diff --git a/xbmc/dialogs/GUIDialogBusy.cpp b/xbmc/dialogs/GUIDialogBusy.cpp
index c8fe070..198af6f 100644
--- a/xbmc/dialogs/GUIDialogBusy.cpp
+++ b/xbmc/dialogs/GUIDialogBusy.cpp
@@ -31,12 +31,12 @@ class CBusyWaiter : public CThread
 public:
   CBusyWaiter(IRunnable *runnable) : CThread(runnable, "waiting"), m_done(new CEvent()) {  }
   
-  bool Wait()
+  bool Wait(unsigned int displaytime, bool allowCancel)
   {
     std::shared_ptr<CEvent> e_done(m_done);
 
     Create();
-    return CGUIDialogBusy::WaitOnEvent(*e_done);
+    return CGUIDialogBusy::WaitOnEvent(*e_done, displaytime, allowCancel);
   }
 
   // 'this' is actually deleted from the thread where it's on the stack
@@ -50,12 +50,12 @@ public:
 
 };
 
-bool CGUIDialogBusy::Wait(IRunnable *runnable)
+bool CGUIDialogBusy::Wait(IRunnable *runnable, unsigned int displaytime /* = 100 */, bool allowCancel /* = true */)
 {
   if (!runnable)
     return false;
   CBusyWaiter waiter(runnable);
-  return waiter.Wait();
+  return waiter.Wait(displaytime, allowCancel);
 }
 
 bool CGUIDialogBusy::WaitOnEvent(CEvent &event, unsigned int displaytime /* = 100 */, bool allowCancel /* = true */)
diff --git a/xbmc/dialogs/GUIDialogBusy.h b/xbmc/dialogs/GUIDialogBusy.h
index 53ba8b9..4e6290c 100644
--- a/xbmc/dialogs/GUIDialogBusy.h
+++ b/xbmc/dialogs/GUIDialogBusy.h
@@ -44,18 +44,20 @@ public:
    Creates a thread to run the given runnable, and while waiting
    it displays the busy dialog.
    \param runnable the IRunnable to run.
+   \param displaytime the time in ms to wait prior to showing the busy dialog (defaults to 100ms)
+   \param allowCancel whether the user can cancel the wait, defaults to true.
    \return true if the runnable completes, false if the user cancels early.
    */
-  static bool Wait(IRunnable *runnable);
+  static bool Wait(IRunnable *runnable, unsigned int displaytime = 100, bool allowCancel = true);
 
   /*! \brief Wait on an event while displaying the busy dialog.
    Throws up the busy dialog after the given time.
-   \param even the CEvent to wait on.
+   \param event the CEvent to wait on.
    \param displaytime the time in ms to wait prior to showing the busy dialog (defaults to 100ms)
    \param allowCancel whether the user can cancel the wait, defaults to true.
    \return true if the event completed, false if cancelled.
    */
-  static bool WaitOnEvent(CEvent &event, unsigned int timeout = 100, bool allowCancel = true);
+  static bool WaitOnEvent(CEvent &event, unsigned int displaytime = 100, bool allowCancel = true);
 protected:
   virtual void Open_Internal(const std::string &param = "");
   bool m_bCanceled;
diff --git a/xbmc/pvr/PVRGUIActions.cpp b/xbmc/pvr/PVRGUIActions.cpp
index 4a8c92a..b7845ec 100644
--- a/xbmc/pvr/PVRGUIActions.cpp
+++ b/xbmc/pvr/PVRGUIActions.cpp
@@ -19,6 +19,7 @@
  */
 
 #include "Application.h"
+#include "dialogs/GUIDialogBusy.h"
 #include "dialogs/GUIDialogKaiToast.h"
 #include "dialogs/GUIDialogNumeric.h"
 #include "dialogs/GUIDialogOK.h"
@@ -51,6 +52,7 @@
 #include "ServiceBroker.h"
 #include "settings/MediaSettings.h"
 #include "settings/Settings.h"
+#include "threads/Thread.h"
 #include "utils/StringUtils.h"
 #include "utils/URIUtils.h"
 #include "utils/log.h"
@@ -700,6 +702,50 @@ namespace PVR
                                             CVariant{timer->Title()});
   }
 
+  class AsyncRecordingAction : private IRunnable
+  {
+  public:
+    bool Execute(const CFileItemPtr &item = CFileItemPtr());
+
+  protected:
+    AsyncRecordingAction() : m_bSuccess(false) {}
+
+  private:
+    // IRunnable implementation
+    void Run() override;
+
+    // the worker function
+    virtual bool DoRun(const CFileItemPtr &item) = 0;
+
+    CFileItemPtr m_item;
+    bool m_bSuccess;
+  };
+
+  bool AsyncRecordingAction::Execute(const CFileItemPtr &item)
+  {
+    m_item = item;
+    CGUIDialogBusy::Wait(this, 100, false);
+    return m_bSuccess;
+  }
+
+  void AsyncRecordingAction::Run()
+  {
+    m_bSuccess = DoRun(m_item);
+
+    if (m_bSuccess)
+      g_PVRManager.TriggerRecordingsUpdate();
+  }
+
+  class AsyncRenameRecording : public AsyncRecordingAction
+  {
+  public:
+    AsyncRenameRecording(const std::string &strNewName) : m_strNewName(strNewName) {}
+
+  private:
+    bool DoRun(const CFileItemPtr &item) override { return g_PVRRecordings->RenameRecording(*item, m_strNewName); }
+    std::string m_strNewName;
+  };
+
   bool CPVRGUIActions::RenameRecording(const CFileItemPtr &item) const
   {
     const CPVRRecordingPtr recording(item->GetPVRRecordingInfoTag());
@@ -710,16 +756,21 @@ namespace PVR
     if (!CGUIKeyboardFactory::ShowAndGetInput(strNewName, CVariant{g_localizeStrings.Get(19041)}, false))
       return false;
 
-    if (!g_PVRRecordings->RenameRecording(*item, strNewName))
+    if (!AsyncRenameRecording(strNewName).Execute(item))
     {
       CGUIDialogOK::ShowAndGetInput(CVariant{257}, CVariant{19111}); // "Error", "PVR backend error. Check the log for more information about this message."
       return false;
     }
 
-    g_PVRManager.TriggerRecordingsUpdate();
     return true;
   }
 
+  class AsyncDeleteRecording : public AsyncRecordingAction
+  {
+  private:
+    bool DoRun(const CFileItemPtr &item) override { return g_PVRRecordings->Delete(*item); }
+  };
+
   bool CPVRGUIActions::DeleteRecording(const CFileItemPtr &item) const
   {
     if ((!item->IsPVRRecording() && !item->m_bIsFolder) || item->IsParentFolder())
@@ -728,13 +779,12 @@ namespace PVR
     if (!ConfirmDeleteRecording(item))
       return false;
 
-    if (!g_PVRRecordings->Delete(*item))
+    if (!AsyncDeleteRecording().Execute(item))
     {
       CGUIDialogOK::ShowAndGetInput(CVariant{257}, CVariant{19111}); // "Error", "PVR backend error. Check the log for more information about this message."
       return false;
     }
 
-    g_PVRManager.TriggerRecordingsUpdate();
     return true;
   }
 
@@ -750,15 +800,20 @@ namespace PVR
                                             CVariant{item->GetLabel()});
   }
 
+  class AsyncEmptyRecordingsTrash : public AsyncRecordingAction
+  {
+  private:
+    bool DoRun(const CFileItemPtr &item) override { return g_PVRRecordings->DeleteAllRecordingsFromTrash(); }
+  };
+
   bool CPVRGUIActions::DeleteAllRecordingsFromTrash() const
   {
     if (!ConfirmDeleteAllRecordingsFromTrash())
       return false;
 
-    if (!g_PVRRecordings->DeleteAllRecordingsFromTrash())
+    if (!AsyncEmptyRecordingsTrash().Execute())
       return false;
 
-    g_PVRManager.TriggerRecordingsUpdate();
     return true;
   }
 
@@ -768,19 +823,23 @@ namespace PVR
                                             CVariant{19293}); // "Remove all deleted recordings from trash? This operation cannot be reverted."
   }
 
+  class AsyncUndeleteRecording : public AsyncRecordingAction
+  {
+  private:
+    bool DoRun(const CFileItemPtr &item) override { return g_PVRRecordings->Undelete(*item); }
+  };
+
   bool CPVRGUIActions::UndeleteRecording(const CFileItemPtr &item) const
   {
     if (!item->IsDeletedPVRRecording())
       return false;
 
-    /* undelete the recording */
-    if (!g_PVRRecordings->Undelete(*item))
+    if (!AsyncUndeleteRecording().Execute(item))
     {
       CGUIDialogOK::ShowAndGetInput(CVariant{257}, CVariant{19111}); // "Error", "PVR backend error. Check the log for more information about this message."
       return false;
     }
 
-    g_PVRManager.TriggerRecordingsUpdate();
     return true;
   }
 
