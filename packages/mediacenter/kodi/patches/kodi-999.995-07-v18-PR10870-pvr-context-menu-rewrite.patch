diff --git a/Kodi.xcodeproj/project.pbxproj b/Kodi.xcodeproj/project.pbxproj
index 7ce0ad3..da0f100 100644
--- a/Kodi.xcodeproj/project.pbxproj
+++ b/Kodi.xcodeproj/project.pbxproj
@@ -140,12 +140,15 @@
 		2A7B2BDD1BD6F16600044BCD /* PVRSettings.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2A7B2BDB1BD6F16600044BCD /* PVRSettings.cpp */; };
 		2AB491701CDDF1920004C263 /* HTTPRequestHandlerUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AB4916E1CDDF1920004C263 /* HTTPRequestHandlerUtils.cpp */; };
 		2AB491711CDDF1920004C263 /* HTTPRequestHandlerUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AB4916E1CDDF1920004C263 /* HTTPRequestHandlerUtils.cpp */; };
+		2ABCFF7D1D998AA70067B4A1 /* PVRGUIActions.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2ABCFF7B1D998AA70067B4A1 /* PVRGUIActions.cpp */; };
 		2AC7EB5A1C21F6BA00BDAA95 /* GUIWindowPVRTimerRules.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AC7EB561C21F6BA00BDAA95 /* GUIWindowPVRTimerRules.cpp */; };
 		2AC7EB5B1C21F6BA00BDAA95 /* GUIWindowPVRTimersBase.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AC7EB581C21F6BA00BDAA95 /* GUIWindowPVRTimersBase.cpp */; };
 		2AC7EB5C1C2330B300BDAA95 /* GUIWindowPVRTimerRules.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AC7EB561C21F6BA00BDAA95 /* GUIWindowPVRTimerRules.cpp */; };
 		2AC7EB5D1C2330BC00BDAA95 /* GUIWindowPVRTimersBase.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AC7EB581C21F6BA00BDAA95 /* GUIWindowPVRTimersBase.cpp */; };
 		2AC7EB601C34893700BDAA95 /* PVRRecordingsPath.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AC7EB5F1C34893700BDAA95 /* PVRRecordingsPath.cpp */; };
 		2AC7EB611C34893700BDAA95 /* PVRRecordingsPath.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AC7EB5F1C34893700BDAA95 /* PVRRecordingsPath.cpp */; };
+		2AE16B841D60DBC4005C20EB /* PVRContextMenus.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AE16B821D60DBC4005C20EB /* PVRContextMenus.cpp */; };
+		2AF0B0971DE1025E005CA6BA /* PVRItem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AF0B0951DE1025E005CA6BA /* PVRItem.cpp */; };
 		2AFBB94C1CC608A200BAB340 /* GUIEPGGridContainerModel.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AFBB94B1CC608A200BAB340 /* GUIEPGGridContainerModel.cpp */; };
 		2AFBB94D1CC608A200BAB340 /* GUIEPGGridContainerModel.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AFBB94B1CC608A200BAB340 /* GUIEPGGridContainerModel.cpp */; };
 		2F4564D51970129A00396109 /* GUIFontCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2F4564D31970129A00396109 /* GUIFontCache.cpp */; };
@@ -2602,17 +2605,25 @@
 		2A5531F81D4A0F9C00BDCE99 /* AddonEvents.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AddonEvents.h; sourceTree = "<group>"; };
 		2A5531F91D4A0FEB00BDCE99 /* EventStream.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EventStream.h; sourceTree = "<group>"; };
 		2A5531FA1D4A0FEB00BDCE99 /* EventStreamDetail.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EventStreamDetail.h; sourceTree = "<group>"; };
+		2A77C42D1DEF5C8400E634EF /* PVRTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PVRTypes.h; sourceTree = "<group>"; };
+		2A77C42F1DEF7A0100E634EF /* EpgTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EpgTypes.h; sourceTree = "<group>"; };
 		2A7B2BDB1BD6F16600044BCD /* PVRSettings.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PVRSettings.cpp; sourceTree = "<group>"; };
 		2A7B2BDE1BD6F18B00044BCD /* PVRSettings.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PVRSettings.h; sourceTree = "<group>"; };
 		2A7E24C71CEBBC3B003096EB /* libKODI_peripheral.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = libKODI_peripheral.h; path = "kodi-addon-dev-kit/include/kodi/libKODI_peripheral.h"; sourceTree = "<group>"; };
 		2AB4916E1CDDF1920004C263 /* HTTPRequestHandlerUtils.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = HTTPRequestHandlerUtils.cpp; sourceTree = "<group>"; };
 		2AB4916F1CDDF1920004C263 /* HTTPRequestHandlerUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = HTTPRequestHandlerUtils.h; sourceTree = "<group>"; };
+		2ABCFF7B1D998AA70067B4A1 /* PVRGUIActions.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PVRGUIActions.cpp; sourceTree = "<group>"; };
+		2ABCFF7C1D998AA70067B4A1 /* PVRGUIActions.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PVRGUIActions.h; sourceTree = "<group>"; };
 		2AC7EB561C21F6BA00BDAA95 /* GUIWindowPVRTimerRules.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GUIWindowPVRTimerRules.cpp; sourceTree = "<group>"; };
 		2AC7EB571C21F6BA00BDAA95 /* GUIWindowPVRTimerRules.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GUIWindowPVRTimerRules.h; sourceTree = "<group>"; };
 		2AC7EB581C21F6BA00BDAA95 /* GUIWindowPVRTimersBase.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GUIWindowPVRTimersBase.cpp; sourceTree = "<group>"; };
 		2AC7EB591C21F6BA00BDAA95 /* GUIWindowPVRTimersBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GUIWindowPVRTimersBase.h; sourceTree = "<group>"; };
 		2AC7EB5E1C34892100BDAA95 /* PVRRecordingsPath.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = PVRRecordingsPath.h; sourceTree = "<group>"; };
 		2AC7EB5F1C34893700BDAA95 /* PVRRecordingsPath.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PVRRecordingsPath.cpp; sourceTree = "<group>"; };
+		2AE16B821D60DBC4005C20EB /* PVRContextMenus.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PVRContextMenus.cpp; sourceTree = "<group>"; };
+		2AE16B831D60DBC4005C20EB /* PVRContextMenus.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PVRContextMenus.h; sourceTree = "<group>"; };
+		2AF0B0951DE1025E005CA6BA /* PVRItem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PVRItem.cpp; sourceTree = "<group>"; };
+		2AF0B0961DE1025E005CA6BA /* PVRItem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PVRItem.h; sourceTree = "<group>"; };
 		2AFB819A1D81D1A2002B82A2 /* PVREvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PVREvent.h; sourceTree = "<group>"; };
 		2AFBB94A1CC6088000BAB340 /* GUIEPGGridContainerModel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GUIEPGGridContainerModel.h; sourceTree = "<group>"; };
 		2AFBB94B1CC608A200BAB340 /* GUIEPGGridContainerModel.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GUIEPGGridContainerModel.cpp; sourceTree = "<group>"; };
@@ -7045,15 +7056,22 @@
 				C84828AD156CFCD8005A996F /* windows */,
 				42DAC16C1A6E789E0066B4C8 /* PVRActionListener.cpp */,
 				42DAC16D1A6E789E0066B4C8 /* PVRActionListener.h */,
+				2AE16B821D60DBC4005C20EB /* PVRContextMenus.cpp */,
+				2AE16B831D60DBC4005C20EB /* PVRContextMenus.h */,
 				C848289B156CFCD8005A996F /* PVRDatabase.cpp */,
 				C848289C156CFCD8005A996F /* PVRDatabase.h */,
 				2AFB819A1D81D1A2002B82A2 /* PVREvent.h */,
+				2ABCFF7B1D998AA70067B4A1 /* PVRGUIActions.cpp */,
+				2ABCFF7C1D998AA70067B4A1 /* PVRGUIActions.h */,
 				C848289D156CFCD8005A996F /* PVRGUIInfo.cpp */,
 				C848289E156CFCD8005A996F /* PVRGUIInfo.h */,
+				2AF0B0951DE1025E005CA6BA /* PVRItem.cpp */,
+				2AF0B0961DE1025E005CA6BA /* PVRItem.h */,
 				C848289F156CFCD8005A996F /* PVRManager.cpp */,
 				C84828A0156CFCD8005A996F /* PVRManager.h */,
 				2A7B2BDB1BD6F16600044BCD /* PVRSettings.cpp */,
 				2A7B2BDE1BD6F18B00044BCD /* PVRSettings.h */,
+				2A77C42D1DEF5C8400E634EF /* PVRTypes.h */,
 			);
 			path = pvr;
 			sourceTree = "<group>";
@@ -7175,6 +7193,7 @@
 				C84828EF156CFD5E005A996F /* EpgInfoTag.h */,
 				C84828F0156CFD5E005A996F /* EpgSearchFilter.cpp */,
 				C84828F1156CFD5E005A996F /* EpgSearchFilter.h */,
+				2A77C42F1DEF7A0100E634EF /* EpgTypes.h */,
 				C84828F2156CFD5E005A996F /* GUIEPGGridContainer.cpp */,
 				C84828F3156CFD5E005A996F /* GUIEPGGridContainer.h */,
 				2AFBB94B1CC608A200BAB340 /* GUIEPGGridContainerModel.cpp */,
@@ -9932,6 +9951,7 @@
 				E38E20630D25F9FD00618676 /* DirectoryNodeMoviesOverview.cpp in Sources */,
 				E38E20640D25F9FD00618676 /* DirectoryNodeMusicVideosOverview.cpp in Sources */,
 				E38E20650D25F9FD00618676 /* DirectoryNodeOverview.cpp in Sources */,
+				2ABCFF7D1D998AA70067B4A1 /* PVRGUIActions.cpp in Sources */,
 				E38E20660D25F9FD00618676 /* DirectoryNodeRecentlyAddedEpisodes.cpp in Sources */,
 				DF4BF01D1A4EF3410053AC56 /* DVDDemuxCC.cpp in Sources */,
 				7C8E02281BA35D0B0072E8B2 /* GUIBuiltins.cpp in Sources */,
@@ -10282,6 +10302,7 @@
 				18B7C38A12942090009E7A26 /* GUIDialogAddonInfo.cpp in Sources */,
 				18B7C38B12942090009E7A26 /* GUIViewStateAddonBrowser.cpp in Sources */,
 				39BD2AD81B845D40004A5A15 /* DialogHelper.cpp in Sources */,
+				2AE16B841D60DBC4005C20EB /* PVRContextMenus.cpp in Sources */,
 				18B7C392129420E5009E7A26 /* Settings.cpp in Sources */,
 				18B7C3A812942132009E7A26 /* AdvancedSettings.cpp in Sources */,
 				395C29DB1A98A11C00EBC7AD /* WsgiResponse.cpp in Sources */,
@@ -10402,6 +10423,7 @@
 				433219D812E4C6A500CD7486 /* udf25.cpp in Sources */,
 				433219D912E4C6A500CD7486 /* UDFDirectory.cpp in Sources */,
 				7C4705AE12EF584C00369E51 /* AddonInstaller.cpp in Sources */,
+				2AF0B0971DE1025E005CA6BA /* PVRItem.cpp in Sources */,
 				18C1D22D13033F6A00CFFE59 /* GLUtils.cpp in Sources */,
 				F56579AF13060D1E0085ED7F /* RenderCapture.cpp in Sources */,
 				6815C1411CC7BADB000DB91A /* RumbleGenerator.cpp in Sources */,
diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index abfc92b..9db838a 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -780,8 +780,10 @@ msgctxt "#179"
 msgid "Song"
 msgstr ""
 
+#. generic "duration" label used in different places
 #: xbmc/dialogs/GUIDialogMediaFilter.cpp
 #: xbmc/playlists/SmartPlaylist.cpp
+#: xbmc/xbmc/pvr/windows/GUIViewStatePVR.cpp
 #: addons/skin.estuary/1080i/Variables.xml
 #: addons/skin.estuary/1080i/View_51_Poster.xml
 #: addons/skin.estuary/1080i/DialogVideoInfo.xml
@@ -850,6 +852,8 @@ msgctxt "#193"
 msgid "Scan"
 msgstr ""
 
+
+#. label for "searching" message box heading
 #: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
 #: xbmc/video/dialogs/GUIDialogVideoInfo.cpp
 #: xbmc/video/windows/GUIWindowVideoBase.cpp
@@ -928,8 +932,12 @@ msgctxt "#207"
 msgid "Plot"
 msgstr ""
 
-#: xbmc/pvr/windows/PVRGUIWindowRecordings.cpp
+#. generic "play" (some sort of media) label used in different places
+#: addons/skin.estuary/1080i/DialogVideoInfo.xml
 #: xbmc/dialogs/GUIDialogPlayEject.cpp
+#: xbmc/games/windows/GUIWindowGames.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
+#: xbmc/video/windows/GUIWindowVideoBase.cpp
 #: system/settings/settings.xml
 msgctxt "#208"
 msgid "Play"
@@ -1207,13 +1215,13 @@ msgstr ""
 #. Label for a context menu entry to start/schedule a recording
 #: xbmc/music/windows/GUIWindowMusicBase.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
-#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
-#: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 #: addons/skin.estuary/1080i/Variables.xml
 msgctxt "#264"
 msgid "Record"
 msgstr ""
 
+#: xbmc/music/windows/GUIWindowMusicBase.cpp
 msgctxt "#265"
 msgid "Stop Rec."
 msgstr ""
@@ -1292,6 +1300,7 @@ msgctxt "#283"
 msgid "Search results"
 msgstr ""
 
+#. generic "no search results found" label used in diferent places
 #: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
 #: xbmc/video/dialogs/GUIDialogVideoInfo.cpp
 #: xbmc/video/windows/GUIWindowVideoBase.cpp
@@ -1386,11 +1395,13 @@ msgctxt "#304"
 msgid "Language"
 msgstr ""
 
-#. Label of active/inactive radiobutton in PVR timer settings dialog
+#. Label of 'Enabled' radiobutton in PVR timer settings dialog
+#. Label of timers state in PVR timer/timer rule window
 #: system/peripherals.xml
 #: xbmc/filesystem/AddonsDirectory.cpp
 #: system/settings/settings.xml
 #: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#305"
 msgid "Enabled"
 msgstr ""
@@ -1427,8 +1438,11 @@ msgctxt "#312"
 msgid "(0=auto)"
 msgstr ""
 
+#. generic "cleaning database" label used in different places
 #: xbmc/music/MusicDatabase.cpp
 #: xbmc/pvr/PVRManager.cpp
+#: xbmc/settings/MediaSettings.cpp
+#: xbmc/video/VideoDatabase.cpp
 msgctxt "#313"
 msgid "Cleaning database"
 msgstr ""
@@ -2456,8 +2470,9 @@ msgctxt "#548"
 msgid "Downmix multichannel audio to stereo"
 msgstr ""
 
-#: /xbmc/xbmc/pvr/windows/GUIViewStatePVR.cpp
-#: /xbmc/xbmc/utils/SortUtils.cpp
+#. generic "number" label used in different places
+#: xbmc/xbmc/pvr/windows/GUIViewStatePVR.cpp
+#: xbmc/xbmc/utils/SortUtils.cpp
 msgctxt "#549"
 msgid "Number"
 msgstr ""
@@ -2467,12 +2482,16 @@ msgctxt "#550"
 msgid "Sort by: %s"
 msgstr ""
 
+#. generic "name" label used in different places
+#: xbmc/xbmc/pvr/windows/GUIViewStatePVR.cpp
 #: xbmc/view/GUIViewState.cpp
 msgctxt "#551"
 msgid "Name"
 msgstr ""
 
+#. generic "date" label used in different places
 #: addons/skin.estuary/1080i/Variables.xml
+#: xbmc/xbmc/pvr/windows/GUIViewStatePVR.cpp
 msgctxt "#552"
 msgid "Date"
 msgstr ""
@@ -2572,8 +2591,10 @@ msgctxt "#567"
 msgid "Play count"
 msgstr ""
 
+#. generic "last played" label used in different places
 #: xbmc/dialogs/GUIDialogMediaFilter.cpp
 #: xbmc/playlists/SmartPlaylist.cpp
+#: xbmc/xbmc/pvr/windows/GUIViewStatePVR.cpp
 msgctxt "#568"
 msgid "Last played"
 msgstr ""
@@ -2700,8 +2721,7 @@ msgstr ""
 #: xbmc/filesystem/AddonsDirectory.cpp
 #: xbmc/PlayListPlayer.cpp
 #: xbmc/profiles/dialogs/GUIDialogLockSettings.cpp
-#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#593"
 msgid "All"
 msgstr ""
@@ -3533,8 +3553,10 @@ msgctxt "#810"
 msgid "Start any time"
 msgstr ""
 
-# Label of "Recording group" list in the PVR timer setting dialog
+#. Label of recording group list control in the PVR timer settings dialog
+#. Part of value of recording group list control in the PVR timer settings dialog (e.g. "Recording Group 1")
 #: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
+#: xbmc/pvr/timers/PVRTimerType.cpp
 msgctxt "#811"
 msgid "Recording group"
 msgstr ""
@@ -3547,26 +3569,26 @@ msgctxt "#812"
 msgid "Prevent duplicate episodes"
 msgstr ""
 
-#. Label of pre-record margin spinner in PVR timer settings dialog
+#. Label of start padding time list control in PVR timer settings dialog
 #: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
 msgctxt "#813"
 msgid "Start padding time"
 msgstr ""
 
-#. Label of post-record margin spinner in PVR timer settings dialog
+#. Label of end padding time list control in PVR timer settings dialog
 #: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
 msgctxt "#814"
 msgid "End padding time"
 msgstr ""
 
-#. Value of prevent duplicate episodes list control
-#: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
+#. Value of prevent duplicate episodes list control in PVR timer settings dialog
+#: xbmc/pvr/timers/PVRTimerType.cpp
 msgctxt "#815"
 msgid "Record all episodes"
 msgstr ""
 
-#. Value of prevent duplicate episodes list control
-#: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
+#. Value of prevent duplicate episodes list control in PVR timer settings dialog
+#: xbmc/pvr/timers/PVRTimerType.cpp
 msgctxt "#816"
 msgid "Record only new episodes"
 msgstr ""
@@ -3577,7 +3599,7 @@ msgctxt "#817"
 msgid "End any time"
 msgstr ""
 
-#. Label of "MaxRecordings" list in the PVR timer setting dialog
+#. Label of "MaxRecordings" list in the PVR timer settings dialog
 #: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
 msgctxt "#818"
 msgid "Max recordings"
@@ -3620,49 +3642,42 @@ msgstr ""
 #empty strings from id 829 to 830
 
 #. Weekday representation
-#: xbmc/dialogs/GUIDialogPVRTimerWeekdaysSettings.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#831"
 msgid "Mondays"
 msgstr ""
 
 #. Weekday representation
-#: xbmc/dialogs/GUIDialogPVRTimerWeekdaysSettings.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#832"
 msgid "Tuesdays"
 msgstr ""
 
 #. Weekday representation
-#: xbmc/dialogs/GUIDialogPVRTimerWeekdaysSettings.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#833"
 msgid "Wednesdays"
 msgstr ""
 
 #. Weekday representation
-#: xbmc/dialogs/GUIDialogPVRTimerWeekdaysSettings.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#834"
 msgid "Thursdays"
 msgstr ""
 
 #. Weekday representation
-#: xbmc/dialogs/GUIDialogPVRTimerWeekdaysSettings.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#835"
 msgid "Fridays"
 msgstr ""
 
 #. Weekday representation
-#: xbmc/dialogs/GUIDialogPVRTimerWeekdaysSettings.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#836"
 msgid "Saturdays"
 msgstr ""
 
 #. Weekday representation
-#: xbmc/dialogs/GUIDialogPVRTimerWeekdaysSettings.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#837"
 msgid "Sundays"
@@ -3671,13 +3686,13 @@ msgstr ""
 #empty strings from id 838 to 839
 
 #. Message in a dialog when a user wants to delete a timer that was scheduled by a timer rule
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#840"
 msgid "Do you only want to delete this timer or also the timer rule that has scheduled it?"
 msgstr ""
 
 #. Label for No button in a dialog when a user wants to delete a timer that was scheduled by a timer rule
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#841"
 msgid "Only this"
 msgstr ""
@@ -3685,37 +3700,37 @@ msgstr ""
 #empty string with id 842
 
 #. Label for a context menu entry to activate a currently inactive timer
-#: xbmc/pvr/windows/GUIWindowPVRTimers.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#843"
 msgid "Activate"
 msgstr ""
 
 #. Label for a context menu entry to deactivate a currently active timer
-#: xbmc/pvr/windows/GUIWindowPVRTimers.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#844"
 msgid "Deactivate"
 msgstr ""
 
 #. Message in a dialog when a user wants to delete a timer rule
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#845"
 msgid "Are you sure you want to delete this timer rule and all timers it has scheduled?"
 msgstr ""
 
 #. Message in a dialog when a user wants to delete a timer
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#846"
 msgid "Are you sure you want to delete this timer?"
 msgstr ""
 
 #. Heading for a dialog for confirming to stop an active recording
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#847"
 msgid "Confirm stop recording"
 msgstr ""
 
 #. Message in a dialog when a user wants to stop an active recording
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#848"
 msgid "Are you sure you want to stop this recording?"
 msgstr ""
@@ -5161,21 +5176,21 @@ msgstr ""
 
 #. Label of various controls for starting playback from the beginning
 #: xbmc/Autorun.cpp
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 #: xbmc/video/windows/GUIWindowVideoBase.cpp
 msgctxt "#12021"
-msgid "Start from beginning"
+msgid "Play from beginning"
 msgstr ""
 
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#. Label of various controls for resuming playback from a certain point in time
+#: xbmc/pvr/PVRGUIActions.cpp
 #: xbmc/video/windows/GUIWindowVideoBase.cpp
 msgctxt "#12022"
 msgid "Resume from %s"
 msgstr ""
 
 #. Label of video/recordings context menu items
-#: xbmc/pvr/windows/PVRGUIWindowRecordings.cpp
 #: xbmc/video/ContextMenus.cpp
 msgctxt "#12023"
 msgid "Play from beginning"
@@ -5748,6 +5763,7 @@ msgstr ""
 
 #empty strings from id 13102 to 13105
 
+#. generic "disabled" label used in different places
 #: xbmc/peripherals/bus/PeripheralBus.cpp
 #: system/settings/settings.xml
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
@@ -5766,7 +5782,7 @@ msgctxt "#13108"
 msgid "Always enabled"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13109"
 msgid "Test & apply the resolution"
 msgstr ""
@@ -5781,38 +5797,42 @@ msgctxt "#13111"
 msgid "Would you like to keep this change?"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13112"
 msgid "High quality upscaling"
 msgstr ""
 
-#: unknown
+#. used by several skins
 msgctxt "#13113"
 msgid "Disabled"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13114"
 msgid "Enabled for SD content"
 msgstr ""
 
+#. unused?
 msgctxt "#13115"
 msgid "Always enabled"
 msgstr ""
 
+#. unused?
 msgctxt "#13116"
 msgid "Upscaling method"
 msgstr ""
 
+#. unused?
 msgctxt "#13117"
 msgid "Bicubic"
 msgstr ""
 
+#. unused?
 msgctxt "#13118"
 msgid "Lanczos"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13119"
 msgid "Sinc"
 msgstr ""
@@ -5824,6 +5844,7 @@ msgstr ""
 
 #empty strings from id 13121 to 13122
 
+#: xbmc/Application.cpp
 msgctxt "#13123"
 msgid "Keep skin?"
 msgstr ""
@@ -5835,12 +5856,12 @@ msgctxt "#13130"
 msgid "Blank other displays"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13131"
 msgid "Disabled"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13132"
 msgid "Blank displays"
 msgstr ""
@@ -5886,7 +5907,7 @@ msgctxt "#13161"
 msgid "Primary DNS"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13162"
 msgid "Initialise failed"
 msgstr ""
@@ -5898,22 +5919,22 @@ msgctxt "#13170"
 msgid "Never"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13171"
 msgid "Immediately"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13172"
 msgid "After %i secs"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13173"
 msgid "HDD install date:"
 msgstr ""
 
-#: unknown
+#. unused?
 msgctxt "#13174"
 msgid "HDD power cycle count:"
 msgstr ""
@@ -5936,54 +5957,71 @@ msgstr ""
 
 #empty strings from id 13202 to 13203
 
-#: unknown
+#. used by several skins
 msgctxt "#13204"
 msgid "Last loaded profile:"
 msgstr ""
 
-#: xbmc/addons/GUIDialogAddonInfo.cpp
-#: xbmc/peripherals/devices/Peripheral.cpp
+#. generic "unknown" label used in different places
+#: xbmc/GUIInfoManager.cpp
+#: xbmc/LangInfo.cpp
+#: xbmc/music/MusicDatabase.cpp
 #: xbmc/peripherals/bus/PeripheralBus.cpp
+#: xbmc/peripherals/devices/Peripheral.cpp
+#: xbmc/platform/win32/WIN32Util.cpp
+#: xbmc/pvr/addons/PVRClients.cpp
+#: xbmc/pvr/channels/PVRChannel.cpp
+#: xbmc/pvr/PVRGUIInfo.cpp
+#: xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
+#: xbmc/video/PlayerController.cpp
 msgctxt "#13205"
 msgid "Unknown"
 msgstr ""
 
+#. unused?
 msgctxt "#13206"
 msgid "Overwrite"
 msgstr ""
 
 #. Subtitle selection to only use forced subtitles
-#:  xbmc/LangInfo.cpp
+#: xbmc/LangInfo.cpp
 msgctxt "#13207"
 msgid "Forced only"
 msgstr ""
 
+#: xbmc/utils/AlarmClock.cpp
 msgctxt "#13208"
 msgid "Alarm clock"
 msgstr ""
 
+#: xbmc/interfaces/builtins/GUIBuiltins.cpp
 msgctxt "#13209"
 msgid "Alarm clock interval (in minutes)"
 msgstr ""
 
+#: xbmc/utils/AlarmClock.cpp
 msgctxt "#13210"
 msgid "Started, alarm in %im"
 msgstr ""
 
+#: xbmc/utils/AlarmClock.cpp
 msgctxt "#13211"
 msgid "Alarm!"
 msgstr ""
 
+#: xbmc/utils/AlarmClock.cpp
 msgctxt "#13212"
 msgid "Cancelled with %im%is left"
 msgstr ""
 
 #. minutes (left from countdown)
+#: xbmc/GUIInfoManager.cpp
 msgctxt "#13213"
 msgid "%2.0fm"
 msgstr ""
 
 #. seconds (left from countdown)
+#: xbmc/GUIInfoManager.cpp
 msgctxt "#13214"
 msgid "%2.0fs"
 msgstr ""
@@ -7807,26 +7845,31 @@ msgstr ""
 
 #empty strings from id 14278 to 14299
 
+#. "pvr manager" settings group label
 #: system/settings/settings.xml
 msgctxt "#14300"
 msgid "PVR Manager"
 msgstr ""
 
+#. pvr "channels" settings group label
 #: system/settings/settings.xml
 msgctxt "#14301"
 msgid "Channels"
 msgstr ""
 
+#. pvr "icons" settings group label
 #: system/settings/settings.xml
 msgctxt "#14302"
 msgid "Icons"
 msgstr ""
 
+#. pvr "epg updates" settings group label
 #: system/settings/settings.xml
 msgctxt "#14303"
 msgid "Updates"
 msgstr ""
 
+#. pvr "RDS" settings group label
 #: system/settings/settings.xml
 msgctxt "#14304"
 msgid "RDS Radio"
@@ -8011,8 +8054,7 @@ msgstr ""
 #empty strings from id 15043 to 15046
 
 #. Label for a context menu entry and dialog button to open audio DSP settings dialog
-#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 #: xbmc/music/windows/GUIWindowMusicBase.cpp
 #: addons/skin.estuary/1080i/Custom_1105_MusicOSDSettings.xml
 msgctxt "#15047"
@@ -8480,6 +8522,8 @@ msgctxt "#16028"
 msgid "Enter value"
 msgstr ""
 
+#. PVR error messages dialog text.
+#: xbmc/addons/PVRClients.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 msgctxt "#16029"
 msgid "Check the log for more information about this message."
@@ -8554,7 +8598,7 @@ msgstr ""
 
 #. Label for a context menu entry to mark an item as watched
 #: xbmc/music/windows/GUIWindowMusicNav.cpp
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 #: xbmc/video/dialogs/GUIDialogVideoInfo.cpp
 #: xbmc/video/windows/GUIWindowVideoNav.cpp
 msgctxt "#16103"
@@ -8563,7 +8607,7 @@ msgstr ""
 
 #. Label for a context menu entry to mark an item as unwatched
 #: xbmc/music/windows/GUIWindowMusicNav.cpp
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 #: xbmc/video/dialogs/GUIDialogVideoInfo.cpp
 #: xbmc/video/windows/GUIWindowVideoNav.cpp
 msgctxt "#16104"
@@ -8856,76 +8900,93 @@ msgctxt "#19002"
 msgid "or use phrases to find an exact match, like \"The wizard of Oz\"."
 msgstr ""
 
-#. Label of a button / context menu entry to find similar programs (matching a given epg event)
-#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
-#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#. Label of a context menu entry to find similar programs (matching a given epg event)
+#: xbmc/pvr/PVRContextMenuItem.cpp
 msgctxt "#19003"
 msgid "Find similar"
 msgstr ""
 
+#. label for epg import progess control
 #: xbmc/epg/EpgContainer.cpp
 msgctxt "#19004"
 msgid "Importing guide from clients"
 msgstr ""
 
-#: addons/skin.estuary/1080i/VideoFullScreen.xml
+#. used by several skins
 msgctxt "#19005"
 msgid "PVR stream information"
 msgstr ""
 
+#. label for 'tuner name' in pvr player information dialog
+#: addons/skin.estuary/1080i/DialogPlayerProcessInfo.xml
 msgctxt "#19006"
 msgid "Receiving device"
 msgstr ""
 
+#. label for 'device status' in pvr player information dialog
+#: addons/skin.estuary/1080i/DialogPlayerProcessInfo.xml
 msgctxt "#19007"
 msgid "Device status"
 msgstr ""
 
-#: addons/skin.estuary/1080i/VideoFullScreen.xml
+#. label for 'signal quality' in pvr player information dialog
+#: addons/skin.estuary/1080i/DialogPlayerProcessInfo.xml
 msgctxt "#19008"
 msgid "Signal quality"
 msgstr ""
 
-#: addons/skin.estuary/1080i/VideoFullScreen.xml
+#. label for 'signal noise ratio' in pvr player information dialog
+#: addons/skin.estuary/1080i/DialogPlayerProcessInfo.xml
 msgctxt "#19009"
 msgid "SNR"
 msgstr ""
 
+#. label for 'bit error ratio' in pvr player information dialog
+#: addons/skin.estuary/1080i/DialogPlayerProcessInfo.xml
 msgctxt "#19010"
 msgid "BER"
 msgstr ""
 
+#. label for 'number of uncorrected errors' in pvr player information dialog
+#: addons/skin.estuary/1080i/DialogPlayerProcessInfo.xml
 msgctxt "#19011"
 msgid "UNC"
 msgstr ""
 
+#. label for PVR backend name in system information's PVR section
 #: xbmc/windows/GUIWindowSystemInfo.cpp
 msgctxt "#19012"
 msgid "PVR backend"
 msgstr ""
 
+#. PVR 'channel encryption system' textual presentation for free to air channels
 #: xbmc/pvr/channels/PVRChannel.cpp
 msgctxt "#19013"
 msgid "Free to air"
 msgstr ""
 
+#. PVR 'channel encryption system' textual presentation for 'fixed' channels
 #: xbmc/pvr/channels/PVRChannel.cpp
 msgctxt "#19014"
 msgid "Fixed"
 msgstr ""
 
+#. label for 'channel encryption' in pvr player information dialog
+#: addons/skin.estuary/1080i/DialogPlayerProcessInfo.xml
 msgctxt "#19015"
 msgid "Encryption"
 msgstr ""
 
-#: unused
+#. unused?
 msgctxt "#19016"
 msgid "PVR backend %i - %s"
 msgstr ""
 
-#: xbmc/dialogs/GUIDialogMediaSource.cpp
+#. generic label for pvr recordings used in different places
+#: addons/skin.estuary/1080i/Home.xml
 #: addons/skin.estuary/1080i/Variables.xml
+#: xbmc/dialogs/GUIDialogMediaSource.cpp
+#: xbmc/filesystem/PVRDirectory.cpp
 msgctxt "#19017"
 msgid "Recordings"
 msgstr ""
@@ -8936,37 +8997,45 @@ msgctxt "#19018"
 msgid "Folder with channel icons"
 msgstr ""
 
-#: xbmc/windows/GUIWindowSystemInfo.cpp
+#. label for PVR backend number of channels in system information's PVR section
 #: addons/skin.estuary/1080i/DialogPVRGuideOSD.xml
 #: addons/skin.estuary/1080i/DialogPVRChannelManager.xml
 #: addons/skin.estuary/1080i/DialogPVRChannelsOSD.xml
 #: addons/skin.estuary/1080i/Variables.xml
 #: addons/skin.estuary/1080i/Home.xml
+#: xbmc/windows/GUIWindowSystemInfo.cpp
 msgctxt "#19019"
 msgid "Channels"
 msgstr ""
 
+#. generic label for 'Live TV' used in different places
+#: addons/skin.estuary/1080i/Home.xml
+#: addons/skin.estuary/1080i/SkinSettings.xml:
+#: addons/skin.estuary/1080i/Variables.xml
 #: xbmc/pvr/channels/PVRChannelGroupsContainer.cpp
 #: xbmc/pvr/PVRManager.cpp
-#: addons/skin.estuary/1080i/Includes.xml
-#: addons/skin.estuary/1080i/Home.xml
 msgctxt "#19020"
 msgid "TV"
 msgstr ""
 
+#. generic label for pvr-provided 'Radio' used in different places
+#: addons/skin.estuary/1080i/Home.xml
+#: addons/skin.estuary/1080i/SkinSettings.xml
+#: addons/skin.estuary/1080i/Variables.xml
 #: xbmc/pvr/channels/PVRChannelGroupsContainer.cpp
 #: xbmc/pvr/PVRManager.cpp
-#: addons/skin.estuary/1080i/Home.xml
 msgctxt "#19021"
 msgid "Radio"
 msgstr ""
 
+#. generic 'hidden' label used in different places
 #: xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
 #: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 msgctxt "#19022"
 msgid "Hidden"
 msgstr ""
 
+#. generic label for 'Live TV channels' used in different places
 #: xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
 #: addons/skin.estuary/1080i/Variables.xml
 #: addons/skin.estuary/1080i/DialogPVRChannelManager.xml
@@ -8974,6 +9043,7 @@ msgctxt "#19023"
 msgid "TV channels"
 msgstr ""
 
+#. generic label for pvr-provided 'Radio channels' used in different places
 #: xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
 #: addons/skin.estuary/1080i/DialogPVRChannelManager.xml
 #: addons/skin.estuary/1080i/Variables.xml
@@ -8981,54 +9051,75 @@ msgctxt "#19024"
 msgid "Radio channels"
 msgstr ""
 
+#. label for PVR backend number of timers in system information's PVR section
 #: xbmc/windows/GUIWindowSystemInfo.cpp
 msgctxt "#19025"
 msgid "Upcoming recordings"
 msgstr ""
 
+#. label for "add timer..." list item used in pvr timers / timer rules window
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
+#: xbmc/pvr/timers/PVRTimers.cpp
 msgctxt "#19026"
 msgid "Add timer..."
 msgstr ""
 
+#. unused?
 msgctxt "#19027"
 msgid "No search results"
 msgstr ""
 
+#. label used in pvr guide window views to indicate that there are no epg data for the current view (channel, now, next)
+#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
 msgctxt "#19028"
 msgid "No guide entries"
 msgstr ""
 
+#. generic 'channel' label used in different places
 #: addons/skin.estuary/1080i/DialogFullScreenInfo.xml
-#: addons/skin.estuary/1080i/MyPVRGuide.xml
+#: xbmc/filesystem/PluginDirectory.cpp
+#: xbmc/pvr/channels/PVRChannel.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
+#: xbmc/utils/SortUtils.cpp
 msgctxt "#19029"
 msgid "Channel"
 msgstr ""
 
+#. generic 'now' label used in diffrent places
 #: addons/skin.estuary/1080i/DialogPVRRadioRDSInfo.xml
 #: addons/skin.estuary/1080i/MyWeather.xml
+#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
 msgctxt "#19030"
 msgid "Now"
 msgstr ""
 
-#. Label prefix for the next playing tv-show (PVR) or media, like "Next: The Simpsons", "Next: AC/DC - Thunderstruck". It's also used as EPG display mode (EPG: timeline / now / next)
+#. generic 'next' label used in diffrent places in pvr context
 #: addons/skin.estuary/1080i/DialogFullScreenInfo.xml
 #: addons/skin.estuary/1080i/DialogPVRRadioRDSInfo.xml
+#: addons/skin.estuary/1080i/MyPVRChannels.xml
+#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
 msgctxt "#19031"
 msgid "Next"
 msgstr ""
 
+#. 'timeline' label used in pvr guide window
 #: addons/skin.estuary/1080i/MyPVRGuide.xml
+#. xbmc/pvr/windows/GUIWindowPVRGuide.cpp
 msgctxt "#19032"
 msgid "Timeline"
 msgstr ""
 
+#. generic 'information' label used in different places, like labels for message box headers
 #: xbmc/event/windows/GUIWindowEventLog.cpp
 #: xbmc/pvr/addons/PVRClients.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
-#: xbmc/pvr/PVRManager.cpp
+#: xbmc/pvr/recordings/PVRRecording.cpp
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 #: xbmc/pvr/timers/PVRTimers.cpp
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
-#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
+#: xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
+#: xbmc/pvr/PVRManager.cpp
 #: xbmc/video/windows/GUIWindowVideoBase.cpp
 #: addons/skin.estuary/1080i/VideoOSD.xml
 msgctxt "#19033"
@@ -9036,32 +9127,39 @@ msgid "Information"
 msgstr ""
 
 #. message box text stating that a timer is already set for a given epg event.
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19034"
 msgid "There is already a timer set for this event"
 msgstr ""
 
+#. message box text stating that a pvr channel could not be played.
+#: xbmc/pvr/PVRGUIActions.cpp
+#: xbmc/pvr/PVRManager.cpp
 msgctxt "#19035"
-msgid "%s couldn't be played. Check the log for more information about this message."
+msgid "%s can't be played. Check the log for more information about this message."
 msgstr ""
 
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#. message box text stating that a recording could not be played.
+#: xbmc/pvr/PVRGUIActions.cpp
 #: xbmc/video/windows/GUIWindowVideoBase.cpp
 msgctxt "#19036"
 msgid "This recording can't be played. Check the log for more information about this message."
 msgstr ""
 
+#. pvr settings "show signal quality" label
 #: system/settings/settings.xml
 msgctxt "#19037"
 msgid "Show signal quality"
 msgstr ""
 
+#. message box text stating that a PVR backend does not support a certain functionality.
 #: xbmc/pvr/addons/PVRClients.cpp
-#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 msgctxt "#19038"
 msgid "Not supported by the PVR backend."
 msgstr ""
 
+#. message box text asking for confirmation to hide a channel.
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19039"
 msgid "Are you sure you want to hide this channel?"
 msgstr ""
@@ -9071,48 +9169,59 @@ msgctxt "#19040"
 msgid "Timers"
 msgstr ""
 
+#. label for "rename recording" confirmation input dialog
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19041"
 msgid "Are you sure you want to rename this recording?"
 msgstr ""
 
+#. label for "rename timer" confirmation input dialog
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19042"
 msgid "Are you sure you want to rename this timer?"
 msgstr ""
 
+#. pvr settings "recording" category label
 #: system/settings/settings.xml
 msgctxt "#19043"
 msgid "Recording"
 msgstr ""
 
+#: @@@ unused?
 msgctxt "#19044"
 msgid "Please check your configuration. Check the log for more information about this message."
 msgstr ""
 
+#: @@@ unused?
 msgctxt "#19045"
 msgid "No PVR clients have been started yet. Wait for the PVR clients to start up. Check the log for more information about this message."
 msgstr ""
 
+#: @@@ unused?
 msgctxt "#19046"
 msgid "New channel"
 msgstr ""
 
 #. Label for a context menu entry to open an EPG event information dialog
-#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
-#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
-#: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
-#: xbmc/pvr/windows/GUIWindowPVRtimers.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#19047"
 msgid "Programme information"
 msgstr ""
 
+#. pvr settings "group manager" action button label
+#. Label for a context menu entry to open the pvr channel group manager dialog
+#: system/settings/settings.xml
+#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 msgctxt "#19048"
 msgid "Group manager"
 msgstr ""
 
+#: @@@ unused?
 msgctxt "#19049"
 msgid "Show channel"
 msgstr ""
 
+#: @@@ unused?
 msgctxt "#19050"
 msgid "Show visible channels"
 msgstr ""
@@ -9122,35 +9231,42 @@ msgctxt "#19051"
 msgid "Show hidden channels"
 msgstr ""
 
+#: @@@ unused?
 msgctxt "#19052"
 msgid "Move channel to:"
 msgstr ""
 
 #. Label for a context menu entry to open recording info dialog
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#19053"
 msgid "Recording information"
 msgstr ""
 
+#. header label for hide channel confirmation message box
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19054"
 msgid "Hide channel"
 msgstr ""
 
-#: xbmc/epg/EpgInfoTag.cpp
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
-#: addons/skin.estuary/1080i/View_50_List.xml
+#. generic text used in several places to state that there is no information available
 #: addons/skin.estuary/1080i/DialogMusicInfo.xml
-#: addons/skin.estuary/1080i/MyPics.xml
-#: addons/skin.estuary/1080i/MyVideoNav.xml
-#: addons/skin.estuary/1080i/Includes_PVR.xml
 #: addons/skin.estuary/1080i/DialogVideoInfo.xml
+#: addons/skin.estuary/1080i/Includes_PVR.xml
+#: addons/skin.estuary/1080i/MyGames.xml
 #: addons/skin.estuary/1080i/MyMusicNav.xml
+#: addons/skin.estuary/1080i/MyPics.xml
+#: addons/skin.estuary/1080i/MyVideoNav.xml
+#: addons/skin.estuary/1080i/View_50_List.xml
+#: xbmc/epg/EpgInfoTag.cpp
+#: xbmc/FileItem.cpp
+#: xbmc/GUIInfoManager.cpp
+#: xbmc/pvr/PVRManager.cpp
+#: xbmc/utils/SystemInfo.cpp
 msgctxt "#19055"
 msgid "No information available"
 msgstr ""
 
 #. Label for a new timer
-#: xbmc/pvr/timers/PVRTimers.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
 msgctxt "#19056"
@@ -9169,79 +9285,94 @@ msgctxt "#19058"
 msgid "Timer enabled"
 msgstr ""
 
+#. Label for a context menu entry and for a button to stop a recording
+#: xbmc/pvr/PVRContextMenus.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
 msgctxt "#19059"
 msgid "Stop recording"
 msgstr ""
 
 #. Label for a context menu entry to delete a timer associated with an epg event and for a button to delete a timer in epg event info dialog
+#: xbmc/pvr/PVRContextMenus.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
-#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
-#: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
 msgctxt "#19060"
 msgid "Delete timer"
 msgstr ""
 
 #. Label for a context menu entry to open the timer settings dialog
-#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
-#: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 #: addons/skin.estuary/1080i/DialogPVRInfo.xml
 msgctxt "#19061"
 msgid "Add timer"
 msgstr ""
 
+#: @@@ unused?
 msgctxt "#19062"
 msgid "Sort by: Channel"
 msgstr ""
 
+#. Label for epg grid window "jump to grid start" (oldest available events) context menu entry
+#: /xbmc/pvr/windows/GUIWindowPVRGuide.cpp
 msgctxt "#19063"
 msgid "Go to beginning"
 msgstr ""
 
+#. Label for epg grid window "jump to grid end" (youngest available events) context menu entry
+#: /xbmc/pvr/windows/GUIWindowPVRGuide.cpp
 msgctxt "#19064"
 msgid "Go to end"
 msgstr ""
 
+#. Label for timer settings dialog header
+#: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
 msgctxt "#19065"
 msgid "Timer settings"
 msgstr ""
 
 #. Name of a shortcut to a custom folder for channel icons
-#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 msgctxt "#19066"
 msgid "Channel icons"
 msgstr ""
 
+#. message box text stating that an epg event is already being recorded
 #: xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19067"
 msgid "This event is already being recorded."
 msgstr ""
 
+#. error box text stating that a given pvr recording could not be deleted
 #: xbmc/pvr/recording/PVRRecording.cpp
 msgctxt "#19068"
 msgid "This recording couldn't be deleted. Check the log for more information about this message."
 msgstr ""
 
-#. Electronic program guide. used by ?
+#. Electronic program guide
 #: addons/skin.estuary/1080i/Variables.xml
 msgctxt "#19069"
 msgid "Guide"
 msgstr ""
 
+#. Label for epg grid window "jump to now" (current epg events) context menu entry
+#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
 msgctxt "#19070"
 msgid "Go to now"
 msgstr ""
 
+#. pvr settings "epg update interval" setting label
+#: system/settings/settings.xml
 msgctxt "#19071"
 msgid "Update interval"
 msgstr ""
 
+#. pvr settings "do not store epg data in local database" setting label
 #: system/settings/settings.xml
 msgctxt "#19072"
 msgid "Don't cache in local database"
 msgstr ""
 
+#. pvr settings "delay channel switch" setting label
 #: system/settings/settings.xml
 msgctxt "#19073"
 msgid "Delay channel switch"
@@ -9275,17 +9406,19 @@ msgctxt "#19078"
 msgid "Channel"
 msgstr ""
 
-#. heading for PVR timer days of week settings dialog
+#. Heading for PVR timer days of week settings dialog
 #. Label of days of week button in PVR timer settings dialog
 #: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
 msgctxt "#19079"
 msgid "Days of week"
 msgstr ""
 
+#. used by several skins
 msgctxt "#19080"
 msgid "Begin"
 msgstr ""
 
+#. used by several skins
 msgctxt "#19081"
 msgid "End"
 msgstr ""
@@ -9308,6 +9441,8 @@ msgctxt "#19084"
 msgid "First day"
 msgstr ""
 
+#. default for channels without a name. place holder will be filled with channel number.
+#: xbmc/pvr/channels/PVRChannel.cpp
 msgctxt "#19085"
 msgid "Unknown channel %u"
 msgstr ""
@@ -9362,90 +9497,110 @@ msgid "Instant recording: %s"
 msgstr ""
 
 #. error message displayed in case adding a timer failed because no suitable epg-based timer type could be found.
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19094"
 msgid "Timer creation failed. The PVR add-on does not support a suitable timer type."
 msgstr ""
 
 #. error message displayed in case adding a timer rule failed because no suitable epg-based timer rule type could be found.
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19095"
 msgid "Timer rule creation failed. The PVR add-on does not support a suitable timer rule type."
 msgstr ""
 
 #empty string with id 19096
 
+#. label of the help text for the timer name edit field in PVR timer settings dialog
+#: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
 msgctxt "#19097"
-msgid "Enter the name for the recording"
+msgid "Enter the name for the timer"
 msgstr ""
 
+#. generic warning label used at several places
 #: xbmc/addons/AddonSystemSettings.cpp
 #: xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.cpp
 #: xbmc/pvr/channels/PVRChannelGroupInternal.cpp
 #: xbmc/pvr/PVRManager.cpp
-#: xbmc/settings/dialogs/GUIDialogAudioDSPManager.cpp:
+#: xbmc/settings/dialogs/GUIDialogAudioDSPManager.cpp
 msgctxt "#19098"
 msgid "Warning!"
 msgstr ""
 
-#: xbmc/pvr/PVRGUIInfo.cpp
+#. service label in pvr info dialog
+#: addons/skin.estuary/1080i/DialogPlayerProcessInfo.xml
 msgctxt "#19099"
 msgid "Service"
 msgstr ""
 
-#: xbmc/pvr/PVRGUIInfo.cpp
+#. mux label in pvr info dialog
+#: addons/skin.estuary/1080i/DialogPlayerProcessInfo.xml
 msgctxt "#19100"
 msgid "Mux"
 msgstr ""
 
-#: xbmc/pvr/PVRGUIInfo.cpp
+#. provider label in pvr info dialog
+#: addons/skin.estuary/1080i/DialogPlayerProcessInfo.xml
 msgctxt "#19101"
 msgid "Provider"
 msgstr ""
 
+#. message box text prompting user to switch to nother channel
 #: xbmc/pvr/channels/PVRChannelGroupInternal.cpp
 msgctxt "#19102"
 msgid "Please switch to another channel."
 msgstr ""
 
 #. Title of numeric dialog for choosing a channel by entering a number
-#: xbmc/pvr/windows/GUIWindowPVRCommon.cpp
+#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
+#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
 msgctxt "#19103"
 msgid "Go to channel"
 msgstr ""
 
+#. label of the help text for the recording folder edit field in PVR timer settings dialog
+#: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
 msgctxt "#19104"
 msgid "Enter the name of the folder for the recording"
 msgstr ""
 
+#. unused?
 msgctxt "#19105"
 msgid "Please select a channel"
 msgstr ""
 
+#. part of timer information text (e.g. "Next timer on 10/10/2016 at 9:00 AM")
+#: xbmc/pvr/PVRGUIInfo.cpp
 msgctxt "#19106"
 msgid "Next timer on"
 msgstr ""
 
+#. part of timer information text (e.g. "Next timer on 10/10/2016 at 9:00 AM")
+#: xbmc/pvr/PVRGUIInfo.cpp
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19107"
 msgid "at"
 msgstr ""
 
+#. label for PVR settings "tv fallback framerate" (in Hz) selector
 #: system/settings/settings.xml
 msgctxt "#19108"
 msgid "Fallback framerate"
 msgstr ""
 
+#. message box text stating that a timer could not be saved
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 #: xbmc/pvr/timers/PVRTimers.cpp
 msgctxt "#19109"
 msgid "Couldn't save timer. Check the log for more information about this message."
 msgstr ""
 
+#. message box text stating that an unexpected error occured
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19110"
 msgid "An unexpected error occurred. Try again later or check the log for more information."
 msgstr ""
 
+#. message box text stating that a PVR backend error occured
 #: xbmc/pvr/addons/PVRClients.cpp
 #: xbmc/pvr/recording/PVRRecording.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
@@ -9453,42 +9608,54 @@ msgctxt "#19111"
 msgid "PVR backend error. Check the log for more information about this message."
 msgstr ""
 
+#. delete recordings confirmation message box text
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19112"
 msgid "Delete this recording?"
 msgstr ""
 
+#. delete multiple recordings confirmation message box text
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19113"
 msgid "Delete all recordings in this folder?"
 msgstr ""
 
+#. label for PVR backend version in system information's PVR section
 #: xbmc/windows/GUIWindowSystemInfo.cpp
 msgctxt "#19114"
 msgid "Version"
 msgstr ""
 
+#. label for PVR backend address (e.g. ID address of the PVR backend server) in system information's PVR section
 #: xbmc/windows/GUIWindowSystemInfo.cpp
 msgctxt "#19115"
 msgid "Address"
 msgstr ""
 
+#. label for PVR backend disk size in system information's PVR section
 #: xbmc/windows/GUIWindowSystemInfo.cpp
 msgctxt "#19116"
 msgid "Disksize"
 msgstr ""
 
+#. label for PVR settings channels search action control
 #: system/settings/settings.xml
 msgctxt "#19117"
 msgid "Search for channels"
 msgstr ""
 
+#. unused?
 msgctxt "#19118"
 msgid "Can't use PVR functions while searching."
 msgstr ""
 
+#. channel scan backend selection dialog text
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#19119"
-msgid "On which server do you want to search?"
+msgid "On which backend do you want to search?"
 msgstr ""
 
+#. label for PVR client number in system information's PVR section
 #: xbmc/windows/GUIWindowSystemInfo.cpp
 msgctxt "#19120"
 msgid "Client number"
@@ -9499,6 +9666,8 @@ msgctxt "#19121"
 msgid "Avoid repeats"
 msgstr ""
 
+#. delete active timer confirmation message box text
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19122"
 msgid "This timer is still recording. Are you sure you want to delete this timer?"
 msgstr ""
@@ -9561,6 +9730,7 @@ msgctxt "#19132"
 msgid "Include unknown genres"
 msgstr ""
 
+#: addons/skin.estuary/1080i/DialogPVRGuideSearch.xml
 msgctxt "#19133"
 msgid "Search string"
 msgstr ""
@@ -9575,10 +9745,12 @@ msgctxt "#19135"
 msgid "Case sensitive"
 msgstr ""
 
+#. unused?
 msgctxt "#19136"
 msgid "Channel unavailable"
 msgstr ""
 
+#. channel group manager dialog error message box text
 #: xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
 msgctxt "#19137"
 msgid "No groups defined. Please create a group first"
@@ -9590,41 +9762,52 @@ msgctxt "#19138"
 msgid "Timer rules"
 msgstr ""
 
+#. channel group manager dialog create group / rename group message box text
+#: xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
 msgctxt "#19139"
 msgid "Name of the new group"
 msgstr ""
 
+#. PVR search window 'search' list item label
 #: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
 msgctxt "#19140"
 msgid "Search..."
 msgstr ""
 
+#. part of PVR window's active channel group label (e.g. "Group: HD Sports Channels")
 #: addons/skin.estuary/1080i/Includes_MediaMenu.xml
 #: addons/skin.estuary/1080i/DialogPVRGuideSearch.xml
+#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
 msgctxt "#19141"
 msgid "Group"
 msgstr ""
 
+#: addons/skin.estuary/1080i/DialogPVRGuideSearch.xml
 msgctxt "#19142"
 msgid "Search guide"
 msgstr ""
 
+#: addons/skin.estuary/1080i/DialogPVRGroupManager.xml
 msgctxt "#19143"
 msgid "Group management"
 msgstr ""
 
+#. used by several skins
 msgctxt "#19144"
 msgid "No groups defined"
 msgstr ""
 
+#. used by several skins
 msgctxt "#19145"
 msgid "Grouped"
 msgstr ""
 
+#: addons/skin.estuary/1080i/DialogPVRChannelsOSD.xml
 msgctxt "#19146"
 msgid "Groups"
 msgstr ""
 
+#. message box text stating that a PVR backend does not support a certain functionality.
 #: xbmc/pvr/recording/PVRRecording.cpp
 msgctxt "#19147"
 msgid "The PVR backend does not support this action. Check the log for more information about this message."
@@ -9636,202 +9819,249 @@ msgctxt "#19148"
 msgid "Channel"
 msgstr ""
 
+#. part of timer rule textual weekdays representation (e.g. "Mo-Tu-Fr-Su", "Mo-Tu-__-__-Fr-__-Su")
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19149"
 msgid "Mo"
 msgstr ""
 
+#. part of timer rule textual weekdays representation (e.g. "Mo-Tu-Fr-Su", "Mo-Tu-__-__-Fr-__-Su")
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19150"
 msgid "Tu"
 msgstr ""
 
+#. part of timer rule textual weekdays representation (e.g. "Mo-Tu-Fr-Su", "Mo-Tu-__-__-Fr-__-Su")
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19151"
 msgid "We"
 msgstr ""
 
+#. part of timer rule textual weekdays representation (e.g. "Mo-Tu-Fr-Su", "Mo-Tu-__-__-Fr-__-Su")
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19152"
 msgid "Th"
 msgstr ""
 
+#. part of timer rule textual weekdays representation (e.g. "Mo-Tu-Fr-Su", "Mo-Tu-__-__-Fr-__-Su")
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19153"
 msgid "Fr"
 msgstr ""
 
+#. part of timer rule textual weekdays representation (e.g. "Mo-Tu-Fr-Su", "Mo-Tu-__-__-Fr-__-Su")
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19154"
 msgid "Sa"
 msgstr ""
 
+#. part of timer rule textual weekdays representation (e.g. "Mo-Tu-Fr-Su", "Mo-Tu-__-__-Fr-__-Su")
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19155"
 msgid "Su"
 msgstr ""
 
+#. unused?
 msgctxt "#19156"
 msgid "from"
 msgstr ""
 
+#: addons/skin.estuary/1080i/Home.xml
 msgctxt "#19157"
 msgid "Next recording"
 msgstr ""
 
+#: addons/skin.estuary/1080i/Home.xml
 msgctxt "#19158"
 msgid "Currently recording"
 msgstr ""
 
+#. part of timer / timer rule textual representation (e.g. "10/10/2016 from 11:00 PM to 10/11/2016 1:00 AM". "Mondays from any time to any time")
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19159"
 msgid "from"
 msgstr ""
 
+#. part of timer / timer rule textual representation (e.g. "10/10/2016 from 11:00 PM to 10/11/2016 1:00 AM". "Mondays from any time to any time")
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19160"
 msgid "to"
 msgstr ""
 
-#. timer rule presentation string. <start-day-date|days-of-week> "from" <start-day-time|"any time"> "to" <end-day-time|"any time">
+#. timer rule presentation string. (start-day-date|days-of-week) "from" (start-day-time|"any time") "to" (end-day-time|"any time")
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19161"
 msgid "any time"
 msgstr ""
 
+#. timer status textual representation
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19162"
 msgid "Recording active"
 msgstr ""
 
+#. label for number of PVR recordings in system information's PVR section
 #: xbmc/windows/GUIWindowSystemInfo.cpp
 msgctxt "#19163"
 msgid "Recordings"
 msgstr ""
 
+#. error box text stating that recording could not be started
 #: xbmc/pvr/PVRManager.cpp
 msgctxt "#19164"
 msgid "Can't start recording. Check the log for more information about this message."
 msgstr ""
 
+#: addons/skin.estuary/1080i/DialogPVRInfo.xml
 msgctxt "#19165"
 msgid "Switch"
 msgstr ""
 
+#. label for header of system information's PVR section
 #: xbmc/windows/GUIWindowSystemInfo.cpp
 msgctxt "#19166"
 msgid "PVR information"
 msgstr ""
 
+#. pvr settings "scan for missing channel icons" action button label
 #: system/settings/settings.xml
 msgctxt "#19167"
 msgid "Scan for missing icons"
 msgstr ""
 
-#. Used in system info to show amount of it
+#. label for PVR number of deleted recordings in system information's PVR section
 #: xbmc/windows/GUIWindowSystemInfo.cpp
 msgctxt "#19168"
 msgid "Deleted and recoverable recordings"
 msgstr ""
 
+#. unused?
 msgctxt "#19169"
 msgid "Hide video information box"
 msgstr ""
 
+#. pvr settings "playback timeout" setting label
 #: system/settings/settings.xml
 msgctxt "#19170"
 msgid "Timeout when starting playback"
 msgstr ""
 
+#. pvr settings "start playback in a window instead of full screen" setting label
 #: system/settings/settings.xml
 msgctxt "#19171"
 msgid "Start playback minimised"
 msgstr ""
 
+#. pvr settings "duration for an instant recording" setting label
 #: system/settings/settings.xml
 msgctxt "#19172"
 msgid "Instant recording duration"
 msgstr ""
 
+#. pvr settings "default priority for recordings" setting label
 #: system/settings/settings.xml
 msgctxt "#19173"
 msgid "Default recording priority"
 msgstr ""
 
+#. pvr settings "default lifetime for recordings" setting label
 #: system/settings/settings.xml
 msgctxt "#19174"
 msgid "Default recording lifetime"
 msgstr ""
 
+#. pvr settings "default time to add before the start of an event to record (according to its epg data)" setting label
 #: system/settings/settings.xml
 msgctxt "#19175"
 msgid "Default start padding time"
 msgstr ""
 
+#. pvr settings "default time to add after the end of an event to record (according to epg its data)" setting label
 #: system/settings/settings.xml
 msgctxt "#19176"
 msgid "Default end padding time"
 msgstr ""
 
+#. pvr settings category and group label
 #: system/settings/settings.xml
 msgctxt "#19177"
 msgid "Playback"
 msgstr ""
 
+#. pvr setting "show channel info while switching channels" value
 #: system/settings/settings.xml
 msgctxt "#19178"
 msgid "Show channel information when switching channels"
 msgstr ""
 
-#. Used as extension header on recordings window
+#. header used in pvr recordings window
 #: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
 msgctxt "#19179"
 msgid "Deleted"
 msgstr ""
 
-#. Settings -> Interface -> Other -> Startup window
+#. Settings -> Interface -> Other -> Startup window value
 #: system/settings/settings.xml
 msgctxt "#19180"
 msgid "TV channels"
 msgstr ""
 
+#. pvr settings "Menu / OSD" category label
 #: system/settings/settings.xml
 msgctxt "#19181"
 msgid "Menu / OSD"
 msgstr ""
 
+#. pvr settings "epg days to display" setting value
 #: system/settings/settings.xml
 msgctxt "#19182"
 msgid "Days to display"
 msgstr ""
 
-#. Settings -> Interface -> Other -> Startup window
+#. Settings -> Interface -> Other -> Startup window value
 #: system/settings/settings.xml
 msgctxt "#19183"
 msgid "Radio channels"
 msgstr ""
 
-#. Used on pvr recordings as button to show of them
+#. label for "deleted recordings" data source in media source window
 #: addons/skin.estuary/1080i/Includes_MediaMenu.xml
+#: xbmc/dialogs/GUIDialogMediaSource.cpp
 msgctxt "#19184"
 msgid "Deleted recordings"
 msgstr ""
 
+#. pvr settings "clear epg data" action button label
 #: system/settings/settings.xml
 msgctxt "#19185"
 msgid "Clear data"
 msgstr ""
 
+#. message box text for pvr data reset confirmation
 #: xbmc/pvr/PVRManager.cpp
 msgctxt "#19186"
 msgid "All your TV related data (channels, groups, guide) will be cleared. Are you sure?"
 msgstr ""
 
+#. progress dialog text shown while purging pvr data
 #: xbmc/pvr/PVRManager.cpp
 msgctxt "#19187"
 msgid "Clearing all related data."
 msgstr ""
 
+#. message box text for epg data reset confirmation
 #: xbmc/pvr/PVRManager.cpp
 msgctxt "#19188"
 msgid "All your guide data will be cleared. Are you sure?"
 msgstr ""
 
+#. pvr settings "automatically start last played channel after Kodi startup" setting label
 #: system/settings/settings.xml
 msgctxt "#19189"
 msgid "Continue last channel on startup"
 msgstr ""
 
+#. pvr settings "automatically start last played channel after Kodi startup" setting value
 #: system/settings/settings.xml
 msgctxt "#19190"
 msgid "Background"
@@ -9842,38 +10072,48 @@ msgctxt "#19191"
 msgid "PVR service"
 msgstr ""
 
+#. error message box text stating that none of the available pvr clients does support channel scanning
 #: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#19192"
 msgid "None of the connected PVR backends supports scanning for channels."
 msgstr ""
 
+#. error message box text stating that a given pvr channel could not be played
 #: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#19193"
 msgid "The channel scan can't be started. Check the log for more information about this message."
 msgstr ""
 
+#. unused?
 msgctxt "#19194"
 msgid "Continue?"
 msgstr ""
 
+#. label for a context menu entry for pvr client specific actions
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#19195"
 msgid "Client actions"
 msgstr ""
 
+#. value for "pvr client specific actions" dialog headers
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#19196"
 msgid "PVR client specific actions"
 msgstr ""
 
-#: xbmc/addons/addoncallbackspvr.cpp
+#. text for "recording started on <pvr client name>" pvr client addon callback notification
+#: xbmc/addons/binary/interfaces/api1/PVR/AddonCallbacksPVR.cpp
 msgctxt "#19197"
 msgid "Recording started on: %s"
 msgstr ""
 
-#: xbmc/addons/addoncallbackspvr.cpp
+#. text for "recording finished on <pvr client name>" pvr client addon callback notification
+#: xbmc/addons/binary/interfaces/api1/PVR/AddonCallbacksPVR.cpp
 msgctxt "#19198"
 msgid "Recording finished on: %s"
 msgstr ""
 
+#. pvr settings "channel manager" action button label
 #: system/settings/settings.xml
 #: addons/skin.estuary/1080i/Variables.xml
 msgctxt "#19199"
@@ -9895,11 +10135,14 @@ msgctxt "#19202"
 msgid "Channel icon:"
 msgstr ""
 
+#. used by several skins
 msgctxt "#19203"
 msgid "Edit channel"
 msgstr ""
 
+#. initial name for new channels, used in pvr channel manager dialog
 #: addons/skin.estuary/1080i/DialogPVRChannelManager.xml
+#: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 msgctxt "#19204"
 msgid "New channel"
 msgstr ""
@@ -9914,19 +10157,25 @@ msgctxt "#19206"
 msgid "Activate guide:"
 msgstr ""
 
+#. used by several skins
 msgctxt "#19207"
 msgid "Group:"
 msgstr ""
 
+#. text for "new channel name input" dialog
+#: xbmc/pvr/dialogs/GUIDialogChannelManager.cpp
 msgctxt "#19208"
 msgid "Enter the name of the new channel"
 msgstr ""
 
+#. unused?
 msgctxt "#19209"
 msgid "Kodi virtual backend"
 msgstr ""
 
+#. pvr channel manager "epg source" selector value
 #: addons/skin.estuary/1080i/DialogPVRChannelManager.xml
+#: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 msgctxt "#19210"
 msgid "Client"
 msgstr ""
@@ -9937,121 +10186,169 @@ msgctxt "#19211"
 msgid "Delete channel"
 msgstr ""
 
+#. pvr channel manager "save changes", part of confirmation dialog message
+#: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 msgctxt "#19212"
 msgid "This list contains changes"
 msgstr ""
 
+#. pvr channel manager "create new channel", backend selector dialog message
+#: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 msgctxt "#19213"
 msgid "Select backend"
 msgstr ""
 
+#. @@@ dead code in pvr channel manager, action for a context menu item never added?
+#: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 msgctxt "#19214"
 msgid "Enter a valid URL for the new channel"
 msgstr ""
 
+#. message box text stating that a pvr backend does not support timers
 #: xbmc/pvr/timers/PVRTimers.cpp
+#: xbmc/pvr/windows/GUIWindowsPVRTimersBase.cpp
 msgctxt "#19215"
 msgid "The PVR backend does not support timers."
 msgstr ""
 
+#. used by several skins
 msgctxt "#19216"
 msgid "All radio channels"
 msgstr ""
 
+#. label for 'all channels' value for 'channels' selector control in pvr guide search dialog 
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19217"
 msgid "All TV channels"
 msgstr ""
 
+#. 'visible' label used as prefix for 'group' control label in pvr channel group manager dialog, e.g. "Visible TV groups"
+#: xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
 msgctxt "#19218"
 msgid "Visible"
 msgstr ""
 
+#. label for 'ungrouped' control in pvr channel group manager dialog
+#: xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
 msgctxt "#19219"
 msgid "Ungrouped channels"
 msgstr ""
 
+#. 'channels in' label used as prefix for 'group' control label in pvr channel group manager dialog, e.g. "Channels in My Sports Channels Group"
+#: xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
 msgctxt "#19220"
 msgid "Channels in"
 msgstr ""
 
+#. pvr settings "sync channel groups with backend(s)" control label
 #: system/settings/settings.xml
 msgctxt "#19221"
 msgid "Synchronise channel groups with backend(s)"
 msgstr ""
 
+#: addons/skin.estouchy/xml/Includes.xml
 msgctxt "#19222"
 msgid "Guide"
 msgstr ""
 
+#. unused?
 msgctxt "#19223"
 msgid "No PVR add-on could be enabled. Check your settings or the log for more information."
 msgstr ""
 
+#. Notification text to announce that a recording was aborted
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19224"
 msgid "Recording aborted"
 msgstr ""
 
+#. Notification text to announce that a recording was scheduled
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19225"
 msgid "Recording scheduled"
 msgstr ""
 
+#. Notification text to announce that a recording started
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19226"
 msgid "Recording started"
 msgstr ""
 
+#. Notification text to announce that a recording completed
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19227"
 msgid "Recording completed"
 msgstr ""
 
-#: xbmc/pvr/timers/PVRTimerInfoTag.cpp, displayed when a timer is deleted
+#. Notification text to announce that a timer was deleted
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19228"
 msgid "Timer deleted"
 msgstr ""
 
+#. label for PVR settings close channel OSD after channel switch control
+#: system/settings/settings.xml
 msgctxt "#19229"
 msgid "Close channel OSD after switching channels"
 msgstr ""
 
+#. label for PVR settings no epg updates during playback control
 #: system/settings/settings.xml
 msgctxt "#19230"
 msgid "Prevent updates during playback"
 msgstr ""
 
+#. label for PVR settings use backend channel order control
 #: system/settings/settings.xml
 msgctxt "#19231"
 msgid "Use channel order from backend(s)"
 msgstr ""
 
+#. label for pvr epg search window 'clear search results' context menu item
+#: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
 msgctxt "#19232"
 msgid "Clear search results"
 msgstr ""
 
+#. label for PVR settings timer updates notification control
 #: system/settings/settings.xml
 msgctxt "#19233"
 msgid "Display a notification on timer updates"
 msgstr ""
 
+#. label for PVR settings use backend channel numbers control
 #: system/settings/settings.xml
 msgctxt "#19234"
 msgid "Use channel numbers from backend"
 msgstr ""
 
+#. label 'pvr starting up' for progress dialog text
+#: xbmc/pvr/PVRManager.cpp
+#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
 msgctxt "#19235"
 msgid "PVR manager is starting up"
 msgstr ""
 
+#. label 'loading channels' for progress dialog text
+#: xbmc/pvr/PVRManager.cpp
 msgctxt "#19236"
 msgid "Loading channels from clients"
 msgstr ""
 
+#. label 'loading timers' for progress dialog text
+#: xbmc/pvr/PVRManager.cpp
 msgctxt "#19237"
 msgid "Loading timers from clients"
 msgstr ""
 
+#. label 'loading recordings' for progress dialog text
+#: xbmc/pvr/PVRManager.cpp
 msgctxt "#19238"
 msgid "Loading recordings from clients"
 msgstr ""
 
+#. label 'starting background tasks' for progress dialog text
+#: xbmc/pvr/PVRManager.cpp
 msgctxt "#19239"
 msgid "Starting background threads"
 msgstr ""
@@ -10059,74 +10356,84 @@ msgstr ""
 #empty string with id 19240
 
 #. Label for context menu entry to open settings dialog for a timer (read-only)
-#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
-#: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
-#: xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#19241"
 msgid "View timer information"
 msgstr ""
 
 #. Label for context menu entry to open settings dialog for a timer
-#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
-#: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#19242"
 msgid "Edit timer"
 msgstr ""
 
 #. Label for context menu entry to open settings dialog for a timer rule
-#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
-#: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
-#: xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#19243"
 msgid "Edit timer rule"
 msgstr ""
 
+#. label for PVR settings pvr backend idle time control. if enabled, kodi will be automatically shutdown after the defined amount of pvr backend idle time.
 #: system/settings/settings.xml
 msgctxt "#19244"
 msgid "Backend idle time"
 msgstr ""
 
+#. label for PVR settings wakeup command control. if not empty, kodi will execute the given command upon waking up from suspend.
 #: system/settings/settings.xml
 msgctxt "#19245"
 msgid "Wakeup command"
 msgstr ""
 
+#. label for PVR settings wakeup before recording control. if checked, the box where kodi is installed on will be automatically turned on before a recording starts.
 #: system/settings/settings.xml
 msgctxt "#19246"
 msgid "Wakeup before recording"
 msgstr ""
 
+#. label for PVR settings daily wakeup control. if checked, the box where kodi is installed on will be automatically turned on at the given time.
 #: system/settings/settings.xml
 msgctxt "#19247"
 msgid "Daily wakeup"
 msgstr ""
 
+#. label for PVR settings daily wakeup time control. if checked, the box where kodi is installed on will be automatically turned on at the given time.
 #: system/settings/settings.xml
 msgctxt "#19248"
 msgid "Daily wakeup time (HH:MM:SS)"
 msgstr ""
 
+#. unused?
 msgctxt "#19249"
 msgid "Filter channels"
 msgstr ""
 
+#. label 'loading epg data from database' for progress dialog text
 #: xbmc/epg/EpgContainer.cpp
 msgctxt "#19250"
 msgid "Loading guide from database"
 msgstr ""
 
+#. label for 'update epg' context menu item and 'update epg' confirmation dialog header
+#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 msgctxt "#19251"
 msgid "Update guide information"
 msgstr ""
 
+#. label for 'update channel epg' confirmation dialog text
+#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 msgctxt "#19252"
 msgid "Schedule guide update for this channel?"
 msgstr ""
 
+#. label for notification text stating that an epg data update for a given channel was started
+#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 msgctxt "#19253"
 msgid "Guide update scheduled for channel"
 msgstr ""
 
+#. label for notification text stating that an epg data update for a given channel failed
+#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 msgctxt "#19254"
 msgid "Guide update failed for channel"
 msgstr ""
@@ -10143,47 +10450,61 @@ msgctxt "#19256"
 msgid "Completed"
 msgstr ""
 
+#. unused?
 msgctxt "#19257"
 msgid "Lock channel"
 msgstr ""
 
+#. unused?
 msgctxt "#19258"
 msgid "Unlock channel"
 msgstr ""
 
+#. pvr settings category label
 #: system/settings/settings.xml
 msgctxt "#19259"
 msgid "Parental control"
 msgstr ""
 
+#. pvr settings 'parental control channel unlock duration' setting label
 #: system/settings/settings.xml
 msgctxt "#19260"
 msgid "Unlock duration"
 msgstr ""
 
+#. pvr settings 'parental control change pin' setting label
 #: system/settings/settings.xml
 msgctxt "#19261"
 msgid "Change PIN"
 msgstr ""
 
+#. generic 'parental control enter pin' label
+#: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
+#: xbmc/pvr/PVRManager.cpp
+#: xbmc/settings/SettingConditions.cpp
 msgctxt "#19262"
 msgid "Parental control. Enter PIN:"
 msgstr ""
 
+#. label for 'parental control pin' verification dialog
+#: xbmc/pvr/PVRManager.cpp
 msgctxt "#19263"
 msgid "Locked channel. Enter PIN:"
 msgstr ""
 
+#. label for 'incorrect pin' error dialog header
 #: xbmc/pvr/PVRManager.cpp
 msgctxt "#19264"
 msgid "Incorrect PIN"
 msgstr ""
 
+#. label for 'incorrect pin' error dialog text
 #: xbmc/pvr/PVRManager.cpp
 msgctxt "#19265"
-msgid "The entered PIN number was incorrect."
+msgid "The entered PIN was incorrect."
 msgstr ""
 
+#. label to use for epg tag title instead of actual event title if the respective channel is parental locked
 #: xbmc/epg/EpgInfoTag.cpp
 msgctxt "#19266"
 msgid "Parental locked"
@@ -10194,117 +10515,124 @@ msgctxt "#19267"
 msgid "Parental locked:"
 msgstr ""
 
+#. pvr settings 'hide no info available labels' setting label. Instead of displaying "no information available" text (for example in epg grid for time spans without epg data), show nothing
 #: system/settings/settings.xml
 msgctxt "#19268"
 msgid "Hide \"No information available\" labels"
 msgstr ""
 
+#. pvr settings 'hide connection lost warnings' setting label. Do not display notification message in case Kodi cannot reach a pvr backend
 #: system/settings/settings.xml
 msgctxt "#19269"
 msgid "Disable \"Connection lost\" warnings"
 msgstr ""
 
-#. Label of the option to switch between a grouped recordings list and a non-grouped recordings list.
+#. Label of the option to switch between a grouped recordings list and a non-grouped recordings list in pvr recordings window.
 #: addons/skin.estuary/1080i/Includes_MediaMenu.xml
 msgctxt "#19270"
 msgid "Group Items"
 msgstr ""
 
+#. unused?
 msgctxt "#19271"
 msgid "No PVR add-ons could be found"
 msgstr ""
 
+#. label for 'pvr configuration incomplete' information dialog text
+#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
 msgctxt "#19272"
 msgid "You need a tuner, backend software, and an add-on for the backend to be able to use PVR. Please visit http://kodi.wiki/view/PVR to learn more."
 msgstr ""
 
-#. Settings -> Interface -> Other -> Startup window
-#: system/settings/settings.xml
+#. Settings -> Interface -> Other -> Startup window value
+#: xbmc/addons/Skin.cpp
 msgctxt "#19273"
 msgid "TV guide"
 msgstr ""
 
-#. Settings -> Interface -> Other -> Startup window
-#: system/settings/settings.xml
+#. Settings -> Interface -> Other -> Startup window value
+#: xbmc/addons/Skin.cpp
 msgctxt "#19274"
 msgid "Radio guide"
 msgstr ""
 
+#. timer status textual representation
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19275"
 msgid "Conflict warning"
 msgstr ""
 
+#. timer status textual representation
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19276"
 msgid "Conflict error"
 msgstr ""
 
+#. Notification text to announce that a recording has a conflict
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19277"
 msgid "Recording conflict"
 msgstr ""
 
-#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
+#. Notification text to announce that a recording has an error
 msgctxt "#19278"
 msgid "Recording error"
 msgstr ""
 
+#. pvr settings 'client specific' category label.
 #: system/settings/settings.xml
 msgctxt "#19279"
 msgid "Client specific"
 msgstr ""
 
+#. pvr client specific settings 'client specific settings' action control label.
 #: system/settings/settings.xml
 msgctxt "#19280"
 msgid "Client specific settings"
 msgstr ""
 
+#. pvr settings 'confirm channel switch' setting label.
 #: system/settings/settings.xml
 msgctxt "#19281"
 msgid "Confirm channel switches by pressing \"OK\""
 msgstr ""
 
 #. Label for a select option or list item, representing an icon graphic (like a TV channel icon)
-#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 msgctxt "#19282"
 msgid "Current icon"
 msgstr ""
 
 #. Label for a select option or list item, representing an icon graphic (like a TV channel icon)
-#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 msgctxt "#19283"
 msgid "No icon"
 msgstr ""
 
-#. Label for a select/menu option to select an icon graphic
-#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
-#: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
+#. used by several skins
 msgctxt "#19284"
 msgid "Choose icon"
 msgstr ""
 
 #. Label for a select/menu option to select an icon graphic
-#: xbmc/pvr/windows/GUIWindowPVRChannels.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 msgctxt "#19285"
 msgid "Browse for icon"
 msgstr ""
 
-#. Label for channel icon search progress dialog
-#: xbmc/pvr/channels/PVRChannelGroup.cpp
+#. Label for channel icon search progress dialog
+#: xbmc/pvr/channels/PVRChannelGroup.cpp
 msgctxt "#19286"
 msgid "Searching for channel icons"
 msgstr ""
 
 #. Label for the default pvr channel group
-#: xbmc/pvr/channels/PVRChannelGroupInternal.cpp
+#: xbmc/pvr/channels/PVRChannelGroupInternal.cpp
 msgctxt "#19287"
 msgid "All channels"
 msgstr ""
 
+#. pvr settings 'continue last channel on startup' setting value label.
 #: system/settings/settings.xml
 msgctxt "#19288"
 msgid "Foreground"
@@ -10317,39 +10645,37 @@ msgid "Hide group"
 msgstr ""
 
 #. Label for a context menu entry of a recording to undelete a deleted recording
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#19290"
 msgid "Undelete"
 msgstr ""
 
-#. Used on recordings context menu
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#. Label for a context menu entry of a recording to permanently delete a deleted recording
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#19291"
 msgid "Delete permanently"
 msgstr ""
 
-#. Used on recordings context menu
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#. "remove deleted recordings from trash" dialog header
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19292"
 msgid "Delete all permanently"
 msgstr ""
 
-#. Used on yes no dialog
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#. "remove deleted recordings from trash" dialog text
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19293"
-msgid "Delete all recordings permanently?"
+msgid "Remove all deleted recordings from trash? This operation cannot be reverted."
 msgstr ""
 
-#. Used on yes no dialog
-#: xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+#. "remove deleted recording from trash" dialog text
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19294"
-msgid "Delete this recording permanently?"
+msgid "Remove this deleted recording from trash? This operation cannot be reverted."
 msgstr ""
 
 #. Label for context menu entry to delete a timer rule
-#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
-#: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
-#: xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#19295"
 msgid "Delete timer rule"
 msgstr ""
@@ -10362,51 +10688,63 @@ msgstr ""
 
 #empty strings from id 19297 to 19498
 
+#. label for epg genre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19499"
 msgid "Other / Unknown"
 msgstr ""
 
+#. label for epg "movie/drama" genre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19500"
 msgid "Movie / Drama"
 msgstr ""
 
+#. label for epg "movie/drama" subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19501"
 msgid "Detective / Thriller"
 msgstr ""
 
+#. label for epg "movie/drama" subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19502"
 msgid "Adventure / Western / War"
 msgstr ""
 
+#. label for epg "movie/drama" subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19503"
 msgid "Science fiction / Fantasy / Horror"
 msgstr ""
 
+#. label for epg "movie/drama" subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19504"
 msgid "Comedy"
 msgstr ""
 
+#. label for epg "movie/drama" subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19505"
 msgid "Soap / Melodrama / Folkloric"
 msgstr ""
 
+#. label for epg "movie/drama" subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19506"
 msgid "Romance"
 msgstr ""
 
+#. label for epg "movie/drama" subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19507"
 msgid "Serious / Classical / Religious / Historical movie / drama"
 msgstr ""
 
+#. label for epg "movie/drama" subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19508"
 msgid "Adult movie / drama"
@@ -10414,26 +10752,32 @@ msgstr ""
 
 #empty strings from id 19509 to 19515
 
+#. label for "news/current affairs" epg genre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19516"
 msgid "News / Current affairs"
 msgstr ""
 
+#. label for "news/current affairs" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19517"
 msgid "News / Weather report"
 msgstr ""
 
+#. label for "news/current affairs" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19518"
 msgid "News magazine"
 msgstr ""
 
+#. label for "news/current affairs" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19519"
 msgid "Documentary"
 msgstr ""
 
+#. label for "news/current affairs" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19520"
 msgid "Discussion / Interview / Debate"
@@ -10441,21 +10785,26 @@ msgstr ""
 
 #empty strings from id 19521 to 19531
 
+#. label for "show/game show" epg subgenre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19532"
 msgid "Show / Game show"
 msgstr ""
 
+#. label for "show/game show" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19533"
 msgid "Game show / Quiz / Contest"
 msgstr ""
 
+#. label for "show/game show" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19534"
 msgid "Variety show"
 msgstr ""
 
+#. label for "show/game show" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19535"
 msgid "Talk show"
@@ -10463,61 +10812,74 @@ msgstr ""
 
 #empty strings from id 19536 to 19547
 
+#. label for "sports" epg genre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19548"
 msgid "Sports"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19549"
 msgid "Special event"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19550"
 msgid "Sport magazine"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19551"
 msgid "Football"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19552"
 msgid "Tennis / Squash"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19553"
 msgid "Team sports"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19554"
 msgid "Athletics"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19555"
 msgid "Motor sport"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19556"
 msgid "Water sport"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19557"
 msgid "Winter sports"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19558"
 msgid "Equestrian"
 msgstr ""
 
+#. label for "sports" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19559"
 msgid "Martial sports"
@@ -10525,31 +10887,38 @@ msgstr ""
 
 #empty strings from id 19560 to 19563
 
+#. label for "children's/youth programmes" epg genre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19564"
 msgid "Children's / Youth programmes"
 msgstr ""
 
+#. label for "children's/youth programmes" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19565"
 msgid "Pre-school children's programmes"
 msgstr ""
 
+#. label for "children's/youth programmes" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19566"
 msgid "Entertainment programmes for 6 to 14"
 msgstr ""
 
+#. label for "children's/youth programmes" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19567"
 msgid "Entertainment programmes for 10 to 16"
 msgstr ""
 
+#. label for "children's/youth programmes" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19568"
 msgid "Informational / Educational / School programme"
 msgstr ""
 
+#. label for "children's/youth programmes" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19569"
 msgid "Cartoons / Puppets"
@@ -10557,30 +10926,38 @@ msgstr ""
 
 #empty strings from id 19570 to 19579
 
+#. label for "music/ballet/dance" epg genre value
+#: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19580"
 msgid "Music / Ballet / Dance"
 msgstr ""
 
+#. label for "music/ballet/dance" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19581"
 msgid "Rock / Pop"
 msgstr ""
 
+#. label for "music/ballet/dance" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19582"
 msgid "Serious / Classical music"
 msgstr ""
 
+#. label for "music/ballet/dance" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19583"
 msgid "Folk / Traditional music"
 msgstr ""
 
+#. label for "music/ballet/dance" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19584"
 msgid "Musical / Opera"
 msgstr ""
 
+#. label for "music/ballet/dance" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19585"
 msgid "Ballet"
@@ -10588,61 +10965,74 @@ msgstr ""
 
 #empty strings from id 19586 to 19595
 
+#. label for "arts/culture" epg genre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19596"
 msgid "Arts / Culture"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19597"
 msgid "Performing arts"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19598"
 msgid "Fine arts"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19599"
 msgid "Religion"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19600"
 msgid "Popular culture / Traditional arts"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19601"
 msgid "Literature"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19602"
 msgid "Film / Cinema"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19603"
 msgid "Experimental film / video"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19604"
 msgid "Broadcasting / Press"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19605"
 msgid "New media"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19606"
 msgid "Arts / Culture magazines"
 msgstr ""
 
+#. label for "arts/culture" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19607"
 msgid "Fashion"
@@ -10650,21 +11040,26 @@ msgstr ""
 
 #empty strings from id 19608 to 19611
 
+#. label for "social/political/economics" epg genre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19612"
 msgid "Social / Political / Economics"
 msgstr ""
 
+#. label for "social/political/economics" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19613"
 msgid "Magazines / Reports / Documentary"
 msgstr ""
 
+#. label for "social/political/economics" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19614"
 msgid "Economics / Social advisory"
 msgstr ""
 
+#. label for "social/political/economics" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19615"
 msgid "Remarkable people"
@@ -10672,41 +11067,50 @@ msgstr ""
 
 #empty strings from id 19616 to 19627
 
+#. label for "education/science/factual" epg genre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19628"
 msgid "Education / Science / Factual"
 msgstr ""
 
+#. label for "education/science/factual" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19629"
 msgid "Nature / Animals / Environment"
 msgstr ""
 
+#. label for "education/science/factual" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19630"
 msgid "Technology / Natural sciences"
 msgstr ""
 
+#. label for "education/science/factual" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19631"
 msgid "Medicine / Physiology / Psychology"
 msgstr ""
 
+#. label for "education/science/factual" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19632"
 msgid "Foreign countries / Expeditions"
 msgstr ""
 
+#. label for "education/science/factual" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19633"
 msgid "Social / Spiritual sciences"
 msgstr ""
 
+#. label for "education/science/factual" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19634"
 msgid "Further education"
 msgstr ""
 
+#. label for "education/science/factual" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19635"
 msgid "Languages"
@@ -10714,41 +11118,50 @@ msgstr ""
 
 #empty strings from id 19636 to 19643
 
+#. label for "leisure/hobbies" epg genre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19644"
 msgid "Leisure / Hobbies"
 msgstr ""
 
+#. label for "leisure/hobbies" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19645"
 msgid "Tourism / Travel"
 msgstr ""
 
+#. label for "leisure/hobbies" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19646"
 msgid "Handicraft"
 msgstr ""
 
+#. label for "leisure/hobbies" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19647"
 msgid "Motoring"
 msgstr ""
 
+#. label for "leisure/hobbies" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19648"
 msgid "Fitness & health"
 msgstr ""
 
+#. label for "leisure/hobbies" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19649"
 msgid "Cooking"
 msgstr ""
 
+#. label for "leisure/hobbies" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19650"
 msgid "Advertisement / Shopping"
 msgstr ""
 
+#. label for "leisure/hobbies" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19651"
 msgid "Gardening"
@@ -10756,26 +11169,32 @@ msgstr ""
 
 #empty strings from id 19652 to 19659
 
+#. label for "special characteristics" epg genre value
 #: xbmc/epg/Epg.cpp
+#: xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
 msgctxt "#19660"
 msgid "Special characteristics"
 msgstr ""
 
+#. label for "special characteristics" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19661"
 msgid "Original language"
 msgstr ""
 
+#. label for "special characteristics" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19662"
 msgid "Black & white"
 msgstr ""
 
+#. label for "special characteristics" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19663"
 msgid "Unpublished"
 msgstr ""
 
+#. label for "special characteristics" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19664"
 msgid "Live broadcast"
@@ -10783,46 +11202,55 @@ msgstr ""
 
 #empty strings from id 19665 to 19675
 
+#. label for "user defined" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19676"
 msgid "Drama"
 msgstr ""
 
+#. label for "user defined" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19677"
 msgid "Detective / Thriller"
 msgstr ""
 
+#. label for "user defined" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19678"
 msgid "Adventure / Western / War"
 msgstr ""
 
+#. label for "user defined" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19679"
 msgid "Science fiction / Fantasy / Horror"
 msgstr ""
 
+#. label for "user defined" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19680"
 msgid "Comedy"
 msgstr ""
 
+#. label for "user defined" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19681"
 msgid "Soap / Melodrama / Folkloric"
 msgstr ""
 
+#. label for "user defined" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19682"
 msgid "Romance"
 msgstr ""
 
+#. label for "user defined" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19683"
 msgid "Serious / Classical / Religion / Historical"
 msgstr ""
 
+#. label for "user defined" epg subgenre value
 #: xbmc/epg/Epg.cpp
 msgctxt "#19684"
 msgid "Adult"
@@ -10836,25 +11264,27 @@ msgstr ""
 
 #empty string with id 19686
 
-#: Label for a context menu entries, dialog heading, button to start playing a recording
-#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
-#: xbmc/pvr/windows/GUIWindowPVRSearch.cpp
-#: xbmc/pvr/windows/GUIWindowPVRBase.cpp
+#: Label for context menu entries, dialog heading, button to start playing a recording
+#: xbmc/pvr/PVRContextMenus.cpp
+#: xbmc/pvr/PVRGUIActions.cpp
 msgctxt "#19687"
 msgid "Play recording"
 msgstr ""
 
-#: xbmc/pvr/addons/PVRClients.cpp
+#. label for 'scanning for pvr services' dialog header
+#: xbmc/addons/PVRClient.cpp
 msgctxt "#19688"
 msgid "Scanning for PVR services"
 msgstr ""
 
-#: xbmc/pvr/addons/PVRClients.cpp
+#. label for 'scanning for pvr services' dialog text
+#: xbmc/addons/PVRClient.cpp
 msgctxt "#19689"
 msgid "%s service found at %s"
 msgstr ""
 
-#: xbmc/pvr/addons/PVRClient.cpp
+#. label for 'scanning for pvr services' dialog text
+#: xbmc/addons/PVRClient.cpp
 msgctxt "#19690"
 msgid "Do you want to use this service?"
 msgstr ""
@@ -13127,7 +13557,7 @@ msgstr ""
 
 #. Label for controls used to edit something (e.g. setting "Appearance -> Skin -> Edit" or a context menu entry to open timer settings dialog)
 #: system/settings/settings.xml
-#: xbmc/pvr/windows/GUIWindowPVRTimers.cpp
+#: xbmc/pvr/PVRContextMenus.cpp
 msgctxt "#21450"
 msgid "Edit"
 msgstr ""
@@ -14039,7 +14469,6 @@ msgctxt "#24031"
 msgid "Error loading settings"
 msgstr ""
 
-#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#24032"
 msgid "All add-ons"
 msgstr ""
@@ -14925,7 +15354,7 @@ msgctxt "#29919"
 msgid "Lottery"
 msgstr ""
 
-# Stock information, in list selector (if present)
+#. Stock information, in list selector (if present)
 #: xbmc/pvr/dialogs/GUIDialogPVRRadioRDSInfo.cpp
 msgctxt "#29920"
 msgid "Stock"
@@ -16269,31 +16698,31 @@ msgstr ""
 #empty strings from id 35103 to 35504
 
 #. connection state "host unreachable"
-#: xbmc/addons/AddonCallbacksPVR.cpp
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#35505"
 msgid "Server is unreachable."
 msgstr ""
 
 #. connection state "server type mismatch" (reachable, but maybe an HTTP server where an FTP server is expected)
-#: xbmc/addons/AddonCallbacksPVR.cpp
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#35506"
 msgid "Server does not respond properly."
 msgstr ""
 
 #. connection state "client - server version mismatch (reachable, but maybe server version to low)"
-#: xbmc/addons/AddonCallbacksPVR.cpp
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#35507"
 msgid "Server version is not compatible."
 msgstr ""
 
 #. connection state "access denied" (e.g. due to wrong credentials)
-#: xbmc/addons/AddonCallbacksPVR.cpp
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#35508"
 msgid "Access denied."
 msgstr ""
 
 #. connection state "connecting" (asynchronous addon start)
-#: xbmc/addons/AddonCallbacksPVR.cpp
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#35509"
 msgid "Connecting to backend."
 msgstr ""
@@ -16441,9 +16870,9 @@ msgctxt "#36029"
 msgid "When the TV is switched off"
 msgstr ""
 
-#: xbmc/addons/addonstatushandler.cpp
-#: xbmc/addons/AddonCallbacksPVR.cpp
+#. connection state "connection lost"
 #: xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#36030"
 msgid "Connection lost"
 msgstr ""
@@ -16463,7 +16892,8 @@ msgctxt "#36033"
 msgid "Action when switching to another source"
 msgstr ""
 
-#: xbmc/addons/AddonCallbacksPVR.cpp
+#. connection state "connection established"
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#36034"
 msgid "Connection established"
 msgstr ""
@@ -18829,13 +19259,13 @@ msgstr ""
 
 #empty strings from id 36578 to 36579
 
-# Dialog title for 3D LUT file picker
+#. Dialog title for 3D LUT file picker
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
 msgctxt "#36580"
 msgid "3D LUT file"
 msgstr ""
 
-# Dialog title for ICC display profile file picker
+#. Dialog title for ICC display profile file picker
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
 msgctxt "#36581"
 msgid "ICC Profile"
diff --git a/system/keymaps/keyboard.xml b/system/keymaps/keyboard.xml
index 190efe7..e0bbe9b 100644
--- a/system/keymaps/keyboard.xml
+++ b/system/keymaps/keyboard.xml
@@ -197,6 +197,7 @@
   </VirtualKeyboard>
   <TVChannels>
     <keyboard>
+      <delete>Delete</delete>
       <m mod="ctrl">Move</m>
       <h>PreviousMenu</h>
     </keyboard>
@@ -246,6 +247,7 @@
   </TVGuide>
   <RadioChannels>
     <keyboard>
+      <delete>Delete</delete>
       <m mod="ctrl">Move</m>
       <j>PreviousMenu</j>
     </keyboard>
diff --git a/xbmc/ApplicationPlayer.h b/xbmc/ApplicationPlayer.h
index a0567a6..a08e88c 100644
--- a/xbmc/ApplicationPlayer.h
+++ b/xbmc/ApplicationPlayer.h
@@ -28,6 +28,7 @@
 #include "threads/SystemClock.h"
 #include "guilib/Resolution.h"
 #include "cores/IPlayer.h"
+#include "pvr/PVRTypes.h"
 
 typedef enum
 {
@@ -36,12 +37,6 @@ typedef enum
   PLAYBACK_OK = 1,
 } PlayBackRet;
 
-namespace PVR
-{
-  class CPVRChannel;
-  typedef std::shared_ptr<PVR::CPVRChannel> CPVRChannelPtr;
-}
-
 class CAction;
 class CPlayerOptions;
 class CStreamDetails;
diff --git a/xbmc/ContextMenuManager.cpp b/xbmc/ContextMenuManager.cpp
index 4329c54..a9e8584 100644
--- a/xbmc/ContextMenuManager.cpp
+++ b/xbmc/ContextMenuManager.cpp
@@ -25,6 +25,7 @@
 #include "addons/ContextMenus.h"
 #include "addons/IAddon.h"
 #include "music/ContextMenus.h"
+#include "pvr/PVRContextMenus.h"
 #include "video/ContextMenus.h"
 #include "utils/log.h"
 #include "ServiceBroker.h"
@@ -32,7 +33,7 @@
 #include <iterator>
 
 using namespace ADDON;
-
+using namespace PVR;
 
 const CContextMenuItem CContextMenuManager::MAIN = CContextMenuItem::CreateGroup("", "", "kodi.core.main", "");
 const CContextMenuItem CContextMenuManager::MANAGE = CContextMenuItem::CreateGroup("", "", "kodi.core.manage", "");
@@ -72,7 +73,12 @@ void CContextMenuManager::Init()
       std::make_shared<CONTEXTMENU::CMarkWatched>(),
       std::make_shared<CONTEXTMENU::CMarkUnWatched>(),
   };
+
   ReloadAddonItems();
+
+  const std::vector<std::shared_ptr<IContextMenuItem>> pvrItems(CPVRContextMenuManager::GetInstance().GetMenuItems());
+  for (const auto &item : pvrItems)
+    m_items.emplace_back(item);
 }
 
 void CContextMenuManager::ReloadAddonItems()
diff --git a/xbmc/ContextMenuManager.h b/xbmc/ContextMenuManager.h
index 3a96b8a..7da1666 100644
--- a/xbmc/ContextMenuManager.h
+++ b/xbmc/ContextMenuManager.h
@@ -77,4 +77,4 @@ namespace CONTEXTMENU
    * Shortcut for continuing the context menu loop from an exisiting menu item.
    */
   bool LoopFrom(const IContextMenuItem& menu, const CFileItemPtr& fileItem);
-}
\ No newline at end of file
+}
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index 7def932..c55e80b 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -24,13 +24,17 @@
  *
  */
 
+#include <map>
 #include <memory>
+#include <string>
 #include <utility>
 #include <vector>
 
 #include "addons/IAddon.h"
+#include "epg/EpgTypes.h"
 #include "guilib/GUIListItem.h"
 #include "GUIPassword.h"
+#include "pvr/PVRTypes.h"
 #include "threads/CriticalSection.h"
 #include "utils/IArchivable.h"
 #include "utils/ISerializable.h"
@@ -43,22 +47,6 @@ namespace MUSIC_INFO
   class CMusicInfoTag;
 }
 class CVideoInfoTag;
-namespace EPG
-{
-  class CEpgInfoTag;
-  typedef std::shared_ptr<EPG::CEpgInfoTag> CEpgInfoTagPtr;
-}
-namespace PVR
-{
-  class CPVRChannel;
-  class CPVRRecording;
-  class CPVRTimerInfoTag;
-  class CPVRRadioRDSInfoTag;
-  typedef std::shared_ptr<PVR::CPVRRecording> CPVRRecordingPtr;
-  typedef std::shared_ptr<PVR::CPVRChannel> CPVRChannelPtr;
-  typedef std::shared_ptr<PVR::CPVRTimerInfoTag> CPVRTimerInfoTagPtr;
-  typedef std::shared_ptr<PVR::CPVRRadioRDSInfoTag> CPVRRadioRDSInfoTagPtr;
-}
 class CPictureInfoTag;
 
 class CAlbum;
diff --git a/xbmc/GUIInfoManager.h b/xbmc/GUIInfoManager.h
index 48d1c6f..104b952 100644
--- a/xbmc/GUIInfoManager.h
+++ b/xbmc/GUIInfoManager.h
@@ -37,21 +37,18 @@
 #include "interfaces/info/SkinVariable.h"
 #include "cores/IPlayer.h"
 #include "FileItem.h"
+#include "epg/EpgTypes.h"
+#include "pvr/PVRTypes.h"
 
-#include <memory>
-#include <list>
+#include <atomic>
 #include <map>
+#include <string>
 #include <vector>
 
 namespace MUSIC_INFO
 {
   class CMusicInfoTag;
 }
-namespace PVR
-{
-  class CPVRRadioRDSInfoTag;
-  typedef std::shared_ptr<PVR::CPVRRadioRDSInfoTag> CPVRRadioRDSInfoTagPtr;
-}
 class CVideoInfoTag;
 class CFileItem;
 class CGUIListItem;
@@ -63,13 +60,6 @@ namespace INFO
 
 // forward
 class CGUIWindow;
-namespace EPG
-{
-  class CEpgInfoTag;
-  typedef std::shared_ptr<EPG::CEpgInfoTag> CEpgInfoTagPtr;
-}
-
-
 
 // structure to hold multiple integer data
 // for storage referenced from a single integer
diff --git a/xbmc/addons/PVRClient.h b/xbmc/addons/PVRClient.h
index 8262ed5..c52fe08 100644
--- a/xbmc/addons/PVRClient.h
+++ b/xbmc/addons/PVRClient.h
@@ -19,6 +19,7 @@
  *
  */
 
+#include <exception>
 #include <memory>
 #include <string>
 #include <vector>
@@ -29,6 +30,7 @@
 #include "network/ZeroconfBrowser.h"
 
 #include "pvr/channels/PVRChannel.h"
+#include "pvr/PVRTypes.h"
 
 namespace EPG
 {
@@ -51,7 +53,6 @@ namespace PVR
   typedef std::shared_ptr<CPVRClient> PVR_CLIENT;
   #define PVR_INVALID_CLIENT_ID (-2)
 
-  typedef std::shared_ptr<CPVRTimerType> CPVRTimerTypePtr;
   typedef std::vector<CPVRTimerTypePtr>  CPVRTimerTypes;
 
   /*!
diff --git a/xbmc/cores/IPlayer.h b/xbmc/cores/IPlayer.h
index a1ea99f..642e9a0 100644
--- a/xbmc/cores/IPlayer.h
+++ b/xbmc/cores/IPlayer.h
@@ -21,12 +21,13 @@
  */
 
 #include "system.h" // until we get sane int types used here
-#include <memory>
 #include <vector>
+#include <string>
+
 #include "IPlayerCallback.h"
 #include "guilib/Geometry.h"
 #include "guilib/Resolution.h"
-#include <string>
+#include "pvr/PVRTypes.h"
 
 #define CURRENT_STREAM -1
 #define CAPTUREFLAG_CONTINUOUS  0x01 //after a render is done, render a new one immediately
@@ -38,12 +39,6 @@ class TiXmlElement;
 class CStreamDetails;
 class CAction;
 
-namespace PVR
-{
-  class CPVRChannel;
-  typedef std::shared_ptr<PVR::CPVRChannel> CPVRChannelPtr;
-}
-
 class CPlayerOptions
 {
 public:
diff --git a/xbmc/dialogs/GUIDialogContextMenu.h b/xbmc/dialogs/GUIDialogContextMenu.h
index 37be004..7b10ad1 100644
--- a/xbmc/dialogs/GUIDialogContextMenu.h
+++ b/xbmc/dialogs/GUIDialogContextMenu.h
@@ -87,23 +87,13 @@ enum CONTEXT_BUTTON { CONTEXT_BUTTON_CANCELLED = 0,
                       CONTEXT_BUTTON_PLAY_OTHER,
                       CONTEXT_BUTTON_SET_ACTOR_THUMB,
                       CONTEXT_BUTTON_UNLINK_BOOKMARK,
-                      CONTEXT_BUTTON_ADD,
                       CONTEXT_BUTTON_ACTIVATE,
-                      CONTEXT_BUTTON_START_RECORD,
-                      CONTEXT_BUTTON_ADD_TIMER,
-                      CONTEXT_BUTTON_STOP_RECORD,
-                      CONTEXT_BUTTON_EDIT_TIMER,
-                      CONTEXT_BUTTON_EDIT_TIMER_RULE,
-                      CONTEXT_BUTTON_DELETE_TIMER,
-                      CONTEXT_BUTTON_DELETE_TIMER_RULE,
                       CONTEXT_BUTTON_GROUP_MANAGER,
                       CONTEXT_BUTTON_CHANNEL_MANAGER,
                       CONTEXT_BUTTON_SET_MOVIESET_ART,
                       CONTEXT_BUTTON_BEGIN,
                       CONTEXT_BUTTON_END,
                       CONTEXT_BUTTON_NOW,
-                      CONTEXT_BUTTON_FIND,
-                      CONTEXT_BUTTON_MENU_HOOKS,
                       CONTEXT_BUTTON_PLAY_AND_QUEUE,
                       CONTEXT_BUTTON_PLAY_ONLY_THIS,
                       CONTEXT_BUTTON_UPDATE_EPG,
@@ -113,7 +103,6 @@ enum CONTEXT_BUTTON { CONTEXT_BUTTON_CANCELLED = 0,
                       CONTEXT_BUTTON_MOVIESET_ADD_REMOVE_ITEMS,
                       CONTEXT_BUTTON_BROWSE_INTO,
                       CONTEXT_BUTTON_EDIT_SORTTITLE,
-                      CONTEXT_BUTTON_UNDELETE,
                       CONTEXT_BUTTON_DELETE_ALL,
                       CONTEXT_BUTTON_HELP,
                       CONTEXT_BUTTON_ACTIVE_ADSP_SETTINGS,
diff --git a/xbmc/epg/CMakeLists.txt b/xbmc/epg/CMakeLists.txt
index e2c3a0d..7d8ac04 100644
--- a/xbmc/epg/CMakeLists.txt
+++ b/xbmc/epg/CMakeLists.txt
@@ -11,6 +11,7 @@ set(HEADERS Epg.h
             EpgDatabase.h
             EpgInfoTag.h
             EpgSearchFilter.h
+            EpgTypes.h
             GUIEPGGridContainer.h
             GUIEPGGridContainerModel.h)
 
diff --git a/xbmc/epg/Epg.h b/xbmc/epg/Epg.h
index 1a803ea..1643002 100644
--- a/xbmc/epg/Epg.h
+++ b/xbmc/epg/Epg.h
@@ -26,19 +26,15 @@
 
 #include "EpgInfoTag.h"
 #include "EpgSearchFilter.h"
+#include "EpgTypes.h"
 
-#include <memory>
-
-namespace PVR
-{
-  class CPVRChannel;
-}
+#include <map>
+#include <string>
+#include <vector>
 
 /** EPG container for CEpgInfoTag instances */
 namespace EPG
 {
-  class CEpg;
-  typedef std::shared_ptr<CEpg> CEpgPtr;
   typedef std::map<unsigned int, CEpgPtr> EPGMAP;
 
   class CEpg : public Observable
diff --git a/xbmc/epg/EpgDatabase.h b/xbmc/epg/EpgDatabase.h
index b25ac20..c5f5ee7 100644
--- a/xbmc/epg/EpgDatabase.h
+++ b/xbmc/epg/EpgDatabase.h
@@ -19,9 +19,6 @@
  *
  */
 
-#include <map>
-#include <memory>
-
 #include "XBDateTime.h"
 #include "dbwrappers/Database.h"
 
@@ -29,8 +26,6 @@
 
 namespace EPG
 {
-  class CEpg;
-  typedef std::shared_ptr<CEpg> CEpgPtr;
   class CEpgInfoTag;
   class CEpgContainer;
 
diff --git a/xbmc/epg/EpgInfoTag.cpp b/xbmc/epg/EpgInfoTag.cpp
index 44c97e9..740bd03 100644
--- a/xbmc/epg/EpgInfoTag.cpp
+++ b/xbmc/epg/EpgInfoTag.cpp
@@ -59,7 +59,7 @@ CEpgInfoTag::CEpgInfoTag(void) :
 {
 }
 
-CEpgInfoTag::CEpgInfoTag(CEpg *epg, PVR::CPVRChannelPtr pvrChannel, const std::string &strTableName /* = "" */, const std::string &strIconPath /* = "" */) :
+CEpgInfoTag::CEpgInfoTag(CEpg *epg, const PVR::CPVRChannelPtr &pvrChannel, const std::string &strTableName /* = "" */, const std::string &strIconPath /* = "" */) :
     m_bNotify(false),
     m_iBroadcastId(-1),
     m_iGenreType(0),
@@ -528,7 +528,7 @@ CPVRTimerInfoTagPtr CEpgInfoTag::Timer(void) const
   return m_timer;
 }
 
-void CEpgInfoTag::SetPVRChannel(PVR::CPVRChannelPtr channel)
+void CEpgInfoTag::SetPVRChannel(const PVR::CPVRChannelPtr &channel)
 {
   CSingleLock lock(m_critSection);
   m_pvrChannel = channel;
@@ -717,7 +717,7 @@ void CEpgInfoTag::ClearTimer(void)
     previousTag->ClearEpgTag();
 }
 
-void CEpgInfoTag::SetRecording(CPVRRecordingPtr recording)
+void CEpgInfoTag::SetRecording(const CPVRRecordingPtr &recording)
 {
   CSingleLock lock(m_critSection);
   m_recording = recording;
diff --git a/xbmc/epg/EpgInfoTag.h b/xbmc/epg/EpgInfoTag.h
index 945d6e8..24281a0 100644
--- a/xbmc/epg/EpgInfoTag.h
+++ b/xbmc/epg/EpgInfoTag.h
@@ -19,16 +19,19 @@
  *
  */
 
-#include <memory>
-#include <string>
-#include <vector>
-
 #include "XBDateTime.h"
 #include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "pvr/PVRTypes.h"
 #include "pvr/channels/PVRChannel.h"
+#include "pvr/recordings/PVRRecording.h"
 #include "pvr/timers/PVRTimerInfoTag.h"
 #include "utils/ISerializable.h"
 
+#include "epg/EpgTypes.h"
+
+#include <string>
+#include <vector>
+
 #define EPG_DEBUGGING 0
 
 class CVariant;
@@ -37,9 +40,6 @@ namespace EPG
 {
   class CEpg;
 
-  class CEpgInfoTag;
-  typedef std::shared_ptr<EPG::CEpgInfoTag> CEpgInfoTagPtr;
-
   class CEpgInfoTag : public ISerializable
   {
     friend class CEpg;
@@ -66,7 +66,7 @@ namespace EPG
     /*!
      * @brief Create a new empty event without a unique ID.
      */
-    CEpgInfoTag(CEpg *epg, PVR::CPVRChannelPtr pvrChannel, const std::string &strTableName = "", const std::string &strIconPath = "");
+    CEpgInfoTag(CEpg *epg, const PVR::CPVRChannelPtr &pvrChannel, const std::string &strTableName = "", const std::string &strIconPath = "");
 
     CEpgInfoTag(const CEpgInfoTag &tag) = delete;
     CEpgInfoTag &operator =(const CEpgInfoTag &other) = delete;
@@ -344,7 +344,7 @@ namespace EPG
      * @brief Set a recording for this event or NULL to clear it.
      * @param recording The recording value.
      */
-    void SetRecording(PVR::CPVRRecordingPtr recording);
+    void SetRecording(const PVR::CPVRRecordingPtr &recording);
 
     /*!
      * @brief Clear a recording for this event.
@@ -367,7 +367,7 @@ namespace EPG
      * @brief Change the channel tag of this epg tag
      * @param channel The new channel
      */
-    void SetPVRChannel(PVR::CPVRChannelPtr channel);
+    void SetPVRChannel(const PVR::CPVRChannelPtr &channel);
 
     /*!
      * @return True if this tag has a PVR channel set.
diff --git a/xbmc/epg/EpgTypes.h b/xbmc/epg/EpgTypes.h
new file mode 100644
index 0000000..c546d5d
--- /dev/null
+++ b/xbmc/epg/EpgTypes.h
@@ -0,0 +1,33 @@
+#pragma once
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <memory>
+
+namespace EPG
+{
+  class CEpg;
+  typedef std::shared_ptr<CEpg> CEpgPtr;
+
+  class CEpgInfoTag;
+  typedef std::shared_ptr<CEpgInfoTag> CEpgInfoTagPtr;
+
+} // namespace EPG
+
diff --git a/xbmc/interfaces/json-rpc/PlayerOperations.h b/xbmc/interfaces/json-rpc/PlayerOperations.h
index da0e992..7c995ef 100644
--- a/xbmc/interfaces/json-rpc/PlayerOperations.h
+++ b/xbmc/interfaces/json-rpc/PlayerOperations.h
@@ -21,14 +21,11 @@
 
 #include "JSONRPC.h"
 #include "FileItemHandler.h"
+#include "epg/EpgTypes.h"
 
-class CVariant;
+#include <string>
 
-namespace EPG
-{
-  class CEpgInfoTag;
-  typedef std::shared_ptr<EPG::CEpgInfoTag> CEpgInfoTagPtr;
-}
+class CVariant;
 
 namespace JSONRPC
 {
diff --git a/xbmc/pvr/CMakeLists.txt b/xbmc/pvr/CMakeLists.txt
index aab1a62..b5d5387 100644
--- a/xbmc/pvr/CMakeLists.txt
+++ b/xbmc/pvr/CMakeLists.txt
@@ -2,13 +2,20 @@ set(SOURCES PVRActionListener.cpp
             PVRGUIInfo.cpp
             PVRManager.cpp
             PVRDatabase.cpp
-            PVRSettings.cpp)
+            PVRSettings.cpp
+            PVRContextMenus.cpp
+            PVRGUIActions.cpp
+            PVRItem.cpp)
 
 set(HEADERS PVRActionListener.h
             PVRDatabase.h
             PVREvent.h
             PVRGUIInfo.h
             PVRManager.h
-            PVRSettings.h)
+            PVRSettings.h
+            PVRContextMenus.h
+            PVRGUIActions.h
+            PVRItem.h
+            PVRTypes.h)
 
 core_add_library(pvr)
diff --git a/xbmc/pvr/Makefile b/xbmc/pvr/Makefile
index 3d9f47e..22ae196 100644
--- a/xbmc/pvr/Makefile
+++ b/xbmc/pvr/Makefile
@@ -2,7 +2,10 @@ SRCS=PVRGUIInfo.cpp \
      PVRManager.cpp \
      PVRDatabase.cpp \
      PVRActionListener.cpp \
-     PVRSettings.cpp
+     PVRSettings.cpp \
+     PVRContextMenus.cpp \
+     PVRGUIActions.cpp \
+     PVRItem.cpp
 
 LIB=pvr.a
 
diff --git a/xbmc/pvr/PVRContextMenus.cpp b/xbmc/pvr/PVRContextMenus.cpp
new file mode 100644
index 0000000..ffad705
--- /dev/null
+++ b/xbmc/pvr/PVRContextMenus.cpp
@@ -0,0 +1,694 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "ContextMenuItem.h"
+#include "cores/AudioEngine/Engines/ActiveAE/AudioDSPAddons/ActiveAEDSP.h"
+#include "epg/EpgInfoTag.h"
+#include "pvr/addons/PVRClients.h"
+#include "pvr/channels/PVRChannel.h"
+#include "pvr/PVRGUIActions.h"
+#include "pvr/PVRManager.h"
+#include "pvr/recordings/PVRRecording.h"
+#include "pvr/recordings/PVRRecordingsPath.h"
+#include "settings/Settings.h"
+#include "pvr/timers/PVRTimers.h"
+#include "utils/URIUtils.h"
+
+#include "PVRContextMenus.h"
+
+using namespace EPG;
+
+namespace PVR
+{
+  namespace CONTEXTMENUITEM
+  {
+    #define DECL_STATICCONTEXTMENUITEM(clazz) \
+    class clazz : public CStaticContextMenuAction \
+    { \
+    public: \
+      clazz(uint32_t label) : CStaticContextMenuAction(label) {} \
+      bool IsVisible(const CFileItem &item) const override; \
+      bool Execute(const CFileItemPtr &item) const override; \
+    };
+
+    #define DECL_CONTEXTMENUITEM(clazz) \
+    class clazz : public IContextMenuItem \
+    { \
+    public: \
+      std::string GetLabel(const CFileItem &item) const override; \
+      bool IsVisible(const CFileItem &item) const override; \
+      bool Execute(const CFileItemPtr &item) const override; \
+    };
+
+    DECL_CONTEXTMENUITEM(ShowInformation);
+    DECL_STATICCONTEXTMENUITEM(FindSimilar);
+    DECL_STATICCONTEXTMENUITEM(StartRecording);
+    DECL_STATICCONTEXTMENUITEM(StopRecording);
+    DECL_STATICCONTEXTMENUITEM(AddTimerRule);
+    DECL_STATICCONTEXTMENUITEM(EditTimerRule);
+    DECL_STATICCONTEXTMENUITEM(DeleteTimerRule);
+    DECL_CONTEXTMENUITEM(EditTimer);
+    DECL_CONTEXTMENUITEM(DeleteTimer);
+    DECL_CONTEXTMENUITEM(PlayChannel);
+    DECL_CONTEXTMENUITEM(ResumePlayRecording);
+    DECL_CONTEXTMENUITEM(PlayRecording);
+    DECL_STATICCONTEXTMENUITEM(MarkWatched);
+    DECL_STATICCONTEXTMENUITEM(MarkUnwatched);
+    DECL_STATICCONTEXTMENUITEM(RenameRecording);
+    DECL_CONTEXTMENUITEM(DeleteRecording);
+    DECL_STATICCONTEXTMENUITEM(UndeleteRecording);
+    DECL_CONTEXTMENUITEM(ToggleTimerState);
+    DECL_STATICCONTEXTMENUITEM(RenameTimer);
+    DECL_STATICCONTEXTMENUITEM(ShowAudioDSPSettings);
+    DECL_STATICCONTEXTMENUITEM(PVRClientMenuHook);
+
+    CPVRTimerInfoTagPtr GetTimerInfoTagFromItem(const CFileItem &item)
+    {
+      CPVRTimerInfoTagPtr timer;
+
+      const CEpgInfoTagPtr epg(item.GetEPGInfoTag());
+      if (epg)
+        timer = epg->Timer();
+
+      if (!timer)
+        timer = item.GetPVRTimerInfoTag();
+
+      return timer;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Show information (epg, recording)
+
+    std::string ShowInformation::GetLabel(const CFileItem &item) const
+    {
+      if (item.GetPVRRecordingInfoTag())
+        return g_localizeStrings.Get(19053); /* Recording Information */
+
+      return g_localizeStrings.Get(19047); /* Programme information */
+    }
+
+    bool ShowInformation::IsVisible(const CFileItem &item) const
+    {
+      const CPVRChannelPtr channel(item.GetPVRChannelInfoTag());
+      if (channel)
+        return channel->GetEPGNow().get() != nullptr;
+
+      if (item.GetEPGInfoTag())
+        return true;
+
+      const CPVRTimerInfoTagPtr timer(item.GetPVRTimerInfoTag());
+      if (timer && !URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER))
+        return timer->GetEpgInfoTag().get() != nullptr;
+
+      if (item.GetPVRRecordingInfoTag())
+        return true;
+
+      return false;
+    }
+
+    bool ShowInformation::Execute(const CFileItemPtr &item) const
+    {
+      if (item->GetPVRRecordingInfoTag())
+        return CPVRGUIActions::GetInstance().ShowRecordingInfo(item);
+
+      return CPVRGUIActions::GetInstance().ShowEPGInfo(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Find similar
+
+    bool FindSimilar::IsVisible(const CFileItem &item) const
+    {
+      const CPVRChannelPtr channel(item.GetPVRChannelInfoTag());
+      if (channel)
+        return channel->GetEPGNow().get() != nullptr;
+
+      if (item.GetEPGInfoTag())
+        return true;
+
+      const CPVRRecordingPtr recording(item.GetPVRRecordingInfoTag());
+      if (recording)
+        return !recording->IsDeleted();
+
+      return false;
+    }
+
+    bool FindSimilar::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().FindSimilar(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Play channel
+
+    std::string PlayChannel::GetLabel(const CFileItem &item) const
+    {
+      if (item.GetEPGInfoTag())
+        return g_localizeStrings.Get(19000); /* Switch to channel */
+
+      return g_localizeStrings.Get(208); /* Play */
+    }
+
+    bool PlayChannel::IsVisible(const CFileItem &item) const
+    {
+      if (item.GetPVRChannelInfoTag())
+        return true;
+
+      if (item.GetEPGInfoTag())
+        return true;
+
+      return false;
+    }
+
+    bool PlayChannel::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().SwitchToChannel(
+        item, CSettings::GetInstance().GetBool(CSettings::SETTING_PVRPLAYBACK_PLAYMINIMIZED), false /* bCheckResume */);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Resume play recording
+
+    std::string ResumePlayRecording::GetLabel(const CFileItem &item) const
+    {
+      return CPVRGUIActions::GetInstance().GetResumeLabel(item);
+    }
+
+    bool ResumePlayRecording::IsVisible(const CFileItem &item) const
+    {
+      CPVRRecordingPtr recording;
+
+      const CEpgInfoTagPtr epg(item.GetEPGInfoTag());
+      if (epg)
+        recording = epg->Recording();
+
+      if (!recording)
+        recording = item.GetPVRRecordingInfoTag();
+
+      if (recording)
+        return !recording->IsDeleted() && !CPVRGUIActions::GetInstance().GetResumeLabel(item).empty();
+
+      return false;
+    }
+
+    bool ResumePlayRecording::Execute(const CFileItemPtr &item) const
+    {
+      item->m_lStartOffset = STARTOFFSET_RESUME; // must always be set if PlayRecording is called with bCheckResume == false
+      return CPVRGUIActions::GetInstance().PlayRecording(item, false /* bPlayMinimized */, false /* bCheckResume */);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Play recording
+
+    std::string PlayRecording::GetLabel(const CFileItem &item) const
+    {
+      const CPVRRecordingPtr recording(item.GetPVRRecordingInfoTag());
+      if (recording && !recording->IsDeleted())
+      {
+        if (CPVRGUIActions::GetInstance().GetResumeLabel(item).empty())
+          return g_localizeStrings.Get(208); /* Play */
+        else
+          return g_localizeStrings.Get(12021); /* Play from beginning */
+      }
+
+      return g_localizeStrings.Get(19687); /* Play recording */
+    }
+
+    bool PlayRecording::IsVisible(const CFileItem &item) const
+    {
+      CPVRRecordingPtr recording;
+
+      const CEpgInfoTagPtr epg(item.GetEPGInfoTag());
+      if (epg)
+        recording = epg->Recording();
+
+      if (!recording)
+        recording = item.GetPVRRecordingInfoTag();
+
+      if (recording)
+        return !recording->IsDeleted();
+
+      return false;
+    }
+
+    bool PlayRecording::Execute(const CFileItemPtr &item) const
+    {
+      item->m_lStartOffset = 0; // must always be set if PlayRecording is called with bCheckResume == false
+      return CPVRGUIActions::GetInstance().PlayRecording(item, false /* bPlayMinimized */, false /* bCheckResume */);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Mark watched
+
+    bool MarkWatched::IsVisible(const CFileItem &item) const
+    {
+      const CPVRRecordingPtr recording(item.GetPVRRecordingInfoTag());
+      if (!recording)
+        return false;
+
+      // ".." folders don't have have "mark watched" context menu item
+      if (item.IsParentFolder())
+        return false;
+
+      // recording folders always have "mark watched" context menu item
+      if (item.m_bIsFolder)
+        return true;
+
+      if (!recording->IsDeleted())
+      {
+        if (recording->m_playCount == 0)
+          return true;
+      }
+      return false;
+    }
+
+    bool MarkWatched::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().MarkWatched(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Mark unwatched
+
+    bool MarkUnwatched::IsVisible(const CFileItem &item) const
+    {
+      const CPVRRecordingPtr recording(item.GetPVRRecordingInfoTag());
+      if (!recording)
+        return false;
+
+      // ".." folders don't have have "mark unwatched" context menu item
+      if (item.IsParentFolder())
+        return false;
+
+      // recording folders always have "mark unwatched" context menu item
+      if (item.m_bIsFolder)
+        return true;
+
+      if (!recording->IsDeleted())
+      {
+        if (recording->m_playCount > 0)
+          return true;
+      }
+      return false;
+    }
+
+    bool MarkUnwatched::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().MarkUnwatched(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Start recording
+
+    bool StartRecording::IsVisible(const CFileItem &item) const
+    {
+      const CPVRChannelPtr channel(item.GetPVRChannelInfoTag());
+      if (channel)
+        return g_PVRClients->SupportsTimers(channel->ClientID()) && !channel->IsRecording();
+
+      const CEpgInfoTagPtr epg(item.GetEPGInfoTag());
+      if (epg)
+        return g_PVRClients->SupportsTimers() && !epg->Timer() && epg->EndAsLocalTime() > CDateTime::GetCurrentDateTime();
+
+      return false;
+    }
+
+    bool StartRecording::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().AddTimer(item, false);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Stop recording
+
+    bool StopRecording::IsVisible(const CFileItem &item) const
+    {
+      const CPVRChannelPtr channel(item.GetPVRChannelInfoTag());
+      if (channel)
+        return channel->IsRecording();
+
+      const CPVRTimerInfoTagPtr timer(GetTimerInfoTagFromItem(item));
+      if (timer && !URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER))
+        return timer->IsRecording();
+
+      return false;
+    }
+
+    bool StopRecording::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().StopRecording(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Rename recording
+
+    bool RenameRecording::IsVisible(const CFileItem &item) const
+    {
+      const CPVRRecordingPtr recording(item.GetPVRRecordingInfoTag());
+      if (recording && !recording->IsDeleted())
+        return true;
+
+      return false;
+    }
+
+    bool RenameRecording::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().RenameRecording(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Delete recording
+
+    std::string DeleteRecording::GetLabel(const CFileItem &item) const
+    {
+      const CPVRRecordingPtr recording(item.GetPVRRecordingInfoTag());
+      if (recording && recording->IsDeleted())
+        return g_localizeStrings.Get(19291); /* Delete permanently */
+
+      return g_localizeStrings.Get(117); /* Delete */
+    }
+
+    bool DeleteRecording::IsVisible(const CFileItem &item) const
+    {
+      if (item.GetPVRRecordingInfoTag())
+        return true;
+
+      return false;
+    }
+
+    bool DeleteRecording::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().DeleteRecording(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Undelete recording
+
+    bool UndeleteRecording::IsVisible(const CFileItem &item) const
+    {
+      const CPVRRecordingPtr recording(item.GetPVRRecordingInfoTag());
+      if (recording && recording->IsDeleted())
+        return true;
+
+      return false;
+    }
+
+    bool UndeleteRecording::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().UndeleteRecording(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Activate / deactivate timer or timer rule
+
+    std::string ToggleTimerState::GetLabel(const CFileItem &item) const
+    {
+      const CPVRTimerInfoTagPtr timer(item.GetPVRTimerInfoTag());
+      if (timer && timer->m_state != PVR_TIMER_STATE_DISABLED)
+        return g_localizeStrings.Get(844); /* Deactivate */
+
+      return g_localizeStrings.Get(843); /* Activate */
+    }
+
+    bool ToggleTimerState::IsVisible(const CFileItem &item) const
+    {
+      const CPVRTimerInfoTagPtr timer(item.GetPVRTimerInfoTag());
+      if (!timer || URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER))
+        return false;
+
+      const CPVRTimerTypePtr timerType(timer->GetTimerType());
+      return timerType && timerType->SupportsEnableDisable();
+    }
+
+    bool ToggleTimerState::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().ToggleTimerState(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Add timer rule
+
+    bool AddTimerRule::IsVisible(const CFileItem &item) const
+    {
+      const CEpgInfoTagPtr epg(item.GetEPGInfoTag());
+      if (epg)
+        return g_PVRClients->SupportsTimers() && !epg->Timer();
+
+      return false;
+    }
+
+    bool AddTimerRule::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().AddTimerRule(item, true);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Edit timer rule
+
+    bool EditTimerRule::IsVisible(const CFileItem &item) const
+    {
+      const CPVRTimerInfoTagPtr timer(GetTimerInfoTagFromItem(item));
+      if (timer && !URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER))
+        return timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT;
+
+      return false;
+    }
+
+    bool EditTimerRule::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().EditTimerRule(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Delete timer rule
+
+    bool DeleteTimerRule::IsVisible(const CFileItem &item) const
+    {
+      const CPVRTimerInfoTagPtr timer(GetTimerInfoTagFromItem(item));
+      if (timer && !URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER))
+        return timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT;
+
+      return false;
+    }
+
+    bool DeleteTimerRule::Execute(const CFileItemPtr &item) const
+    {
+      CFileItemPtr parentTimer(g_PVRTimers->GetTimerRule(item.get()));
+      if (parentTimer)
+        return CPVRGUIActions::GetInstance().DeleteTimerRule(parentTimer);
+
+      return false;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Edit / View timer
+
+    std::string EditTimer::GetLabel(const CFileItem &item) const
+    {
+      const CPVRTimerInfoTagPtr timer(GetTimerInfoTagFromItem(item));
+      if (timer)
+      {
+        const CPVRTimerTypePtr timerType(timer->GetTimerType());
+        if (timerType && !timerType->IsReadOnly() && timer->GetTimerRuleId() == PVR_TIMER_NO_PARENT)
+        {
+          const CEpgInfoTagPtr epg(item.GetEPGInfoTag());
+          if (epg)
+            return g_localizeStrings.Get(19242); /* Edit timer */
+          else
+            return g_localizeStrings.Get(21450); /* Edit */
+        }
+      }
+
+      return g_localizeStrings.Get(19241); /* View timer information */
+    }
+
+    bool EditTimer::IsVisible(const CFileItem &item) const
+    {
+      const CPVRTimerInfoTagPtr timer(GetTimerInfoTagFromItem(item));
+      if (timer && (!item.GetEPGInfoTag() || !URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER)))
+      {
+        const CPVRTimerTypePtr timerType(timer->GetTimerType());
+        return timerType && !timerType->IsReadOnly() && timer->GetTimerRuleId() == PVR_TIMER_NO_PARENT;
+      }
+
+      return false;
+    }
+
+    bool EditTimer::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().EditTimer(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Rename timer
+
+    bool RenameTimer::IsVisible(const CFileItem &item) const
+    {
+      const CPVRTimerInfoTagPtr timer(item.GetPVRTimerInfoTag());
+      if (!timer || URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER))
+        return false;
+
+      // As epg-based timers will get it's title from the epg tag, they should not be renamable.
+      if (timer->IsManual())
+      {
+        const CPVRTimerTypePtr timerType(timer->GetTimerType());
+        if (!timerType->IsReadOnly())
+          return true;
+      }
+
+      return false;
+    }
+
+    bool RenameTimer::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().RenameTimer(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Delete timer
+
+    std::string DeleteTimer::GetLabel(const CFileItem &item) const
+    {
+      if (item.GetPVRTimerInfoTag())
+        return g_localizeStrings.Get(117); /* Delete */
+
+      return g_localizeStrings.Get(19060); /* Delete timer */
+    }
+
+    bool DeleteTimer::IsVisible(const CFileItem &item) const
+    {
+      const CPVRTimerInfoTagPtr timer(GetTimerInfoTagFromItem(item));
+      if (timer && (!item.GetEPGInfoTag() || !URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER)) && !timer->IsRecording())
+      {
+        const CPVRTimerTypePtr timerType(timer->GetTimerType());
+        return  timerType && !timerType->IsReadOnly();
+      }
+
+      return false;
+    }
+
+    bool DeleteTimer::Execute(const CFileItemPtr &item) const
+    {
+      return CPVRGUIActions::GetInstance().DeleteTimer(item);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // Show Audio DSP settings
+
+    bool ShowAudioDSPSettings::IsVisible(const CFileItem &item) const
+    {
+      if (item.GetPVRChannelInfoTag() || item.GetPVRRecordingInfoTag())
+        return CServiceBroker::GetADSP().IsProcessing();
+
+      return false;
+    }
+
+    bool ShowAudioDSPSettings::Execute(const CFileItemPtr &item) const
+    {
+      g_windowManager.ActivateWindow(WINDOW_DIALOG_AUDIO_DSP_OSD_SETTINGS);
+      return true;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // PVR Client menu hook
+
+    bool PVRClientMenuHook::IsVisible(const CFileItem &item) const
+    {
+      const CPVRChannelPtr channel(item.GetPVRChannelInfoTag());
+      if (channel)
+        return g_PVRClients->HasMenuHooks(channel->ClientID(), PVR_MENUHOOK_CHANNEL);
+
+      const CEpgInfoTagPtr epg(item.GetEPGInfoTag());
+      if (epg)
+      {
+        const CPVRChannelPtr channel(epg->ChannelTag());
+        return (channel && g_PVRClients->HasMenuHooks(channel->ClientID(), PVR_MENUHOOK_EPG));
+      }
+
+      const CPVRTimerInfoTagPtr timer(item.GetPVRTimerInfoTag());
+      if (timer && !URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER))
+        return g_PVRClients->HasMenuHooks(timer->m_iClientId, PVR_MENUHOOK_TIMER);
+
+      const CPVRRecordingPtr recording(item.GetPVRRecordingInfoTag());
+      if (recording)
+      {
+        if (recording->IsDeleted())
+          return g_PVRClients->HasMenuHooks(recording->m_iClientId, PVR_MENUHOOK_DELETED_RECORDING);
+        else
+          return g_PVRClients->HasMenuHooks(recording->m_iClientId, PVR_MENUHOOK_RECORDING);
+      }
+
+      return false;
+    }
+
+    bool PVRClientMenuHook::Execute(const CFileItemPtr &item) const
+    {
+      if (item->IsEPG() && item->GetEPGInfoTag()->HasPVRChannel())
+        g_PVRClients->ProcessMenuHooks(item->GetEPGInfoTag()->ChannelTag()->ClientID(), PVR_MENUHOOK_EPG, item.get());
+      else if (item->IsPVRChannel())
+        g_PVRClients->ProcessMenuHooks(item->GetPVRChannelInfoTag()->ClientID(), PVR_MENUHOOK_CHANNEL, item.get());
+      else if (item->IsDeletedPVRRecording())
+        g_PVRClients->ProcessMenuHooks(item->GetPVRRecordingInfoTag()->m_iClientId, PVR_MENUHOOK_DELETED_RECORDING, item.get());
+      else if (item->IsUsablePVRRecording())
+        g_PVRClients->ProcessMenuHooks(item->GetPVRRecordingInfoTag()->m_iClientId, PVR_MENUHOOK_RECORDING, item.get());
+      else if (item->IsPVRTimer())
+        g_PVRClients->ProcessMenuHooks(item->GetPVRTimerInfoTag()->m_iClientId, PVR_MENUHOOK_TIMER, item.get());
+      else
+        return false;
+
+      return true;
+    }
+  } // namespace CONEXTMENUITEM
+
+  CPVRContextMenuManager& CPVRContextMenuManager::GetInstance()
+  {
+    static CPVRContextMenuManager instance;
+    return instance;
+  }
+
+  CPVRContextMenuManager::CPVRContextMenuManager()
+  {
+    m_items =
+    {
+      std::make_shared<CONTEXTMENUITEM::ShowInformation>(),
+      std::make_shared<CONTEXTMENUITEM::FindSimilar>(19003), /* Find similar */
+      std::make_shared<CONTEXTMENUITEM::PlayChannel>(),
+      std::make_shared<CONTEXTMENUITEM::ResumePlayRecording>(),
+      std::make_shared<CONTEXTMENUITEM::PlayRecording>(),
+      std::make_shared<CONTEXTMENUITEM::MarkWatched>(16103), /* Mark as watched */
+      std::make_shared<CONTEXTMENUITEM::MarkUnwatched>(16104), /* Mark as unwatched */
+      std::make_shared<CONTEXTMENUITEM::ToggleTimerState>(),
+      std::make_shared<CONTEXTMENUITEM::AddTimerRule>(19061), /* Add timer */
+      std::make_shared<CONTEXTMENUITEM::EditTimerRule>(19243), /* Edit timer rule */
+      std::make_shared<CONTEXTMENUITEM::DeleteTimerRule>(19295), /* Delete timer rule */
+      std::make_shared<CONTEXTMENUITEM::EditTimer>(),
+      std::make_shared<CONTEXTMENUITEM::RenameTimer>(118), /* Rename */
+      std::make_shared<CONTEXTMENUITEM::DeleteTimer>(),
+      std::make_shared<CONTEXTMENUITEM::StartRecording>(264), /* Record */
+      std::make_shared<CONTEXTMENUITEM::StopRecording>(19059), /* Stop recording */
+      std::make_shared<CONTEXTMENUITEM::RenameRecording>(118), /* Rename */
+      std::make_shared<CONTEXTMENUITEM::DeleteRecording>(),
+      std::make_shared<CONTEXTMENUITEM::UndeleteRecording>(19290), /* Undelete */
+      std::make_shared<CONTEXTMENUITEM::ShowAudioDSPSettings>(15047), /* Audio DSP settings */
+      std::make_shared<CONTEXTMENUITEM::PVRClientMenuHook>(19195), /* PVR client specific action */
+    };
+  }
+
+} // namespace PVR
diff --git a/xbmc/pvr/PVRContextMenus.h b/xbmc/pvr/PVRContextMenus.h
new file mode 100644
index 0000000..704855f
--- /dev/null
+++ b/xbmc/pvr/PVRContextMenus.h
@@ -0,0 +1,45 @@
+#pragma once
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <memory>
+#include <vector>
+
+class IContextMenuItem;
+
+namespace PVR
+{
+  class CPVRContextMenuManager
+  {
+  public:
+    static CPVRContextMenuManager& GetInstance();
+
+    std::vector<std::shared_ptr<IContextMenuItem>> GetMenuItems() const { return m_items; }
+
+  private:
+    CPVRContextMenuManager();
+    CPVRContextMenuManager(const CPVRContextMenuManager&) = delete;
+    CPVRContextMenuManager const& operator=(CPVRContextMenuManager const&) = delete;
+    virtual ~CPVRContextMenuManager() = default;
+
+    std::vector<std::shared_ptr<IContextMenuItem>> m_items;
+  };
+
+} // namespace PVR
diff --git a/xbmc/pvr/PVRGUIActions.cpp b/xbmc/pvr/PVRGUIActions.cpp
new file mode 100644
index 0000000..eb5b9e6
--- /dev/null
+++ b/xbmc/pvr/PVRGUIActions.cpp
@@ -0,0 +1,746 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "Application.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "epg/EpgInfoTag.h"
+#include "FileItem.h"
+#include "filesystem/Directory.h"
+#include "filesystem/StackDirectory.h"
+#include "guilib/GUIKeyboardFactory.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "messaging/ApplicationMessenger.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/dialogs/GUIDialogPVRGuideInfo.h"
+#include "pvr/dialogs/GUIDialogPVRRecordingInfo.h"
+#include "pvr/dialogs/GUIDialogPVRTimerSettings.h"
+#include "pvr/PVRItem.h"
+#include "pvr/PVRManager.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "pvr/windows/GUIWindowPVRSearch.h"
+#include "settings/MediaSettings.h"
+#include "settings/Settings.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/log.h"
+#include "video/VideoDatabase.h"
+
+#include "PVRGUIActions.h"
+
+using namespace EPG;
+using namespace KODI::MESSAGING;
+
+namespace PVR
+{
+  CPVRGUIActions& CPVRGUIActions::GetInstance()
+  {
+    static CPVRGUIActions instance;
+    return instance;
+  }
+
+  bool CPVRGUIActions::ShowEPGInfo(const CFileItemPtr &item) const
+  {
+    const CPVRChannelPtr channel(CPVRItem(item).GetChannel());
+    if (channel && !g_PVRManager.CheckParentalLock(channel))
+      return false;
+
+    const CEpgInfoTagPtr epgTag(CPVRItem(item).GetEpgInfoTag());
+    if (!epgTag)
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - no epg tag!", __FUNCTION__);
+      return false;
+    }
+
+    CGUIDialogPVRGuideInfo* pDlgInfo = dynamic_cast<CGUIDialogPVRGuideInfo*>(g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GUIDE_INFO));
+    if (!pDlgInfo)
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - unable to get WINDOW_DIALOG_PVR_GUIDE_INFO!", __FUNCTION__);
+      return false;
+    }
+
+    pDlgInfo->SetProgInfo(epgTag);
+    pDlgInfo->Open();
+    return true;
+  }
+
+  bool CPVRGUIActions::ShowRecordingInfo(const CFileItemPtr &item) const
+  {
+    if (!item->IsPVRRecording())
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - no recording!", __FUNCTION__);
+      return false;
+    }
+
+    CGUIDialogPVRRecordingInfo* pDlgInfo = dynamic_cast<CGUIDialogPVRRecordingInfo*>(g_windowManager.GetWindow(WINDOW_DIALOG_PVR_RECORDING_INFO));
+    if (!pDlgInfo)
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - unable to get WINDOW_DIALOG_PVR_RECORDING_INFO!", __FUNCTION__);
+      return false;
+    }
+
+    pDlgInfo->SetRecording(item.get());
+    pDlgInfo->Open();
+    return true;
+  }
+
+  bool CPVRGUIActions::FindSimilar(const CFileItemPtr &item, CGUIWindow *windowToClose /* = nullptr */) const
+  {
+    const bool bRadio(CPVRItem(item).IsRadio());
+
+    int windowSearchId = bRadio ? WINDOW_RADIO_SEARCH : WINDOW_TV_SEARCH;
+    CGUIWindowPVRSearch *windowSearch = dynamic_cast<CGUIWindowPVRSearch*>(g_windowManager.GetWindow(windowSearchId));
+    if (!windowSearch)
+    {
+      CLog::Log(LOGERROR, "PVRGUIActions - %s - unable to get %s!", __FUNCTION__, bRadio ? "WINDOW_RADIO_SEARCH" : "WINDOW_TV_SEARCH");
+      return false;
+    }
+
+    if (windowToClose)
+      windowToClose->Close();
+
+    g_windowManager.ActivateWindow(windowSearchId);
+    return windowSearch->FindSimilar(item);
+  };
+
+  bool CPVRGUIActions::ShowTimerSettings(const CPVRTimerInfoTagPtr &timer) const
+  {
+    CGUIDialogPVRTimerSettings* pDlgInfo = dynamic_cast<CGUIDialogPVRTimerSettings*>(g_windowManager.GetWindow(WINDOW_DIALOG_PVR_TIMER_SETTING));
+    if (!pDlgInfo)
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - unable to get WINDOW_DIALOG_PVR_TIMER_SETTING!", __FUNCTION__);
+      return false;
+    }
+
+    pDlgInfo->SetTimer(timer);
+    pDlgInfo->Open();
+
+    return pDlgInfo->IsConfirmed();
+  }
+
+  bool CPVRGUIActions::AddTimer(bool bRadio) const
+  {
+    const CPVRTimerInfoTagPtr newTimer(new CPVRTimerInfoTag(bRadio));
+    if (ShowTimerSettings(newTimer))
+    {
+      /* Add timer to backend */
+      return g_PVRTimers->AddTimer(newTimer);
+    }
+    return false;
+  }
+
+  bool CPVRGUIActions::AddTimer(const CFileItemPtr &item, bool bShowTimerSettings) const
+  {
+    return AddTimer(item, false, bShowTimerSettings);
+  }
+
+  bool CPVRGUIActions::AddTimerRule(const CFileItemPtr &item, bool bShowTimerSettings) const
+  {
+    return AddTimer(item, true, bShowTimerSettings);
+  }
+
+  bool CPVRGUIActions::AddTimer(const CFileItemPtr &item, bool bCreateRule, bool bShowTimerSettings) const
+  {
+    const CPVRChannelPtr channel(CPVRItem(item).GetChannel());
+    if (!channel)
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - no channel!", __FUNCTION__);
+      return false;
+    }
+
+    if (!g_PVRManager.CheckParentalLock(channel))
+      return false;
+
+    const CEpgInfoTagPtr epgTag(CPVRItem(item).GetEpgInfoTag());
+    if (!epgTag && bCreateRule)
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - no epg tag!", __FUNCTION__);
+      return false;
+    }
+
+    CPVRTimerInfoTagPtr timer(bCreateRule || !epgTag ? nullptr : epgTag->Timer());
+    CPVRTimerInfoTagPtr rule (bCreateRule ? g_PVRTimers->GetTimerRule(timer) : nullptr);
+    if (timer || rule)
+    {
+      CGUIDialogOK::ShowAndGetInput(CVariant{19033}, CVariant{19034}); // "Information", "There is already a timer set for this event"
+      return false;
+    }
+
+    CPVRTimerInfoTagPtr newTimer(epgTag ? CPVRTimerInfoTag::CreateFromEpg(epgTag, bCreateRule) : CPVRTimerInfoTag::CreateInstantTimerTag(channel));
+    if (!newTimer)
+    {
+      CGUIDialogOK::ShowAndGetInput(CVariant{19033},
+                                    bCreateRule
+                                      ? CVariant{19095} // "Information", "Timer rule creation failed. The PVR add-on does not support a suitable timer rule type."
+                                      : CVariant{19094}); // "Information", "Timer creation failed. The PVR add-on does not support a suitable timer type."
+      return false;
+    }
+
+    if (bShowTimerSettings)
+    {
+      if (!ShowTimerSettings(newTimer))
+        return false;
+    }
+
+    return g_PVRTimers->AddTimer(newTimer);
+  }
+
+  bool CPVRGUIActions::ToggleTimer(const CFileItemPtr &item) const
+  {
+    if (!item->HasEPGInfoTag())
+      return false;
+
+    const CPVRTimerInfoTagPtr timer(CPVRItem(item).GetTimerInfoTag());
+    if (timer)
+    {
+      if (timer->IsRecording())
+        return StopRecording(item);
+      else
+        return DeleteTimer(item);
+    }
+    else
+      return AddTimer(item, false);
+  }
+
+  bool CPVRGUIActions::ToggleTimerState(const CFileItemPtr &item) const
+  {
+    if (!item->HasPVRTimerInfoTag())
+      return false;
+
+    const CPVRTimerInfoTagPtr timer(item->GetPVRTimerInfoTag());
+    if (timer->m_state == PVR_TIMER_STATE_DISABLED)
+      timer->m_state = PVR_TIMER_STATE_SCHEDULED;
+    else
+      timer->m_state = PVR_TIMER_STATE_DISABLED;
+
+    return g_PVRTimers->UpdateTimer(timer);
+  }
+
+  bool CPVRGUIActions::EditTimer(const CFileItemPtr &item) const
+  {
+    const CPVRTimerInfoTagPtr timer(CPVRItem(item).GetTimerInfoTag());
+    if (!timer)
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - no timer!", __FUNCTION__);
+      return false;
+    }
+
+    // clone the timer.
+    const CPVRTimerInfoTagPtr newTimer(new CPVRTimerInfoTag);
+    newTimer->UpdateEntry(timer);
+
+    if (ShowTimerSettings(newTimer) && (!timer->GetTimerType()->IsReadOnly() || timer->GetTimerType()->SupportsEnableDisable()))
+    {
+      if (newTimer->GetTimerType() == timer->GetTimerType())
+      {
+        return g_PVRTimers->UpdateTimer(newTimer);
+      }
+      else
+      {
+        // timer type changed. delete the original timer, then create the new timer. this order is
+        // important. for instance, the new timer might be a rule which schedules the original timer.
+        // deleting the original timer after creating the rule would do literally this and we would
+        // end up with one timer missing wrt to the rule defined by the new timer.
+        if (g_PVRTimers->DeleteTimer(timer, timer->IsRecording(), false))
+        {
+          if (g_PVRTimers->AddTimer(newTimer))
+            return true;
+
+          // rollback.
+          return g_PVRTimers->AddTimer(timer);
+        }
+      }
+    }
+    return false;
+  }
+
+  bool CPVRGUIActions::EditTimerRule(const CFileItemPtr &item) const
+  {
+    CFileItemPtr parentTimer(g_PVRTimers->GetTimerRule(item.get()));
+    if (parentTimer)
+      return EditTimer(parentTimer);
+
+    return false;
+  }
+
+  bool CPVRGUIActions::RenameTimer(const CFileItemPtr &item) const
+  {
+    if (!item->HasPVRTimerInfoTag())
+      return false;
+
+    const CPVRTimerInfoTagPtr timer(item->GetPVRTimerInfoTag());
+
+    std::string strNewName(timer->m_strTitle);
+    if (CGUIKeyboardFactory::ShowAndGetInput(strNewName,
+                                             CVariant{g_localizeStrings.Get(19042)}, // "Are you sure you want to rename this timer?"
+                                             false))
+    {
+      if (!g_PVRTimers->RenameTimer(*item, strNewName))
+        return false;
+    }
+
+    CGUIWindowPVRBase *pvrWindow = dynamic_cast<CGUIWindowPVRBase *>(g_windowManager.GetWindow(g_windowManager.GetActiveWindow()));
+    if (pvrWindow)
+      pvrWindow->DoRefresh();
+    else
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - called on non-pvr window. no refresh possible.", __FUNCTION__);
+
+    return true;
+  }
+
+  bool CPVRGUIActions::DeleteTimer(const CFileItemPtr &item) const
+  {
+    return DeleteTimer(item, false, false);
+  }
+
+  bool CPVRGUIActions::DeleteTimerRule(const CFileItemPtr &item) const
+  {
+    return DeleteTimer(item, false, true);
+  }
+
+  bool CPVRGUIActions::DeleteTimer(const CFileItemPtr &item, bool bIsRecording, bool bDeleteRule) const
+  {
+    CPVRTimerInfoTagPtr timer(CPVRItem(item).GetTimerInfoTag());
+    if (!timer)
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - no timer!", __FUNCTION__);
+      return false;
+    }
+
+    if (bDeleteRule && !timer->IsTimerRule())
+      timer = g_PVRTimers->GetTimerRule(timer);
+
+    if (!timer)
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - no timer rule!", __FUNCTION__);
+      return false;
+    }
+
+    if (bIsRecording)
+    {
+      if (ConfirmStopRecording(timer))
+        return g_PVRTimers->DeleteTimer(timer, true, false);
+    }
+    else if (timer->HasTimerType() && timer->GetTimerType()->IsReadOnly())
+    {
+      return false;
+    }
+    else
+    {
+      bool bAlsoDeleteRule(false);
+      if (ConfirmDeleteTimer(timer, bAlsoDeleteRule))
+        return g_PVRTimers->DeleteTimer(timer, false, bAlsoDeleteRule);
+    }
+    return false;
+  }
+
+  bool CPVRGUIActions::ConfirmDeleteTimer(const CPVRTimerInfoTagPtr &timer, bool &bDeleteRule) const
+  {
+    bool bConfirmed(false);
+
+    if (timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
+    {
+      // timer was scheduled by a timer rule. prompt user for confirmation for deleting the timer rule, including scheduled timers.
+      bool bCancel(false);
+      bDeleteRule = CGUIDialogYesNo::ShowAndGetInput(CVariant{122}, // "Confirm delete"
+                                                     CVariant{840}, // "Do you want to delete only this timer or also the timer rule that has scheduled it?"
+                                                     CVariant{""},
+                                                     CVariant{timer->Title()},
+                                                     bCancel,
+                                                     CVariant{841}, // "Only this"
+                                                     CVariant{593}, // "All"
+                                                     0); // no autoclose
+      bConfirmed = !bCancel;
+    }
+    else
+    {
+      bDeleteRule = false;
+
+      // prompt user for confirmation for deleting the timer
+      bConfirmed = CGUIDialogYesNo::ShowAndGetInput(CVariant{122}, // "Confirm delete"
+                                                    timer->IsTimerRule()
+                                                      ? CVariant{845}  // "Are you sure you want to delete this timer rule and all timers it has scheduled?"
+                                                      : CVariant{846}, // "Are you sure you want to delete this timer?"
+                                                    CVariant{""},
+                                                    CVariant{timer->Title()});
+    }
+
+    return bConfirmed;
+  }
+
+  bool CPVRGUIActions::StopRecording(const CFileItemPtr &item) const
+  {
+    if (!DeleteTimer(item, true, false))
+      return false;
+
+    g_PVRManager.TriggerRecordingsUpdate();
+    return true;
+  }
+
+  bool CPVRGUIActions::ConfirmStopRecording(const CPVRTimerInfoTagPtr &timer) const
+  {
+    return CGUIDialogYesNo::ShowAndGetInput(CVariant{847}, // "Confirm stop recording"
+                                            CVariant{848}, // "Are you sure you want to stop this recording?"
+                                            CVariant{""},
+                                            CVariant{timer->Title()});
+  }
+
+  bool CPVRGUIActions::RenameRecording(const CFileItemPtr &item) const
+  {
+    const CPVRRecordingPtr recording(item->GetPVRRecordingInfoTag());
+    if (!recording)
+      return false;
+
+    std::string strNewName(recording->m_strTitle);
+    if (!CGUIKeyboardFactory::ShowAndGetInput(strNewName, CVariant{g_localizeStrings.Get(19041)}, false))
+      return false;
+
+    if (!g_PVRRecordings->RenameRecording(*item, strNewName))
+      return false;
+
+    g_PVRManager.TriggerRecordingsUpdate();
+    return true;
+  }
+
+  bool CPVRGUIActions::DeleteRecording(const CFileItemPtr &item) const
+  {
+    if ((!item->IsPVRRecording() && !item->m_bIsFolder) || item->IsParentFolder())
+      return false;
+
+    if (!ConfirmDeleteRecording(item))
+      return false;
+
+    if (!g_PVRRecordings->Delete(*item))
+      return false;
+
+    g_PVRManager.TriggerRecordingsUpdate();
+    return true;
+  }
+
+  bool CPVRGUIActions::ConfirmDeleteRecording(const CFileItemPtr &item) const
+  {
+    return CGUIDialogYesNo::ShowAndGetInput(CVariant{122}, // "Confirm delete"
+                                            item->m_bIsFolder
+                                              ? CVariant{19113} // "Delete all recordings in this folder?"
+                                              : item->GetPVRRecordingInfoTag()->IsDeleted()
+                                                ? CVariant{19294}  // "Remove this deleted recording from trash? This operation cannot be reverted."
+                                                : CVariant{19112}, // "Delete this recording?"
+                                            CVariant{""},
+                                            CVariant{item->GetLabel()});
+  }
+
+  bool CPVRGUIActions::DeleteAllRecordingsFromTrash() const
+  {
+    if (!ConfirmDeleteAllRecordingsFromTrash())
+      return false;
+
+    if (!g_PVRRecordings->DeleteAllRecordingsFromTrash())
+      return false;
+
+    g_PVRManager.TriggerRecordingsUpdate();
+    return true;
+  }
+
+  bool CPVRGUIActions::ConfirmDeleteAllRecordingsFromTrash() const
+  {
+    return CGUIDialogYesNo::ShowAndGetInput(CVariant{19292},  // "Delete all permanently"
+                                            CVariant{19293}); // "Remove all deleted recordings from trash? This operation cannot be reverted."
+  }
+
+  bool CPVRGUIActions::UndeleteRecording(const CFileItemPtr &item) const
+  {
+    if (!item->IsDeletedPVRRecording())
+      return false;
+
+    /* undelete the recording */
+    if (!g_PVRRecordings->Undelete(*item))
+      return false;
+
+    g_PVRManager.TriggerRecordingsUpdate();
+    return true;
+  }
+
+  std::string CPVRGUIActions::GetResumeLabel(const CFileItem &item) const
+  {
+    std::string resumeString;
+
+    const CPVRRecordingPtr recording(CPVRItem(CFileItemPtr(new CFileItem(item))).GetRecording());
+    if (recording && !recording->IsDeleted())
+    {
+      // First try to find the resume position on the back-end, if that fails use video database
+      int positionInSeconds = recording->GetLastPlayedPosition();
+      // If the back-end does report a saved position it will be picked up by FileItem
+      if (positionInSeconds < 0)
+      {
+        CVideoDatabase db;
+        if (db.Open())
+        {
+          CBookmark bookmark;
+          std::string itemPath(recording->m_strFileNameAndPath);
+          if (db.GetResumeBookMark(itemPath, bookmark) )
+            positionInSeconds = lrint(bookmark.timeInSeconds);
+          db.Close();
+        }
+      }
+
+      // Suppress resume from 0
+      if (positionInSeconds > 0)
+        resumeString = StringUtils::Format(g_localizeStrings.Get(12022).c_str(),
+                                           StringUtils::SecondsToTimeString(positionInSeconds, TIME_FORMAT_HH_MM_SS).c_str());
+    }
+    return resumeString;
+  }
+
+  bool CPVRGUIActions::CheckResumeRecording(const CFileItemPtr &item) const
+  {
+    bool bPlayIt(true);
+    std::string resumeString(GetResumeLabel(*item));
+    if (!resumeString.empty())
+    {
+      CContextButtons choices;
+      choices.Add(CONTEXT_BUTTON_RESUME_ITEM, resumeString);
+      choices.Add(CONTEXT_BUTTON_PLAY_ITEM, 12021); // Play from beginning
+      int choice = CGUIDialogContextMenu::ShowAndGetChoice(choices);
+      if (choice > 0)
+        item->m_lStartOffset = choice == CONTEXT_BUTTON_RESUME_ITEM ? STARTOFFSET_RESUME : 0;
+      else
+        bPlayIt = false; // context menu cancelled
+    }
+    return bPlayIt;
+  }
+
+  bool CPVRGUIActions::ResumePlayRecording(const CFileItemPtr &item, bool bPlayMinimized, bool bFallbackToPlay) const
+  {
+    bool bCanResume = !GetResumeLabel(*item).empty();
+    if (bCanResume)
+    {
+      item->m_lStartOffset = STARTOFFSET_RESUME;
+    }
+    else
+    {
+      if (bFallbackToPlay)
+        item->m_lStartOffset = 0;
+      else
+        return false;
+    }
+
+    return PlayRecording(item, bPlayMinimized, false);
+  }
+
+  bool CPVRGUIActions::PlayRecording(const CFileItemPtr &item, bool bPlayMinimized, bool bCheckResume) const
+  {
+    const CPVRRecordingPtr recording(CPVRItem(item).GetRecording());
+    if (!recording)
+      return false;
+
+    std::string stream = recording->m_strStreamURL;
+    if (stream.empty())
+    {
+      if (!bCheckResume || CheckResumeRecording(item))
+      {
+        CFileItem *itemToPlay = new CFileItem(recording);
+        itemToPlay->m_lStartOffset = item->m_lStartOffset;
+        CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PLAY, 0, 0, static_cast<void*>(itemToPlay));
+      }
+      return true;
+    }
+
+    /* Isolate the folder from the filename */
+    size_t found = stream.find_last_of("/");
+    if (found == std::string::npos)
+      found = stream.find_last_of("\\");
+
+    if (found != std::string::npos)
+    {
+      /* Check here for asterisk at the begin of the filename */
+      if (stream[found+1] == '*')
+      {
+        /* Create a "stack://" url with all files matching the extension */
+        std::string ext = URIUtils::GetExtension(stream);
+        std::string dir = stream.substr(0, found);
+
+        CFileItemList items;
+        XFILE::CDirectory::GetDirectory(dir, items);
+        items.Sort(SortByFile, SortOrderAscending);
+
+        std::vector<int> stack;
+        for (int i = 0; i < items.Size(); ++i)
+        {
+          if (URIUtils::HasExtension(items[i]->GetPath(), ext))
+            stack.push_back(i);
+        }
+
+        if (stack.empty())
+        {
+          /* If we have a stack change the path of the item to it */
+          XFILE::CStackDirectory dir;
+          std::string stackPath = dir.ConstructStackPath(items, stack);
+          item->SetPath(stackPath);
+        }
+      }
+      else
+      {
+        /* If no asterisk is present play only the given stream URL */
+        item->SetPath(stream);
+      }
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - can't open recording: no valid filename", __FUNCTION__);
+      CGUIDialogOK::ShowAndGetInput(CVariant{19033}, CVariant{19036});
+      return false;
+    }
+
+    if (!bCheckResume || CheckResumeRecording(item))
+      CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PLAY, 0, 0, static_cast<void*>(new CFileItem(*item)));
+
+    return true;
+  }
+
+  bool CPVRGUIActions::SwitchToChannel(const CFileItemPtr &item, bool bPlayMinimized, bool bCheckResume) const
+  {
+    if (item->m_bIsFolder)
+      return false;
+
+    const CPVRChannelPtr channel(CPVRItem(item).GetChannel());
+    if ((channel && g_PVRManager.IsPlayingChannel(channel)) ||
+        (channel && channel->HasRecording() && g_PVRManager.IsPlayingRecording(channel->GetRecording())))
+    {
+      CGUIMessage msg(GUI_MSG_FULLSCREEN, 0, g_windowManager.GetActiveWindow());
+      g_windowManager.SendMessage(msg);
+      return true;
+    }
+
+    CMediaSettings::GetInstance().SetVideoStartWindowed(bPlayMinimized);
+
+    // switch to channel or if recording present, ask whether to switch or play recording...
+    bool bSwitchSuccessful(false);
+
+    if (channel && g_PVRManager.CheckParentalLock(channel))
+    {
+      const CPVRRecordingPtr recording(channel->GetRecording());
+      if (recording)
+      {
+        bool bCancel(false);
+        bool bPlayRecording = CGUIDialogYesNo::ShowAndGetInput(CVariant{19687}, // "Play recording"
+                                                       CVariant{""},
+                                                       CVariant{12021}, // "Play from beginning"
+                                                       CVariant{recording->m_strTitle},
+                                                       bCancel,
+                                                       CVariant{19000}, // "Switch to channel"
+                                                       CVariant{19687}, // "Play recording"
+                                                       0); // no autoclose
+        if (bCancel)
+          return false;
+
+        if (bPlayRecording)
+        {
+          const CFileItemPtr recordingItem(new CFileItem(recording));
+          return PlayRecording(recordingItem, CSettings::GetInstance().GetBool(CSettings::SETTING_PVRPLAYBACK_PLAYMINIMIZED), bCheckResume);
+        }
+      }
+
+      /* try a fast switch */
+      if ((g_PVRManager.IsPlayingTV() || g_PVRManager.IsPlayingRadio()) &&
+          (channel->IsRadio() == g_PVRManager.IsPlayingRadio()))
+      {
+        if (channel->StreamURL().empty())
+          bSwitchSuccessful = g_application.m_pPlayer->SwitchChannel(channel);
+      }
+
+      if (!bSwitchSuccessful)
+      {
+        CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PLAY, 0, 0, static_cast<void*>(new CFileItem(channel)));
+        return true;
+      }
+    }
+
+    if (!bSwitchSuccessful)
+    {
+      std::string channelName = g_localizeStrings.Get(19029); // Channel
+      if (channel)
+        channelName = channel->ChannelName();
+      std::string msg = StringUtils::Format(g_localizeStrings.Get(19035).c_str(), channelName.c_str()); // CHANNELNAME could not be played. Check the log for details.
+
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(19166), msg); // PVR information
+      return false;
+    }
+
+    return true;
+  }
+
+  bool CPVRGUIActions::HideChannel(const CFileItemPtr &item) const
+  {
+    const CPVRChannelPtr channel(item->GetPVRChannelInfoTag());
+
+    /* check if the channel tag is valid */
+    if (!channel || channel->ChannelNumber() <= 0)
+      return false;
+
+    if (!CGUIDialogYesNo::ShowAndGetInput(CVariant{19054}, // "Hide channel"
+                                          CVariant{19039}, // "Are you sure you want to hide this channel?"
+                                          CVariant{""},
+                                          CVariant{channel->ChannelName()}))
+      return false;
+
+    if (!g_PVRChannelGroups->GetGroupAll(channel->IsRadio())->RemoveFromGroup(channel))
+      return false;
+
+    CGUIWindowPVRBase *pvrWindow = dynamic_cast<CGUIWindowPVRBase *>(g_windowManager.GetWindow(g_windowManager.GetActiveWindow()));
+    if (pvrWindow)
+      pvrWindow->DoRefresh();
+    else
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - called on non-pvr window. no refresh possible.", __FUNCTION__);
+
+    return true;
+  }
+
+  bool CPVRGUIActions::MarkWatched(const CFileItemPtr &item) const
+  {
+    if (!g_PVRRecordings->IncrementRecordingsPlayCount(item))
+      return false;
+
+    CGUIWindowPVRBase *pvrWindow = dynamic_cast<CGUIWindowPVRBase *>(g_windowManager.GetWindow(g_windowManager.GetActiveWindow()));
+    if (pvrWindow)
+      pvrWindow->DoRefresh();
+    else
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - called on non-pvr window. no refresh possible.", __FUNCTION__);
+
+    return true;
+  }
+
+  bool CPVRGUIActions::MarkUnwatched(const CFileItemPtr &item) const
+  {
+    if (!g_PVRRecordings->SetRecordingsPlayCount(item, 0))
+      return false;
+
+    CGUIWindowPVRBase *pvrWindow = dynamic_cast<CGUIWindowPVRBase *>(g_windowManager.GetWindow(g_windowManager.GetActiveWindow()));
+    if (pvrWindow)
+      pvrWindow->DoRefresh();
+    else
+      CLog::Log(LOGERROR, "CPVRGUIActions - %s - called on non-pvr window. no refresh possible.", __FUNCTION__);
+
+    return true;
+  }
+
+} // namespace PVR
diff --git a/xbmc/pvr/PVRGUIActions.h b/xbmc/pvr/PVRGUIActions.h
new file mode 100644
index 0000000..4816245
--- /dev/null
+++ b/xbmc/pvr/PVRGUIActions.h
@@ -0,0 +1,296 @@
+#pragma once
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "pvr/PVRTypes.h"
+
+#include <memory>
+#include <string>
+
+class CFileItem;
+typedef std::shared_ptr<CFileItem> CFileItemPtr;
+
+class CGUIWindow;
+
+namespace PVR
+{
+  class CPVRGUIActions
+  {
+  public:
+    /*!
+     * @brief Request an instance of class CPVRGUIActions.
+     * @return the instance.
+     */
+    static CPVRGUIActions& GetInstance();
+
+    /*!
+     * @brief Open a dialog with epg information for a given item.
+     * @param item containing epg data to show. item must be an epg tag, a channel or a timer.
+     * @return true on success, false otherwise.
+     */
+    bool ShowEPGInfo(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Open a window containing a list of epg tags 'similar' to a given item.
+     * @param item containing epg data for matching. item must be an epg tag, a channel or a recording.
+     * @param windowToClose is the window to close before opening the window with the search reasults.
+     * @return true on success, false otherwise.
+     */
+    bool FindSimilar(const CFileItemPtr &item, CGUIWindow *windowToClose = nullptr) const;
+
+    /*!
+     * @brief Open the timer settings dialog to create a new tv or radio timer.
+     * @param bRadio indicates whether a radio or tv timer shall be created.
+     * @return true on success, false otherwise.
+     */
+    bool AddTimer(bool bRadio) const;
+
+    /*!
+     * @brief Create a new timer, either interactive or non-interactive.
+     * @param item containing epg data to create a timer for. item must be an epg tag or a channel.
+     * @param bShowTimerSettings is used to control whether a settings dialog will be opened prior creating the timer.
+     * @return true, if the timer was created successfully, false otherwise.
+     */
+    bool AddTimer(const CFileItemPtr &item, bool bShowTimerSettings) const;
+
+    /*!
+     * @brief Create a new timer rule, either interactive or non-interactive.
+     * @param item containing epg data to create a timer rule for. item must be an epg tag or a channel.
+     * @param bShowTimerSettings is used to control whether a settings dialog will be opened prior creating the timer rule.
+     * @return true, if the timer rule was created successfully, false otherwise.
+     */
+    bool AddTimerRule(const CFileItemPtr &item, bool bShowTimerSettings) const;
+
+    /*!
+     * @brief Creates or deletes a timer for the given epg tag.
+     * @param item containing an epg tag.
+     * @return true on success, false otherwise.
+     */
+    bool ToggleTimer(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Toggles a given timer's enabled/disabled state.
+     * @param item containing a timer.
+     * @return true on success, false otherwise.
+     */
+    bool ToggleTimerState(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Open the timer settings dialog to edit an existing timer.
+     * @param item containing an epg tag or a timer.
+     * @return true on success, false otherwise.
+     */
+    bool EditTimer(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Open the timer settings dialog to edit an existing timer rule.
+     * @param item containing an epg tag or a timer.
+     * @return true on success, false otherwise.
+     */
+    bool EditTimerRule(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Rename a timer, showing a text input dialog.
+     * @param item containing a timer to rename.
+     * @return true, if the timer was renamed successfully, false otherwise.
+     */
+    bool RenameTimer(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Delete a timer, always showing a confirmation dialog.
+     * @param item containing a timer to delete. item must be a timer, an epg tag or a channel.
+     * @return true, if the timer was deleted successfully, false otherwise.
+     */
+    bool DeleteTimer(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Delete a timer rule, always showing a confirmation dialog.
+     * @param item containing a timer rule to delete. item must be a timer, an epg tag or a channel.
+     * @return true, if the timer rule was deleted successfully, false otherwise.
+     */
+    bool DeleteTimerRule(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Open a dialog with information for a given recording.
+     * @param item containing a recording.
+     * @return true on success, false otherwise.
+     */
+    bool ShowRecordingInfo(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Stop a currently active recording, always showing a confirmation dialog.
+     * @param item containing a recording to stop. item must be a timer, an epg tag or a channel.
+     * @return true, if the recording was stopped successfully, false otherwise.
+     */
+    bool StopRecording(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Rename a recording, showing a text input dialog.
+     * @param item containing a recording to rename.
+     * @return true, if the recording was renamed successfully, false otherwise.
+     */
+    bool RenameRecording(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Delete a recording, always showing a confirmation dialog.
+     * @param item containing a recording to delete.
+     * @return true, if the recording was deleted successfully, false otherwise.
+     */
+    bool DeleteRecording(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Delete all recordings from trash, always showing a confirmation dialog.
+     * @return true, if the recordings were permanently deleted successfully, false otherwise.
+     */
+    bool DeleteAllRecordingsFromTrash() const;
+
+    /*!
+     * @brief Undelete a recording.
+     * @param item containing a recording to undelete.
+     * @return true, if the recording was undeleted successfully, false otherwise.
+     */
+    bool UndeleteRecording(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Get a localized resume play label, if the given item can be resumed.
+     * @param item containing a recording or an epg tag.
+     * @return the localized resume play label that can be used for instance as context menu item label or an empty string if resume is not possible.
+     */
+    std::string GetResumeLabel(const CFileItem &item) const;
+
+    /*!
+     * @brief Resume a previously not completely played recording.
+     * @param item containing a recording or an epg tag.
+     * @param bPlayMinimized controls whether the recording should be played fullscreen or in a window.
+     * @param bFallbackToPlay controls whether playback of the recording should be started at the beginning ig no resume data are available.
+     * @return true on success, false otherwise.
+     */
+    bool ResumePlayRecording(const CFileItemPtr &item, bool bPlayMinimized, bool bFallbackToPlay) const;
+
+    /*!
+     * @brief Play recording.
+     * @param item containing a recording or an epg tag.
+     * @param bPlayMinimized controls whether the recording should be played fullscreen or in a window.
+     * @param bCheckResume controls resume check.
+     * @return true on success, false otherwise.
+     */
+    bool PlayRecording(const CFileItemPtr &item, bool bPlayMinimized, bool bCheckResume) const;
+
+    /*!
+     * @brief Mark a recording or a recordings folder as watched.
+     * @param item containing a recording or a recordings folder.
+     * @return true, if the recording or the recordings folder was successfully marked as watched, false otherwise.
+     */
+    bool MarkWatched(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Mark a recording or a recordings folder as unwatched.
+     * @param item containing a recording or a recordings folder.
+     * @return true, if the recording or the recordings folder was successfully marked as unwatched, false otherwise.
+     */
+    bool MarkUnwatched(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Switch channel.
+     * @param item containing a channel or an epg tag.
+     * @param bPlayMinimized controls whether the channel should be played fullscreen or in a window.
+     * @param bCheckResume controls resume check in case a recording for the current epg event is present.
+     * @return true on success, false otherwise.
+     */
+    bool SwitchToChannel(const CFileItemPtr &item, bool bPlayMinimized, bool bCheckResume) const;
+
+    /*!
+     * @brief Hide a channel, always showing a confirmation dialog.
+     * @param item containing a channel or an epg tag.
+     * @return true on success, false otherwise.
+     */
+    bool HideChannel(const CFileItemPtr &item) const;
+
+  private:
+    CPVRGUIActions() = default;
+    CPVRGUIActions(const CPVRGUIActions&) = delete;
+    CPVRGUIActions const& operator=(CPVRGUIActions const&) = delete;
+    virtual ~CPVRGUIActions() {}
+
+    /*!
+     * @brief Open the timer settings dialog.
+     * @param timer containing the timer the settings shall be displayed for.
+     * @return true, if the dialog was ended successfully, false otherwise.
+     */
+    bool ShowTimerSettings(const CPVRTimerInfoTagPtr &timer) const;
+
+    /*!
+     * @brief Add a timer or timer rule, either interactive or non-interactive.
+     * @param item containing epg data to create a timer or timer rule for. item must be an epg tag or a channel.
+     * @param bCreateteRule denotes whether to create a one-shot timer or a timer rule.
+     * @param bShowTimerSettings is used to control whether a settings dialog will be opened prior creating the timer or timer rule.
+     * @return true, if the timer or timer rule was created successfully, false otherwise.
+     */
+    bool AddTimer(const CFileItemPtr &item, bool bCreateRule, bool bShowTimerSettings) const;
+
+    /*!
+     * @brief Delete a timer or timer rule, always showing a confirmation dialog.
+     * @param item containing a timer or timer rule to delete. item must be a timer, an epg tag or a channel.
+     * @param bIsRecording denotes whether the timer is currently recording (controls correct confirmation dialog).
+     * @param bDeleteRule denotes to delete a timer rule. For convenience, one can pass a timer creted by a rule.
+     * @return true, if the timer or timer rule was deleted successfully, false otherwise.
+    */
+    bool DeleteTimer(const CFileItemPtr &item, bool bIsRecording, bool bDeleteRule) const;
+
+    /*!
+     * @brief Open a dialog to confirm timer delete.
+     * @param timer the timer to delete.
+     * @param bDeleteRule in: ignored
+     *                    out, for one shot timer scheduled by a timer rule: true to also delete the timer
+     *                         rule that has scheduled this timer, false to only delete the one shot timer.
+     *                    out, for one shot timer not scheduled by a timer rule: ignored
+     * @return true, to proceed with delete, false otherwise.
+     */
+    bool ConfirmDeleteTimer(const CPVRTimerInfoTagPtr &timer, bool &bDeleteRule) const;
+
+    /*!
+     * @brief Open a dialog to confirm stop recording.
+     * @param timer the recording to stop (actually the timer to delete).
+     * @return true, to proceed with delete, false otherwise.
+     */
+    bool ConfirmStopRecording(const CPVRTimerInfoTagPtr &timer) const;
+
+    /*!
+     * @brief Open a dialog to confirm to delete a recording.
+     * @param item the recording to delete.
+     * @return true, to proceed with delete, false otherwise.
+     */
+    bool ConfirmDeleteRecording(const CFileItemPtr &item) const;
+
+    /*!
+     * @brief Open a dialog to confirm to permaantly remove all deleted recordings.
+     * @return true, to proceed with delete, false otherwise.
+     */
+    bool ConfirmDeleteAllRecordingsFromTrash() const;
+
+    /*!
+     * @brief Check whether resume play is possible for a given item, display "resume from ..."/"play from start" context menu in case.
+     * @param item containing a recording or an epg tag.
+     * @return true, to play/resume the item, false otherwise.
+     */
+    bool CheckResumeRecording(const CFileItemPtr &item) const;
+  };
+
+} // namespace PVR
diff --git a/xbmc/pvr/PVRGUIInfo.h b/xbmc/pvr/PVRGUIInfo.h
index 182c1fe..e881ea2 100644
--- a/xbmc/pvr/PVRGUIInfo.h
+++ b/xbmc/pvr/PVRGUIInfo.h
@@ -20,6 +20,7 @@
  */
 
 #include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "epg/EpgTypes.h"
 #include "pvr/addons/PVRClients.h"
 #include "threads/CriticalSection.h"
 #include "threads/SystemClock.h"
@@ -27,15 +28,9 @@
 #include "utils/Observer.h"
 
 #include <atomic>
-#include <memory>
+#include <string>
 #include <vector>
 
-namespace EPG
-{
-  class CEpgInfoTag;
-  typedef std::shared_ptr<EPG::CEpgInfoTag> CEpgInfoTagPtr;
-}
-
 namespace PVR
 {
   class CPVRTimerInfoTag;
diff --git a/xbmc/pvr/PVRItem.cpp b/xbmc/pvr/PVRItem.cpp
new file mode 100644
index 0000000..b64dfc3
--- /dev/null
+++ b/xbmc/pvr/PVRItem.cpp
@@ -0,0 +1,148 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "FileItem.h"
+#include "epg/EpgInfoTag.h"
+#include "pvr/channels/PVRChannel.h"
+#include "pvr/recordings/PVRRecording.h"
+#include "pvr/timers/PVRTimerInfoTag.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/PVRManager.h"
+#include "utils/log.h"
+
+#include "PVRItem.h"
+
+using namespace EPG;
+
+namespace PVR
+{
+  CEpgInfoTagPtr CPVRItem::GetEpgInfoTag() const
+  {
+    if (m_item->IsEPG())
+    {
+      return m_item->GetEPGInfoTag();
+    }
+    else if (m_item->IsPVRChannel())
+    {
+      return m_item->GetPVRChannelInfoTag()->GetEPGNow();
+    }
+    else if (m_item->IsPVRTimer())
+    {
+      return m_item->GetPVRTimerInfoTag()->GetEpgInfoTag();
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "CPVRItem - %s - unsupported item type!", __FUNCTION__);
+    }
+    return CEpgInfoTagPtr();
+  }
+
+  CPVRChannelPtr CPVRItem::GetChannel() const
+  {
+    if (m_item->IsPVRChannel())
+    {
+      return m_item->GetPVRChannelInfoTag();
+    }
+    else if (m_item->IsEPG())
+    {
+      return m_item->GetEPGInfoTag()->ChannelTag();
+    }
+    else if (m_item->IsPVRTimer())
+    {
+      const CEpgInfoTagPtr epgTag(m_item->GetPVRTimerInfoTag()->GetEpgInfoTag());
+      if (epgTag)
+        return epgTag->ChannelTag();
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "CPVRItem - %s - unsupported item type!", __FUNCTION__);
+    }
+    return CPVRChannelPtr();
+  }
+
+  CPVRTimerInfoTagPtr CPVRItem::GetTimerInfoTag() const
+  {
+    if (m_item->IsPVRTimer())
+    {
+      return m_item->GetPVRTimerInfoTag();
+    }
+    else if (m_item->IsEPG())
+    {
+      return m_item->GetEPGInfoTag()->Timer();
+    }
+    else if (m_item->IsPVRChannel())
+    {
+      CPVRTimerInfoTagPtr timer;
+      const CEpgInfoTagPtr epgTag(m_item->GetPVRChannelInfoTag()->GetEPGNow());
+      if (epgTag)
+        timer = epgTag->Timer(); // cheap method, but not reliable as timers get set at epg tags asychrounously
+
+      if (timer)
+        return timer;
+
+      return g_PVRTimers->GetActiveTimerForChannel(m_item->GetPVRChannelInfoTag()); // more expensive, but reliable and works even for channels with no epg data
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "CPVRItem - %s - unsupported item type!", __FUNCTION__);
+    }
+    return CPVRTimerInfoTagPtr();
+  }
+
+  CPVRRecordingPtr CPVRItem::GetRecording() const
+  {
+    if (m_item->IsPVRRecording())
+    {
+      return m_item->GetPVRRecordingInfoTag();
+    }
+    else if (m_item->IsEPG())
+    {
+      return m_item->GetEPGInfoTag()->Recording();
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "CPVRItem - %s - unsupported item type!", __FUNCTION__);
+    }
+    return CPVRRecordingPtr();
+  }
+
+  bool CPVRItem::IsRadio() const
+  {
+    if (m_item->IsPVRChannel())
+    {
+      return m_item->GetPVRChannelInfoTag()->IsRadio();
+    }
+    else if (m_item->IsEPG())
+    {
+      const CPVRChannelPtr channel(m_item->GetEPGInfoTag()->ChannelTag());
+      return (channel && channel->IsRadio());
+    }
+    else if (m_item->IsPVRRecording())
+    {
+      return m_item->GetPVRRecordingInfoTag()->IsRadio();
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "CPVRItem - %s - unsupported item type!", __FUNCTION__);
+    }
+    return false;
+  }
+
+} // namespace PVR
diff --git a/xbmc/pvr/PVRItem.h b/xbmc/pvr/PVRItem.h
new file mode 100644
index 0000000..3d10e7a
--- /dev/null
+++ b/xbmc/pvr/PVRItem.h
@@ -0,0 +1,45 @@
+#pragma once
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <memory>
+
+class CFileItem;
+typedef std::shared_ptr<CFileItem> CFileItemPtr;
+
+namespace PVR
+{
+  class CPVRItem
+  {
+  public:
+    CPVRItem(const CFileItemPtr &item) : m_item(item) {}
+
+    EPG::CEpgInfoTagPtr GetEpgInfoTag() const;
+    CPVRChannelPtr GetChannel() const;
+    CPVRTimerInfoTagPtr GetTimerInfoTag() const;
+    CPVRRecordingPtr GetRecording() const;
+
+    bool IsRadio() const;
+
+  private:
+    CFileItemPtr m_item;
+  };
+
+} // namespace PVR
diff --git a/xbmc/pvr/PVRManager.cpp b/xbmc/pvr/PVRManager.cpp
index 66ec738..33700ab 100644
--- a/xbmc/pvr/PVRManager.cpp
+++ b/xbmc/pvr/PVRManager.cpp
@@ -869,11 +869,30 @@ bool CPVRManager::IsPlayingChannel(const CPVRChannelPtr &channel) const
   return bReturn;
 }
 
+bool CPVRManager::IsPlayingRecording(const CPVRRecordingPtr &recording) const
+{
+  bool bReturn(false);
+
+  if (recording && IsStarted())
+  {
+    CPVRRecordingPtr current(GetCurrentRecording());
+    if (current && *current == *recording)
+      bReturn = true;
+  }
+
+  return bReturn;
+}
+
 CPVRChannelPtr CPVRManager::GetCurrentChannel(void) const
 {
   return m_addons->GetPlayingChannel();
 }
 
+CPVRRecordingPtr CPVRManager::GetCurrentRecording(void) const
+{
+  return m_addons->GetPlayingRecording();
+}
+
 int CPVRManager::GetCurrentEpg(CFileItemList &results) const
 {
   int iReturn = -1;
@@ -1203,7 +1222,7 @@ bool CPVRManager::CheckParentalPIN(const std::string& strTitle /* = "" */)
   return bValidPIN;
 }
 
-void CPVRManager::SetPlayingGroup(CPVRChannelGroupPtr group)
+void CPVRManager::SetPlayingGroup(const CPVRChannelGroupPtr &group)
 {
   if (m_channelGroups && group)
     m_channelGroups->Get(group->IsRadio())->SetSelectedGroup(group);
diff --git a/xbmc/pvr/PVRManager.h b/xbmc/pvr/PVRManager.h
index 05c30fc..de9b853 100644
--- a/xbmc/pvr/PVRManager.h
+++ b/xbmc/pvr/PVRManager.h
@@ -30,10 +30,12 @@
 #include "utils/Observer.h"
 
 #include "pvr/PVREvent.h"
+#include "pvr/PVRTypes.h"
 #include "pvr/recordings/PVRRecording.h"
 
-#include <map>
+#include <atomic>
 #include <memory>
+#include <string>
 #include <vector>
 
 class CGUIDialogProgressBarHandle;
@@ -114,14 +116,13 @@ namespace PVR
   {
     friend class CPVRClients;
 
-public:
+  public:
     /*!
      * @brief Create a new CPVRManager instance, which handles all PVR related operations in XBMC.
      */
     CPVRManager(void);
 
-private:
-
+  private:
     /*!
      * @brief Updates the last watched timestamps of the channel and group which are currently playing.
      * @param channel The channel which is updated
@@ -253,6 +254,12 @@ private:
     bool IsPlayingChannel(const CPVRChannelPtr &channel) const;
 
     /*!
+     * @brief Check if the given recording is playing.
+     * @return True if it's playing, false otherwise.
+     */
+    bool IsPlayingRecording(const CPVRRecordingPtr &recording) const;
+
+    /*!
      * @return True while the PVRManager is initialising.
      */
     inline bool IsInitialising(void) const
@@ -294,6 +301,12 @@ private:
     CPVRChannelPtr GetCurrentChannel(void) const;
 
     /*!
+     * @brief Return the recording that is currently playing.
+     * @return The recording or NULL if none is playing.
+     */
+    CPVRRecordingPtr GetCurrentRecording(void) const;
+
+    /*!
      * @brief Update the channel displayed in guiinfomanager and application to match the currently playing channel.
      */
     void UpdateCurrentChannel(void);
@@ -393,7 +406,7 @@ private:
      * @brief Set the current playing group, used to load the right channel.
      * @param group The new group.
      */
-    void SetPlayingGroup(CPVRChannelGroupPtr group);
+    void SetPlayingGroup(const CPVRChannelGroupPtr &group);
 
     /*!
      * @brief Get the current playing group, used to load the right channel.
diff --git a/xbmc/pvr/PVRTypes.h b/xbmc/pvr/PVRTypes.h
new file mode 100644
index 0000000..39c7012
--- /dev/null
+++ b/xbmc/pvr/PVRTypes.h
@@ -0,0 +1,45 @@
+#pragma once
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <memory>
+
+namespace PVR
+{
+  class CPVRChannel;
+  typedef std::shared_ptr<CPVRChannel> CPVRChannelPtr;
+
+  class CPVRChannelGroup;
+  typedef std::shared_ptr<CPVRChannelGroup> CPVRChannelGroupPtr;
+
+  class CPVRRadioRDSInfoTag;
+  typedef std::shared_ptr<CPVRRadioRDSInfoTag> CPVRRadioRDSInfoTagPtr;
+
+  class CPVRRecording;
+  typedef std::shared_ptr<CPVRRecording> CPVRRecordingPtr;
+
+  class CPVRTimerInfoTag;
+  typedef std::shared_ptr<CPVRTimerInfoTag> CPVRTimerInfoTagPtr;
+
+  class CPVRTimerType;
+  typedef std::shared_ptr<CPVRTimerType> CPVRTimerTypePtr;
+
+} // namespace PVR
+
diff --git a/xbmc/pvr/addons/PVRClients.cpp b/xbmc/pvr/addons/PVRClients.cpp
index a524f10..85b7ed4 100644
--- a/xbmc/pvr/addons/PVRClients.cpp
+++ b/xbmc/pvr/addons/PVRClients.cpp
@@ -26,7 +26,6 @@
 
 #include "Application.h"
 #include "cores/IPlayer.h"
-#include "dialogs/GUIDialogExtendedProgressBar.h"
 #include "dialogs/GUIDialogOK.h"
 #include "dialogs/GUIDialogSelect.h"
 #include "dialogs/GUIDialogKaiToast.h"
@@ -81,7 +80,7 @@ bool CPVRClients::IsCreatedClient(int iClientId) const
   return GetCreatedClient(iClientId, client);
 }
 
-bool CPVRClients::IsCreatedClient(const AddonPtr addon)
+bool CPVRClients::IsCreatedClient(const AddonPtr &addon)
 {
   CSingleLock lock(m_critSection);
 
@@ -91,7 +90,7 @@ bool CPVRClients::IsCreatedClient(const AddonPtr addon)
   return false;
 }
 
-int CPVRClients::GetClientId(const AddonPtr client) const
+int CPVRClients::GetClientId(const AddonPtr &client) const
 {
   CSingleLock lock(m_critSection);
 
@@ -196,7 +195,7 @@ bool CPVRClients::HasEnabledClients(void) const
   return false;
 }
 
-bool CPVRClients::StopClient(AddonPtr client, bool bRestart)
+bool CPVRClients::StopClient(const AddonPtr &client, bool bRestart)
 {
   /* stop playback */
   CApplicationMessenger::GetInstance().SendMsg(TMSG_MEDIA_STOP);
@@ -641,52 +640,18 @@ PVR_ERROR CPVRClients::DeleteAllRecordingsFromTrash()
   PVR_CLIENTMAP clients;
   GetCreatedClients(clients);
 
-  std::vector<PVR_CLIENT> suppClients;
-  for (const auto client : clients)
+  for (const auto &client : clients)
   {
     if (client.second->SupportsRecordingsUndelete() && client.second->GetRecordingsAmount(true) > 0)
-      suppClients.push_back(client.second);
-  }
-
-  int selection = 0;
-  if (suppClients.size() > 1)
-  {
-    // have user select client
-    CGUIDialogSelect* pDialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
-    pDialog->Reset();
-    pDialog->SetHeading(CVariant{19292});       //Delete all permanently
-    pDialog->Add(g_localizeStrings.Get(24032)); // All Add-ons
-
-    for (const auto client : clients)
     {
-      if (client.second->SupportsRecordingsUndelete() && client.second->GetRecordingsAmount(true) > 0)
-        pDialog->Add(client.second->GetBackendName());
-    }
-    pDialog->Open();
-    selection = pDialog->GetSelectedItem();
-  }
-
-  if (selection == 0)
-  {
-    for (const auto &client : suppClients)
-    {
-      PVR_ERROR currentError = client->DeleteAllRecordingsFromTrash();
+      PVR_ERROR currentError = client.second->DeleteAllRecordingsFromTrash();
       if (currentError != PVR_ERROR_NO_ERROR)
       {
-        CLog::Log(LOGERROR, "PVR - %s - cannot delete all recordings from client '%d': %s",__FUNCTION__, client->GetID(), CPVRClient::ToString(currentError));
+        CLog::Log(LOGERROR, "PVR - %s - cannot delete all recordings from client '%d': %s",__FUNCTION__, client.second->GetID(), CPVRClient::ToString(currentError));
         error = currentError;
       }
     }
   }
-  else if (selection >= 1 && selection <= (int)suppClients.size())
-  {
-    PVR_ERROR currentError = suppClients[selection-1]->DeleteAllRecordingsFromTrash();
-    if (currentError != PVR_ERROR_NO_ERROR)
-    {
-      CLog::Log(LOGERROR, "PVR - %s - cannot delete all recordings from client '%d': %s",__FUNCTION__, suppClients[selection-1]->GetID(), CPVRClient::ToString(currentError));
-      error = currentError;
-    }
-  }
 
   return error;
 }
@@ -1106,7 +1071,7 @@ bool CPVRClients::RenameChannel(const CPVRChannelPtr &channel)
   return (error == PVR_ERROR_NO_ERROR || error == PVR_ERROR_NOT_IMPLEMENTED);
 }
 
-bool CPVRClients::IsKnownClient(const AddonPtr client) const
+bool CPVRClients::IsKnownClient(const AddonPtr &client) const
 {
   // database IDs start at 1
   return GetClientId(client) > 0;
diff --git a/xbmc/pvr/addons/PVRClients.h b/xbmc/pvr/addons/PVRClients.h
index dd84d80..f272079 100644
--- a/xbmc/pvr/addons/PVRClients.h
+++ b/xbmc/pvr/addons/PVRClients.h
@@ -85,7 +85,7 @@ namespace PVR
      */
     bool IsCreatedClient(int iClientId) const;
 
-    bool IsCreatedClient(const ADDON::AddonPtr addon);
+    bool IsCreatedClient(const ADDON::AddonPtr &addon);
 
     /*!
      * @brief Restart a single client add-on.
@@ -128,7 +128,7 @@ namespace PVR
      * @param bRestart If true, restart the client.
      * @return True if the client was found, false otherwise.
      */
-    bool StopClient(ADDON::AddonPtr client, bool bRestart);
+    bool StopClient(const ADDON::AddonPtr &client, bool bRestart);
 
     /*!
      * @return The amount of connected clients.
@@ -704,10 +704,10 @@ namespace PVR
      * @param client The client to check.
      * @return True if this client is registered, false otherwise.
      */
-    bool IsKnownClient(const ADDON::AddonPtr client) const;
+    bool IsKnownClient(const ADDON::AddonPtr &client) const;
 
 
-    int GetClientId(const ADDON::AddonPtr client) const;
+    int GetClientId(const ADDON::AddonPtr &client) const;
 
 
     bool                  m_bChannelScanRunning;      /*!< true when a channel scan is currently running, false otherwise */
diff --git a/xbmc/pvr/channels/PVRChannel.h b/xbmc/pvr/channels/PVRChannel.h
index 54e5a7f..bc6081d 100644
--- a/xbmc/pvr/channels/PVRChannel.h
+++ b/xbmc/pvr/channels/PVRChannel.h
@@ -20,38 +20,25 @@
  */
 
 #include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "epg/EpgTypes.h"
 #include "threads/CriticalSection.h"
 #include "utils/ISerializable.h"
 #include "utils/ISortable.h"
 #include "utils/Observer.h"
 
-#include <memory>
+#include "pvr/PVRTypes.h"
+
 #include <string>
 #include <utility>
 
 class CVariant;
 class CFileItemList;
 
-namespace EPG
-{
-  class CEpg;
-  typedef std::shared_ptr<CEpg> CEpgPtr;
-  class CEpgInfoTag;
-  typedef std::shared_ptr<CEpgInfoTag> CEpgInfoTagPtr;
-
-}
-
 namespace PVR
 {
   class CPVRDatabase;
   class CPVRChannelGroupInternal;
 
-  class CPVRRecording;
-  typedef std::shared_ptr<CPVRRecording> CPVRRecordingPtr;
-
-  class CPVRChannel;
-  typedef std::shared_ptr<PVR::CPVRChannel> CPVRChannelPtr;
-
   typedef struct
   {
     unsigned int channel;
diff --git a/xbmc/pvr/channels/PVRChannelGroup.h b/xbmc/pvr/channels/PVRChannelGroup.h
index dd2ede5..5fd56c7 100644
--- a/xbmc/pvr/channels/PVRChannelGroup.h
+++ b/xbmc/pvr/channels/PVRChannelGroup.h
@@ -19,10 +19,12 @@
  *
  */
 
-#include "PVRChannel.h"
 #include "settings/lib/ISettingCallback.h"
 #include "utils/Job.h"
 
+#include "pvr/PVRTypes.h"
+#include "pvr/channels/PVRChannel.h"
+
 #include <memory>
 #include <utility>
 #include <vector>
@@ -31,11 +33,6 @@ class CDateTime;
 class CFileItem;
 typedef std::shared_ptr<CFileItem> CFileItemPtr;
 
-namespace EPG
-{
-  struct EpgSearchFilter;
-}
-
 namespace PVR
 {
 #define PVR_GROUP_TYPE_DEFAULT      0
@@ -62,9 +59,6 @@ namespace PVR
     EPG_LAST_DATE = 1
   };
 
-  class CPVRChannelGroup;
-  typedef std::shared_ptr<PVR::CPVRChannelGroup> CPVRChannelGroupPtr;
-
   /** A group of channels */
   class CPVRChannelGroup : public Observable,
                            public IJobCallback,
@@ -537,7 +531,7 @@ namespace PVR
   class CPVRPersistGroupJob : public CJob
   {
   public:
-    CPVRPersistGroupJob(CPVRChannelGroupPtr group): m_group(group) {}
+    CPVRPersistGroupJob(const CPVRChannelGroupPtr &group): m_group(group) {}
     virtual ~CPVRPersistGroupJob() {}
     const char *GetType() const { return "pvr-channelgroup-persist"; }
 
diff --git a/xbmc/pvr/channels/PVRChannelGroupInternal.cpp b/xbmc/pvr/channels/PVRChannelGroupInternal.cpp
index 074a6f5..ff26139 100644
--- a/xbmc/pvr/channels/PVRChannelGroupInternal.cpp
+++ b/xbmc/pvr/channels/PVRChannelGroupInternal.cpp
@@ -309,7 +309,7 @@ bool CPVRChannelGroupInternal::UpdateGroupEntries(const CPVRChannelGroup &channe
   return bReturn;
 }
 
-void CPVRChannelGroupInternal::CreateChannelEpg(CPVRChannelPtr channel, bool bForce /* = false */)
+void CPVRChannelGroupInternal::CreateChannelEpg(const CPVRChannelPtr &channel, bool bForce /* = false */)
 {
   if (!channel)
     return;
diff --git a/xbmc/pvr/channels/PVRChannelGroupInternal.h b/xbmc/pvr/channels/PVRChannelGroupInternal.h
index 9e71c35..83c0922 100644
--- a/xbmc/pvr/channels/PVRChannelGroupInternal.h
+++ b/xbmc/pvr/channels/PVRChannelGroupInternal.h
@@ -149,7 +149,7 @@ namespace PVR
      */
     void UpdateChannelPaths(void);
 
-    void CreateChannelEpg(CPVRChannelPtr channel, bool bForce = false);
+    void CreateChannelEpg(const CPVRChannelPtr &channel, bool bForce = false);
 
     size_t m_iHiddenChannels; /*!< the amount of hidden channels in this container */
 
diff --git a/xbmc/pvr/channels/PVRChannelGroups.cpp b/xbmc/pvr/channels/PVRChannelGroups.cpp
index 391b084..b9b4a8b 100644
--- a/xbmc/pvr/channels/PVRChannelGroups.cpp
+++ b/xbmc/pvr/channels/PVRChannelGroups.cpp
@@ -173,7 +173,7 @@ CPVRChannelGroupPtr CPVRChannelGroups::GetById(int iGroupId) const
   return empty;
 }
 
-std::vector<CPVRChannelGroupPtr> CPVRChannelGroups::GetGroupsByChannel(const CPVRChannelPtr channel, bool bExcludeHidden /* = false */) const
+std::vector<CPVRChannelGroupPtr> CPVRChannelGroups::GetGroupsByChannel(const CPVRChannelPtr &channel, bool bExcludeHidden /* = false */) const
 {
   std::vector<CPVRChannelGroupPtr> groups;
   for (CPVRChannelGroupPtr group : m_groups)
@@ -468,7 +468,7 @@ CPVRChannelGroupPtr CPVRChannelGroups::GetSelectedGroup(void) const
   return m_selectedGroup;
 }
 
-void CPVRChannelGroups::SetSelectedGroup(CPVRChannelGroupPtr group)
+void CPVRChannelGroups::SetSelectedGroup(const CPVRChannelGroupPtr &group)
 {
   // update the selected group
   {
diff --git a/xbmc/pvr/channels/PVRChannelGroups.h b/xbmc/pvr/channels/PVRChannelGroups.h
index ca9567c..367bb31 100644
--- a/xbmc/pvr/channels/PVRChannelGroups.h
+++ b/xbmc/pvr/channels/PVRChannelGroups.h
@@ -95,7 +95,7 @@ namespace PVR
      * @param bExcludeHidden Whenever to exclude hidden channel groups.
      * @return A list of groups the channel is a member.
      */
-    std::vector<CPVRChannelGroupPtr> GetGroupsByChannel(const CPVRChannelPtr channel, bool bExcludeHidden = false) const;
+    std::vector<CPVRChannelGroupPtr> GetGroupsByChannel(const CPVRChannelPtr &channel, bool bExcludeHidden = false) const;
 
     /*!
      * @brief Get a group given it's name.
@@ -167,7 +167,7 @@ namespace PVR
      * @brief Change the selected group.
      * @param group The group to select.
      */
-    void SetSelectedGroup(CPVRChannelGroupPtr group);
+    void SetSelectedGroup(const CPVRChannelGroupPtr &group);
 
     /*!
      * @brief Add a group to this container.
diff --git a/xbmc/pvr/channels/PVRChannelGroupsContainer.cpp b/xbmc/pvr/channels/PVRChannelGroupsContainer.cpp
index 7e085a5..d216242 100644
--- a/xbmc/pvr/channels/PVRChannelGroupsContainer.cpp
+++ b/xbmc/pvr/channels/PVRChannelGroupsContainer.cpp
@@ -334,7 +334,7 @@ CPVRChannelGroupPtr CPVRChannelGroupsContainer::GetPreviousPlayedGroup(void)
   return m_lastPlayedGroups[0];
 }
 
-void CPVRChannelGroupsContainer::SetLastPlayedGroup(CPVRChannelGroupPtr group)
+void CPVRChannelGroupsContainer::SetLastPlayedGroup(const CPVRChannelGroupPtr &group)
 {
   CSingleLock lock(m_critSection);
   m_lastPlayedGroups[0] = m_lastPlayedGroups[1];
diff --git a/xbmc/pvr/channels/PVRChannelGroupsContainer.h b/xbmc/pvr/channels/PVRChannelGroupsContainer.h
index 6a95b85..25a8c6f 100644
--- a/xbmc/pvr/channels/PVRChannelGroupsContainer.h
+++ b/xbmc/pvr/channels/PVRChannelGroupsContainer.h
@@ -197,7 +197,7 @@ namespace PVR
      * @brief Set the last played group.
      * @param The last played group
      */
-    void SetLastPlayedGroup(CPVRChannelGroupPtr group);
+    void SetLastPlayedGroup(const CPVRChannelGroupPtr &group);
 
   protected:
     /*!
diff --git a/xbmc/pvr/channels/PVRRadioRDSInfoTag.h b/xbmc/pvr/channels/PVRRadioRDSInfoTag.h
index 17bffda..702699b 100644
--- a/xbmc/pvr/channels/PVRRadioRDSInfoTag.h
+++ b/xbmc/pvr/channels/PVRRadioRDSInfoTag.h
@@ -23,14 +23,13 @@
 #include "utils/ISerializable.h"
 #include "XBDateTime.h"
 
-#include <memory>
+#include "pvr/PVRTypes.h"
+
 #include <deque>
 #include <string>
 
 namespace PVR
 {
-  class CPVRRadioRDSInfoTag;
-  typedef std::shared_ptr<CPVRRadioRDSInfoTag> CPVRRadioRDSInfoTagPtr;
 
 class CPVRRadioRDSInfoTag : public IArchivable, public ISerializable
 {
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp b/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
index eb69c41..e8ccb42 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
+++ b/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
@@ -720,7 +720,7 @@ void CGUIDialogPVRChannelManager::Clear(void)
   m_channelItems->Clear();
 }
 
-void CGUIDialogPVRChannelManager::RenameChannel(CFileItemPtr pItem)
+void CGUIDialogPVRChannelManager::RenameChannel(const CFileItemPtr &pItem)
 {
   std::string strChannelName = pItem->GetProperty("Name").asString();
   if (strChannelName != pItem->GetPVRChannelInfoTag()->ChannelName())
@@ -733,7 +733,7 @@ void CGUIDialogPVRChannelManager::RenameChannel(CFileItemPtr pItem)
   }
 }
 
-bool CGUIDialogPVRChannelManager::PersistChannel(CFileItemPtr pItem, CPVRChannelGroupPtr group, unsigned int *iChannelNumber)
+bool CGUIDialogPVRChannelManager::PersistChannel(const CFileItemPtr &pItem, const CPVRChannelGroupPtr &group, unsigned int *iChannelNumber)
 {
   if (!pItem || !pItem->HasPVRChannelInfoTag() || !group)
     return false;
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.h b/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.h
index c84246f..129362b 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.h
+++ b/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.h
@@ -67,7 +67,7 @@ namespace PVR
     virtual bool OnClickButtonGroupManager(CGUIMessage &message);
     virtual bool OnClickButtonNewChannel();
 
-    virtual bool PersistChannel(CFileItemPtr pItem, CPVRChannelGroupPtr group, unsigned int *iChannelNumber);
+    virtual bool PersistChannel(const CFileItemPtr &pItem, const CPVRChannelGroupPtr &group, unsigned int *iChannelNumber);
     virtual void SetItemsUnchanged(void);
 
   private:
@@ -76,7 +76,7 @@ namespace PVR
     void SaveList(void);
     void Renumber(void);
     void SetData(int iItem);
-    void RenameChannel(CFileItemPtr pItem);
+    void RenameChannel(const CFileItemPtr &pItem);
     bool m_bIsRadio;
     bool m_bMovingMode;
     bool m_bContainsChanges;
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp b/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
index 1beb856..46677fb 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
+++ b/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
@@ -18,25 +18,20 @@
  *
  */
 
-#include "Application.h"
 #include "FileItem.h"
 #include "GUIInfoManager.h"
-#include "dialogs/GUIDialogKaiToast.h"
 #include "epg/EpgContainer.h"
-#include "guilib/LocalizeStrings.h"
 #include "guilib/GUIWindowManager.h"
 #include "input/Key.h"
 #include "messaging/ApplicationMessenger.h"
-#include "settings/Settings.h"
-#include "utils/StringUtils.h"
 #include "view/ViewState.h"
 
+#include "pvr/PVRGUIActions.h"
 #include "pvr/PVRManager.h"
 #include "pvr/channels/PVRChannelGroupsContainer.h"
 #include "pvr/windows/GUIWindowPVRBase.h"
 
 #include "GUIDialogPVRChannelsOSD.h"
-#include "GUIDialogPVRGuideInfo.h"
 
 using namespace PVR;
 using namespace EPG;
@@ -254,79 +249,22 @@ void CGUIDialogPVRChannelsOSD::Clear()
   m_vecItems->Clear();
 }
 
-void CGUIDialogPVRChannelsOSD::CloseOrSelect(unsigned int iItem)
-{
-  if (CSettings::GetInstance().GetBool(CSettings::SETTING_PVRMENU_CLOSECHANNELOSDONSWITCH))
-  {
-    if (CSettings::GetInstance().GetInt(CSettings::SETTING_PVRMENU_DISPLAYCHANNELINFO) > 0)
-      g_PVRManager.ShowPlayerInfo(CSettings::GetInstance().GetInt(CSettings::SETTING_PVRMENU_DISPLAYCHANNELINFO));
-    Close();
-  }
-  else
-    m_viewControl.SetSelectedItem(iItem);
-}
-
 void CGUIDialogPVRChannelsOSD::GotoChannel(int item)
 {
-  /* Check file item is in list range and get his pointer */
-  if (item < 0 || item >= (int)m_vecItems->Size()) return;
-  CFileItemPtr pItem = m_vecItems->Get(item);
-
-  if (pItem->GetPath() == g_application.CurrentFile())
-  {
-    CloseOrSelect(item);
+  if (item < 0 || item >= (int)m_vecItems->Size())
     return;
-  }
-
-  if (g_PVRManager.IsPlaying() && pItem->HasPVRChannelInfoTag() && g_application.m_pPlayer->HasPlayer())
-  {
-    CPVRChannelPtr channel = pItem->GetPVRChannelInfoTag();
-    if (!g_PVRManager.CheckParentalLock(channel) ||
-        !g_application.m_pPlayer->SwitchChannel(channel))
-    {
-      std::string msg = StringUtils::Format(g_localizeStrings.Get(19035).c_str(), channel->ChannelName().c_str()); // CHANNELNAME could not be played. Check the log for details.
-      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error,
-              g_localizeStrings.Get(19166), // PVR information
-              msg);
-      return;
-    }
-  }
-  else
-    CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PLAY, 0, 0, static_cast<void*>(new CFileItem(*pItem)));
 
+  Close();
+  CPVRGUIActions::GetInstance().SwitchToChannel(m_vecItems->Get(item), false /* bPlayMinimized */, true /* bCheckResume */);
   m_group = GetPlayingGroup();
-
-  CloseOrSelect(item);
 }
 
 void CGUIDialogPVRChannelsOSD::ShowInfo(int item)
 {
-  /* Check file item is in list range and get his pointer */
-  if (item < 0 || item >= (int)m_vecItems->Size()) return;
-
-  CFileItemPtr pItem = m_vecItems->Get(item);
-  if (pItem && pItem->IsPVRChannel())
-  {
-    CPVRChannelPtr channel(pItem->GetPVRChannelInfoTag());
-    if (!g_PVRManager.CheckParentalLock(channel))
-      return;
-
-    /* Get the current running show on this channel from the EPG storage */
-    CEpgInfoTagPtr epgnow(channel->GetEPGNow());
-    if (!epgnow)
-      return;
-
-    /* Load programme info dialog */
-    CGUIDialogPVRGuideInfo* pDlgInfo = (CGUIDialogPVRGuideInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GUIDE_INFO);
-    if (!pDlgInfo)
-      return;
-
-    /* inform dialog about the file item and open dialog window */
-    pDlgInfo->SetProgInfo(epgnow);
-    pDlgInfo->Open();
-  }
+  if (item < 0 || item >= (int)m_vecItems->Size())
+    return;
 
-  return;
+  CPVRGUIActions::GetInstance().ShowEPGInfo(m_vecItems->Get(item));
 }
 
 void CGUIDialogPVRChannelsOSD::OnWindowLoaded()
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.h b/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.h
index 8f4af93..02c5206 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.h
+++ b/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.h
@@ -49,7 +49,6 @@ namespace PVR
     virtual void SaveControlStates();
     virtual void SetInvalid();
 
-    void CloseOrSelect(unsigned int iItem);
     void GotoChannel(int iItem);
     void ShowInfo(int item);
     void Clear();
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp b/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
index 14e9d54..443eac7 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
+++ b/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
@@ -28,11 +28,12 @@
 #include "utils/StringUtils.h"
 #include "utils/Variant.h"
 
+#include "pvr/PVRGUIActions.h"
 #include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClients.h"
 #include "pvr/channels/PVRChannelGroupsContainer.h"
 #include "pvr/timers/PVRTimerInfoTag.h"
-#include "pvr/windows/GUIWindowPVRBase.h"
+#include "pvr/windows/GUIWindowPVRSearch.h"
 
 #include "GUIDialogPVRGuideInfo.h"
 
@@ -58,47 +59,6 @@ CGUIDialogPVRGuideInfo::~CGUIDialogPVRGuideInfo(void)
 {
 }
 
-bool CGUIDialogPVRGuideInfo::ActionStartTimer(const CEpgInfoTagPtr &tag)
-{
-  bool bReturn = false;
-
-  CFileItemPtr item(new CFileItem(tag));
-  bReturn = CGUIWindowPVRBase::AddTimer(item.get());
-
-  if (bReturn)
-    Close();
-
-  return bReturn;
-}
-
-bool CGUIDialogPVRGuideInfo::ActionCancelTimer(const CFileItemPtr &timer)
-{
-  bool bReturn = false;
-
-  if (timer->GetPVRTimerInfoTag()->IsRecording())
-    bReturn = CGUIWindowPVRBase::StopRecordFile(timer.get());
-  else
-    bReturn = CGUIWindowPVRBase::DeleteTimer(timer.get());
-
-  if (bReturn)
-    Close();
-
-  return bReturn;
-}
-
-bool CGUIDialogPVRGuideInfo::ActionAddTimerRule(const CEpgInfoTagPtr &tag)
-{
-  bool bReturn = false;
-
-  const CFileItemPtr item(new CFileItem(tag));
-  bReturn = CGUIWindowPVRBase::AddTimerRule(item.get(), true);
-
-  if (bReturn)
-    Close();
-
-  return bReturn;
-}
-
 bool CGUIDialogPVRGuideInfo::OnClickButtonOK(CGUIMessage &message)
 {
   bool bReturn = false;
@@ -128,13 +88,25 @@ bool CGUIDialogPVRGuideInfo::OnClickButtonRecord(CGUIMessage &message)
       return bReturn;
     }
 
-    CPVRTimerInfoTagPtr timerTag = m_progItem->Timer();
+    const CPVRTimerInfoTagPtr timerTag(m_progItem->Timer());
     if (timerTag)
-      ActionCancelTimer(CFileItemPtr(new CFileItem(timerTag)));
+    {
+      const CFileItemPtr item(new CFileItem(timerTag));
+      if (timerTag->IsRecording())
+        bReturn = CPVRGUIActions::GetInstance().StopRecording(item);
+      else
+        bReturn = CPVRGUIActions::GetInstance().DeleteTimer(item);
+    }
     else
-      ActionStartTimer(m_progItem);
+    {
+      const CFileItemPtr item(new CFileItem(m_progItem));
+      bReturn = CPVRGUIActions::GetInstance().AddTimer(item, false);
+    }
   }
 
+  if (bReturn)
+    Close();
+
   return bReturn;
 }
 
@@ -145,11 +117,15 @@ bool CGUIDialogPVRGuideInfo::OnClickButtonAddTimer(CGUIMessage &message)
   if (message.GetSenderId() == CONTROL_BTN_ADD_TIMER)
   {
     if (m_progItem && !m_progItem->Timer())
-      ActionAddTimerRule(m_progItem);
-
-    bReturn = true;
+    {
+      const CFileItemPtr item(new CFileItem(m_progItem));
+      bReturn = CPVRGUIActions::GetInstance().AddTimerRule(item, true);
+    }
   }
 
+  if (bReturn)
+    Close();
+
   return bReturn;
 }
 
@@ -161,28 +137,12 @@ bool CGUIDialogPVRGuideInfo::OnClickButtonPlay(CGUIMessage &message)
   {
     Close();
 
-    if (m_progItem)
-    {
-      if (message.GetSenderId() == CONTROL_BTN_PLAY_RECORDING && m_progItem->HasRecording())
-        g_application.PlayFile(CFileItem(m_progItem->Recording()), "videoplayer");
-      else if (m_progItem->HasPVRChannel())
-      {
-        CPVRChannelPtr channel = m_progItem->ChannelTag();
-        // try a fast switch
-        bool bSwitchSuccessful = false;
-        if ((g_PVRManager.IsPlayingTV() || g_PVRManager.IsPlayingRadio()) &&
-            (channel->IsRadio() == g_PVRManager.IsPlayingRadio()))
-        {
-          if (channel->StreamURL().empty())
-            bSwitchSuccessful = g_application.m_pPlayer->SwitchChannel(channel);
-        }
-
-        if (!bSwitchSuccessful)
-        {
-          CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PLAY, 0, 0, static_cast<void*>(new CFileItem(channel)), "videoplayer");
-        }
-      }
-    }
+    const CFileItemPtr item(new CFileItem(m_progItem));
+    if (message.GetSenderId() == CONTROL_BTN_PLAY_RECORDING)
+      CPVRGUIActions::GetInstance().PlayRecording(item, false /* bPlayMinimized */, true /* bCheckResume */);
+    else
+      CPVRGUIActions::GetInstance().SwitchToChannel(item, false /* bPlayMinimized */, true /* bCheckResume */);
+
     bReturn = true;
   }
 
@@ -194,19 +154,7 @@ bool CGUIDialogPVRGuideInfo::OnClickButtonFind(CGUIMessage &message)
   bool bReturn = false;
 
   if (message.GetSenderId() == CONTROL_BTN_FIND)
-  {
-    if (m_progItem && m_progItem->HasPVRChannel())
-    {
-      int windowSearchId = m_progItem->ChannelTag()->IsRadio() ? WINDOW_RADIO_SEARCH : WINDOW_TV_SEARCH;
-      CGUIWindowPVRBase *windowSearch = (CGUIWindowPVRBase*) g_windowManager.GetWindow(windowSearchId);
-      if (windowSearch)
-      {
-        Close();
-        g_windowManager.ActivateWindow(windowSearchId);
-        bReturn = windowSearch->OnContextButton(CFileItem(m_progItem), CONTEXT_BUTTON_FIND);
-      }
-    }
-  }
+    return CPVRGUIActions::GetInstance().FindSimilar(CFileItemPtr(new CFileItem(m_progItem)), this);
 
   return bReturn;
 }
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.h b/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.h
index f595b2b..200ad2f 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.h
+++ b/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.h
@@ -19,19 +19,11 @@
  *
  */
 
+#include "epg/EpgTypes.h"
 #include "guilib/GUIDialog.h"
-#include <memory>
-
-namespace EPG
-{
-  class CEpgInfoTag;
-  typedef std::shared_ptr<EPG::CEpgInfoTag> CEpgInfoTagPtr;
-}
 
 namespace PVR
 {
-  class CPVRTimerInfoTag;
-
   class CGUIDialogPVRGuideInfo : public CGUIDialog
   {
   public:
@@ -47,10 +39,6 @@ namespace PVR
   protected:
     virtual void OnInitWindow() override;
 
-    bool ActionStartTimer(const EPG::CEpgInfoTagPtr &tag);
-    bool ActionCancelTimer(const CFileItemPtr &timer);
-    bool ActionAddTimerRule(const EPG::CEpgInfoTagPtr &tag);
-
     bool OnClickButtonOK(CGUIMessage &message);
     bool OnClickButtonRecord(CGUIMessage &message);
     bool OnClickButtonPlay(CGUIMessage &message);
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp b/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
index 8b47243..99a7517 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
+++ b/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
@@ -24,9 +24,9 @@
 #include "input/Key.h"
 #include "view/ViewState.h"
 
+#include "pvr/PVRGUIActions.h"
 #include "pvr/PVRManager.h"
 
-#include "GUIDialogPVRGuideInfo.h"
 #include "GUIDialogPVRGuideOSD.h"
 
 using namespace PVR;
@@ -122,19 +122,10 @@ void CGUIDialogPVRGuideOSD::Clear()
 
 void CGUIDialogPVRGuideOSD::ShowInfo(int item)
 {
-  /* Check file item is in list range and get his pointer */
-  if (item < 0 || item >= (int)m_vecItems->Size()) return;
-
-  CFileItemPtr pItem = m_vecItems->Get(item);
-
-  /* Load programme info dialog */
-  CGUIDialogPVRGuideInfo* pDlgInfo = (CGUIDialogPVRGuideInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GUIDE_INFO);
-  if (!pDlgInfo)
+  if (item < 0 || item >= (int)m_vecItems->Size())
     return;
 
-  /* inform dialog about the file item and open dialog window */
-  pDlgInfo->SetProgInfo(pItem->GetEPGInfoTag());
-  pDlgInfo->Open();
+  CPVRGUIActions::GetInstance().ShowEPGInfo(m_vecItems->Get(item));
 }
 
 void CGUIDialogPVRGuideOSD::OnWindowLoaded()
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp b/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp
index dd7d612..4f8063a 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp
+++ b/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp
@@ -19,8 +19,7 @@
  */
 
 #include "FileItem.h"
-#include "guilib/GUIWindowManager.h"
-#include "pvr/windows/GUIWindowPVRBase.h"
+#include "pvr/PVRGUIActions.h"
 
 #include "GUIDialogPVRRecordingInfo.h"
 
@@ -68,7 +67,7 @@ bool CGUIDialogPVRRecordingInfo::OnClickButtonPlay(CGUIMessage &message)
     Close();
 
     if (m_recordItem)
-      CGUIWindowPVRBase::PlayRecording(m_recordItem.get(), false /* don't play minimized */, true /* check resume */);
+      CPVRGUIActions::GetInstance().PlayRecording(m_recordItem, false /* don't play minimized */, true /* check resume */);
 
     bReturn = true;
   }
@@ -94,14 +93,6 @@ CFileItemPtr CGUIDialogPVRRecordingInfo::GetCurrentListItem(int offset)
 
 void CGUIDialogPVRRecordingInfo::ShowFor(const CFileItemPtr& item)
 {
-  if (item && item->IsPVRRecording())
-  {
-    CGUIDialogPVRRecordingInfo* pDlgInfo = dynamic_cast<CGUIDialogPVRRecordingInfo*>(g_windowManager.GetWindow(WINDOW_DIALOG_PVR_RECORDING_INFO));
-    if (pDlgInfo)
-    {
-      pDlgInfo->SetRecording(item.get());
-      pDlgInfo->Open();
-    }
-  }
+  CPVRGUIActions::GetInstance().ShowRecordingInfo(item);
 }
 
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h b/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h
index 7e7dc7d..5a2cb95 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h
+++ b/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h
@@ -24,8 +24,9 @@
 #include "settings/SettingConditions.h"
 #include "settings/lib/SettingDependency.h"
 
+#include "pvr/PVRTypes.h"
+
 #include <map>
-#include <memory>
 #include <utility>
 #include <vector>
 #include <string>
@@ -35,12 +36,6 @@ class CSetting;
 
 namespace PVR
 {
-  class CPVRTimerInfoTag;
-  typedef std::shared_ptr<CPVRTimerInfoTag> CPVRTimerInfoTagPtr;
-
-  class CPVRTimerType;
-  typedef std::shared_ptr<CPVRTimerType> CPVRTimerTypePtr;
-
   class CGUIDialogPVRTimerSettings : public CGUIDialogSettingsManualBase
   {
   public:
diff --git a/xbmc/pvr/recordings/PVRRecording.h b/xbmc/pvr/recordings/PVRRecording.h
index b6950ee..035fc77 100644
--- a/xbmc/pvr/recordings/PVRRecording.h
+++ b/xbmc/pvr/recordings/PVRRecording.h
@@ -35,25 +35,20 @@
  *
  */
 
-#include <string>
-#include <memory>
-#include <vector>
-
 #include "XBDateTime.h"
 #include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
 #include "video/VideoInfoTag.h"
 
+#include "pvr/PVRTypes.h"
+
+#include <string>
+#include <vector>
+
 class CVideoDatabase;
 class CVariant;
 
 namespace PVR
 {
-  class CPVRRecording;
-  typedef std::shared_ptr<PVR::CPVRRecording> CPVRRecordingPtr;
-
-  class CPVRChannel;
-  typedef std::shared_ptr<PVR::CPVRChannel> CPVRChannelPtr;
-
   /*!
    * @brief Representation of a CPVRRecording unique ID.
    */
diff --git a/xbmc/pvr/recordings/PVRRecordings.h b/xbmc/pvr/recordings/PVRRecordings.h
index b1feb25..941e004 100644
--- a/xbmc/pvr/recordings/PVRRecordings.h
+++ b/xbmc/pvr/recordings/PVRRecordings.h
@@ -19,19 +19,13 @@
  *
  */
 
-#include <memory>
-#include <map>
-
+#include "epg/EpgTypes.h"
 #include "FileItem.h"
 #include "video/VideoDatabase.h"
 
-#include "PVRRecording.h"
+#include "pvr/recordings/PVRRecording.h"
 
-namespace EPG
-{
-  class CEpgInfoTag;
-  typedef std::shared_ptr<EPG::CEpgInfoTag> CEpgInfoTagPtr;
-}
+#include <map>
 
 namespace PVR
 {
diff --git a/xbmc/pvr/timers/PVRTimerInfoTag.h b/xbmc/pvr/timers/PVRTimerInfoTag.h
index 8c900df..14a69f3 100644
--- a/xbmc/pvr/timers/PVRTimerInfoTag.h
+++ b/xbmc/pvr/timers/PVRTimerInfoTag.h
@@ -37,9 +37,9 @@
  * number of the tag reported by the PVR backend and can not be played!
  */
 
-#include <memory>
-
 #include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "epg/EpgTypes.h"
+#include "pvr/PVRTypes.h"
 #include "pvr/timers/PVRTimerType.h"
 #include "threads/CriticalSection.h"
 #include "utils/ISerializable.h"
@@ -48,24 +48,12 @@
 class CFileItem;
 class CVariant;
 
-namespace EPG
-{
-  class CEpgInfoTag;
-  typedef std::shared_ptr<EPG::CEpgInfoTag> CEpgInfoTagPtr;
-}
-
 namespace PVR
 {
   class CGUIDialogPVRTimerSettings;
   class CPVRTimers;
   class CPVRChannelGroupInternal;
 
-  class CPVRChannel;
-  typedef std::shared_ptr<PVR::CPVRChannel> CPVRChannelPtr;
-
-  class CPVRTimerInfoTag;
-  typedef std::shared_ptr<PVR::CPVRTimerInfoTag> CPVRTimerInfoTagPtr;
-
   class CPVRTimerInfoTag : public ISerializable
   {
     friend class CPVRTimers;
diff --git a/xbmc/pvr/timers/PVRTimerType.h b/xbmc/pvr/timers/PVRTimerType.h
index d91c30f..14eb2f3 100644
--- a/xbmc/pvr/timers/PVRTimerType.h
+++ b/xbmc/pvr/timers/PVRTimerType.h
@@ -19,7 +19,8 @@
  *
  */
 
-#include <memory>
+#include "pvr/PVRTypes.h"
+
 #include <string>
 #include <utility>
 #include <vector>
@@ -28,9 +29,6 @@ struct PVR_TIMER_TYPE;
 
 namespace PVR
 {
-  class CPVRTimerType;
-  typedef std::shared_ptr<CPVRTimerType> CPVRTimerTypePtr;
-
   class CPVRTimerType
   {
   public:
diff --git a/xbmc/pvr/windows/GUIWindowPVRBase.cpp b/xbmc/pvr/windows/GUIWindowPVRBase.cpp
index 8dcbe20..74d0340 100644
--- a/xbmc/pvr/windows/GUIWindowPVRBase.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRBase.cpp
@@ -19,42 +19,25 @@
  */
 
 #include "GUIWindowPVRBase.h"
-#include "GUIWindowPVRRecordings.h"
 
-#include "Application.h"
 #include "addons/AddonManager.h"
-#include "cores/AudioEngine/Engines/ActiveAE/AudioDSPAddons/ActiveAEDSP.h"
-#include "dialogs/GUIDialogKaiToast.h"
-#include "dialogs/GUIDialogNumeric.h"
-#include "dialogs/GUIDialogOK.h"
 #include "dialogs/GUIDialogExtendedProgressBar.h"
 #include "dialogs/GUIDialogSelect.h"
-#include "dialogs/GUIDialogYesNo.h"
 #include "epg/Epg.h"
-#include "epg/GUIEPGGridContainer.h"
-#include "filesystem/StackDirectory.h"
 #include "GUIUserMessages.h"
 #include "guilib/GUIMessage.h"
 #include "guilib/GUIWindowManager.h"
 #include "input/Key.h"
 #include "messaging/ApplicationMessenger.h"
-#include "settings/MediaSettings.h"
-#include "settings/Settings.h"
-#include "threads/SingleLock.h"
-#include "utils/Observer.h"
-#include "utils/StringUtils.h"
-#include "utils/Variant.h"
-
-#include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClients.h"
 #include "pvr/channels/PVRChannelGroup.h"
 #include "pvr/channels/PVRChannelGroupsContainer.h"
-#include "pvr/dialogs/GUIDialogPVRGuideInfo.h"
 #include "pvr/dialogs/GUIDialogPVRRecordingInfo.h"
-#include "pvr/dialogs/GUIDialogPVRTimerSettings.h"
+#include "pvr/PVRGUIActions.h"
+#include "pvr/PVRManager.h"
 #include "pvr/timers/PVRTimers.h"
-
-#include <utility>
+#include "ServiceBroker.h"
+#include "utils/Variant.h"
 
 #define MAX_INVALIDATION_FREQUENCY 2000 // limit to one invalidation per X milliseconds
 
@@ -253,107 +236,6 @@ bool CGUIWindowPVRBase::OnMessage(CGUIMessage& message)
   return bReturn || CGUIMediaWindow::OnMessage(message);
 }
 
-bool CGUIWindowPVRBase::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  switch(button)
-  {
-    case CONTEXT_BUTTON_MENU_HOOKS:
-      if (itemNumber >= 0 && itemNumber < m_vecItems->Size())
-      {
-        CFileItemPtr item = m_vecItems->Get(itemNumber);
-
-        if (item->IsEPG() && item->GetEPGInfoTag()->HasPVRChannel())
-          g_PVRClients->ProcessMenuHooks(item->GetEPGInfoTag()->ChannelTag()->ClientID(), PVR_MENUHOOK_EPG, item.get());
-        else if (item->IsPVRChannel())
-          g_PVRClients->ProcessMenuHooks(item->GetPVRChannelInfoTag()->ClientID(), PVR_MENUHOOK_CHANNEL, item.get());
-        else if (item->IsDeletedPVRRecording())
-          g_PVRClients->ProcessMenuHooks(item->GetPVRRecordingInfoTag()->m_iClientId, PVR_MENUHOOK_DELETED_RECORDING, item.get());
-        else if (item->IsUsablePVRRecording())
-          g_PVRClients->ProcessMenuHooks(item->GetPVRRecordingInfoTag()->m_iClientId, PVR_MENUHOOK_RECORDING, item.get());
-        else if (item->IsPVRTimer())
-          g_PVRClients->ProcessMenuHooks(item->GetPVRTimerInfoTag()->m_iClientId, PVR_MENUHOOK_TIMER, item.get());
-
-        bReturn = true;
-      }
-      break;
-    case CONTEXT_BUTTON_FIND:
-    {
-      int windowSearchId = m_bRadio ? WINDOW_RADIO_SEARCH : WINDOW_TV_SEARCH;
-      CGUIWindowPVRBase *windowSearch = (CGUIWindowPVRBase*) g_windowManager.GetWindow(windowSearchId);
-      if (windowSearch && itemNumber >= 0 && itemNumber < m_vecItems->Size())
-      {
-        CFileItemPtr item = m_vecItems->Get(itemNumber);
-        g_windowManager.ActivateWindow(windowSearchId);
-        bReturn = windowSearch->OnContextButton(*item.get(), button);
-      }
-      break;
-    }
-    default:
-      bReturn = false;
-  }
-
-  return bReturn || CGUIMediaWindow::OnContextButton(itemNumber, button);
-}
-
-bool CGUIWindowPVRBase::OnContextButtonActiveAEDSPSettings(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_ACTIVE_ADSP_SETTINGS)
-  {
-    bReturn = true;
-
-    if (CServiceBroker::GetADSP().IsProcessing())
-      g_windowManager.ActivateWindow(WINDOW_DIALOG_AUDIO_DSP_OSD_SETTINGS);
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRBase::OnContextButtonEditTimer(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_EDIT_TIMER)
-  {
-    EditTimer(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRBase::OnContextButtonEditTimerRule(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_EDIT_TIMER_RULE)
-  {
-    EditTimerRule(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRBase::OnContextButtonDeleteTimerRule(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_DELETE_TIMER_RULE)
-  {
-    CFileItemPtr parentTimer(g_PVRTimers->GetTimerRule(item));
-    if (parentTimer)
-      DeleteTimerRule(parentTimer.get());
-
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
 void CGUIWindowPVRBase::SetInvalid()
 {
   if (m_refreshTimeout.IsTimePast())
@@ -455,566 +337,6 @@ void CGUIWindowPVRBase::SetChannelGroup(const CPVRChannelGroupPtr &group)
   }
 }
 
-bool CGUIWindowPVRBase::PlayFile(CFileItem *item, bool bPlayMinimized /* = false */, bool bCheckResume /* = true */)
-{
-  if (item->m_bIsFolder)
-  {
-    return false;
-  }
-
-  CPVRChannelPtr channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : CPVRChannelPtr();
-  if (item->GetPath() == g_application.CurrentFile() ||
-      (channel && channel->HasRecording() && channel->GetRecording()->GetPath() == g_application.CurrentFile()))
-  {
-    CGUIMessage msg(GUI_MSG_FULLSCREEN, 0, GetID());
-    g_windowManager.SendMessage(msg);
-    return true;
-  }
-
-  CMediaSettings::GetInstance().SetVideoStartWindowed(bPlayMinimized);
-
-  if (item->HasPVRRecordingInfoTag())
-  {
-    return PlayRecording(item, bPlayMinimized, bCheckResume);
-  }
-  else
-  {
-    bool bSwitchSuccessful(false);
-    CPVRChannelPtr channel(item->GetPVRChannelInfoTag());
-
-    if (channel && g_PVRManager.CheckParentalLock(channel))
-    {
-      CPVRRecordingPtr recording = channel->GetRecording();
-      if (recording)
-      {
-        CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*) g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
-        if (pDialog)
-        {
-          pDialog->SetHeading(CVariant{19687}); // Play recording
-          pDialog->SetLine(0, CVariant{""});
-          pDialog->SetLine(1, CVariant{12021}); // Start from beginning
-          pDialog->SetLine(2, CVariant{recording->m_strTitle});
-          pDialog->Open();
-
-          if (pDialog->IsConfirmed())
-          {
-            CFileItem recordingItem(recording);
-            return PlayRecording(&recordingItem, CSettings::GetInstance().GetBool(CSettings::SETTING_PVRPLAYBACK_PLAYMINIMIZED), bCheckResume);
-          }
-        }
-      }
-
-      /* try a fast switch */
-      if ((g_PVRManager.IsPlayingTV() || g_PVRManager.IsPlayingRadio()) &&
-         (channel->IsRadio() == g_PVRManager.IsPlayingRadio()))
-      {
-        if (channel->StreamURL().empty())
-          bSwitchSuccessful = g_application.m_pPlayer->SwitchChannel(channel);
-      }
-
-      if (!bSwitchSuccessful)
-      {
-        CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PLAY, 0, 0, static_cast<void*>(new CFileItem(*item)));
-        return true;
-      }
-    }
-
-    if (!bSwitchSuccessful)
-    {
-      std::string channelName = g_localizeStrings.Get(19029); // Channel
-      if (channel)
-        channelName = channel->ChannelName();
-      std::string msg = StringUtils::Format(g_localizeStrings.Get(19035).c_str(), channelName.c_str()); // CHANNELNAME could not be played. Check the log for details.
-
-      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error,
-              g_localizeStrings.Get(19166), // PVR information
-              msg);
-      return false;
-    }
-  }
-
-  return true;
-}
-
-bool CGUIWindowPVRBase::ShowTimerSettings(const CPVRTimerInfoTagPtr &timer)
-{
-  CGUIDialogPVRTimerSettings* pDlgInfo = (CGUIDialogPVRTimerSettings*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_TIMER_SETTING);
-
-  if (!pDlgInfo)
-  {
-    CLog::Log(LOGERROR, "CGUIWindowPVRBase - %s - unable to get WINDOW_DIALOG_PVR_TIMER_SETTING!", __FUNCTION__);
-    return false;
-  }
-
-  pDlgInfo->SetTimer(timer);
-  pDlgInfo->Open();
-
-  return pDlgInfo->IsConfirmed();
-}
-
-bool CGUIWindowPVRBase::AddTimer(CFileItem *item, bool bShowTimerSettings)
-{
-  return AddTimer(item, false, bShowTimerSettings);
-}
-
-bool CGUIWindowPVRBase::AddTimerRule(CFileItem *item, bool bShowTimerSettings)
-{
-  return AddTimer(item, true, bShowTimerSettings);
-}
-
-bool CGUIWindowPVRBase::AddTimer(CFileItem *item, bool bCreateRule, bool bShowTimerSettings)
-{
-  CEpgInfoTagPtr epgTag;
-  CPVRChannelPtr channel;
-
-  if (item->IsEPG())
-  {
-    epgTag  = item->GetEPGInfoTag();
-    channel = epgTag->ChannelTag();
-  }
-  else if (item->IsPVRChannel())
-  {
-    channel = item->GetPVRChannelInfoTag();
-    epgTag  = channel->GetEPGNow();
-  }
-
-  if (!channel)
-  {
-    CLog::Log(LOGERROR, "CGUIWindowPVRBase - %s - no channel!", __FUNCTION__);
-    return false;
-  }
-
-  if (!g_PVRManager.CheckParentalLock(channel))
-    return false;
-
-  if (!epgTag && bCreateRule)
-  {
-    CLog::Log(LOGERROR, "CGUIWindowPVRBase - %s - no epg tag!", __FUNCTION__);
-    return false;
-  }
-
-  CPVRTimerInfoTagPtr timer(bCreateRule || !epgTag ? nullptr : epgTag->Timer());
-  CPVRTimerInfoTagPtr rule (bCreateRule ? g_PVRTimers->GetTimerRule(timer) : nullptr);
-  if (timer || rule)
-  {
-    CGUIDialogOK::ShowAndGetInput(CVariant{19033}, CVariant{19034}); // "Information", "There is already a timer set for this event"
-    return false;
-  }
-
-  CPVRTimerInfoTagPtr newTimer(epgTag ? CPVRTimerInfoTag::CreateFromEpg(epgTag, bCreateRule) : CPVRTimerInfoTag::CreateInstantTimerTag(channel));
-  if (!newTimer)
-  {
-    CGUIDialogOK::ShowAndGetInput(CVariant{19033},
-                                  bCreateRule
-                                    ? CVariant{19095} // "Information", "Timer rule creation failed. The PVR add-on does not support a suitable timer rule type."
-                                    : CVariant{19094}); // "Information", "Timer creation failed. The PVR add-on does not support a suitable timer type."
-    return false;
-  }
-
-  if (bShowTimerSettings)
-  {
-    if (!ShowTimerSettings(newTimer))
-      return false;
-  }
-
-  return g_PVRTimers->AddTimer(newTimer);
-}
-
-bool CGUIWindowPVRBase::EditTimer(CFileItem *item)
-{
-  CPVRTimerInfoTagPtr timer;
-
-  if (item->IsPVRTimer())
-  {
-    timer = item->GetPVRTimerInfoTag();
-  }
-  else if (item->IsEPG())
-  {
-    timer = item->GetEPGInfoTag()->Timer();
-  }
-
-  if (!timer)
-  {
-    CLog::Log(LOGERROR, "CGUIWindowPVRBase - %s - no timer!", __FUNCTION__);
-    return false;
-  }
-
-  // clone the timer.
-  const CPVRTimerInfoTagPtr newTimer(new CPVRTimerInfoTag);
-  newTimer->UpdateEntry(timer);
-
-  if (ShowTimerSettings(newTimer) && (!timer->GetTimerType()->IsReadOnly() || timer->GetTimerType()->SupportsEnableDisable()))
-  {
-    if (newTimer->GetTimerType() == timer->GetTimerType())
-    {
-      return g_PVRTimers->UpdateTimer(newTimer);
-    }
-    else
-    {
-      // timer type changed. delete the original timer, then create the new timer. this order is
-      // important. for instance, the new timer might be a rule which schedules the original timer.
-      // deleting the original timer after creating the rule would do literally this and we would
-      // end up with one timer missing wrt to the rule defined by the new timer.
-      if (g_PVRTimers->DeleteTimer(timer, timer->IsRecording(), false))
-      {
-        if (g_PVRTimers->AddTimer(newTimer))
-          return true;
-
-        // rollback.
-        return g_PVRTimers->AddTimer(timer);
-      }
-    }
-  }
-  return false;
-}
-
-bool CGUIWindowPVRBase::EditTimerRule(CFileItem *item)
-{
-  CFileItemPtr parentTimer(g_PVRTimers->GetTimerRule(item));
-  if (parentTimer)
-    return EditTimer(parentTimer.get());
-
-  return false;
-}
-
-bool CGUIWindowPVRBase::DeleteTimer(CFileItem *item)
-{
-  return DeleteTimer(item, false, false);
-}
-
-bool CGUIWindowPVRBase::StopRecordFile(CFileItem *item)
-{
-  return DeleteTimer(item, true, false);
-}
-
-bool CGUIWindowPVRBase::DeleteTimerRule(CFileItem *item)
-{
-  return DeleteTimer(item, false, true);
-}
-
-bool CGUIWindowPVRBase::DeleteTimer(CFileItem *item, bool bIsRecording, bool bDeleteRule)
-{
-  CPVRTimerInfoTagPtr timer;
-
-  if (item->IsPVRTimer())
-  {
-    timer = item->GetPVRTimerInfoTag();
-  }
-  else if (item->IsEPG())
-  {
-    timer = item->GetEPGInfoTag()->Timer();
-  }
-  else if (item->IsPVRChannel())
-  {
-    const CEpgInfoTagPtr epgTag(item->GetPVRChannelInfoTag()->GetEPGNow());
-    if (epgTag)
-      timer = epgTag->Timer(); // cheap method, but not reliable as timers get set at epg tags asychrounously
-
-    if (!timer)
-      timer = g_PVRTimers->GetActiveTimerForChannel(item->GetPVRChannelInfoTag()); // more expensive, but reliable and works even for channels with no epg data
-  }
-
-  if (!timer)
-  {
-    CLog::Log(LOGERROR, "CGUIWindowPVRBase - %s - no timer!", __FUNCTION__);
-    return false;
-  }
-
-  if (bDeleteRule && !timer->IsTimerRule())
-    timer = g_PVRTimers->GetTimerRule(timer);
-
-  if (!timer)
-  {
-    CLog::Log(LOGERROR, "CGUIWindowPVRBase - %s - no timer rule!", __FUNCTION__);
-    return false;
-  }
-
-  if (bIsRecording)
-  {
-    if (ConfirmStopRecording(timer))
-      return g_PVRTimers->DeleteTimer(timer, true, false);
-  }
-  else if (timer->HasTimerType() && timer->GetTimerType()->IsReadOnly())
-  {
-    return false;
-  }
-  else
-  {
-    bool bAlsoDeleteRule(false);
-    if (ConfirmDeleteTimer(timer, bAlsoDeleteRule))
-      return g_PVRTimers->DeleteTimer(timer, false, bAlsoDeleteRule);
-  }
-  return false;
-}
-
-bool CGUIWindowPVRBase::CheckResumeRecording(CFileItem *item)
-{
-  bool bPlayIt(true);
-  std::string resumeString = CGUIWindowPVRRecordings::GetResumeString(*item);
-  if (!resumeString.empty())
-  {
-    CContextButtons choices;
-    choices.Add(CONTEXT_BUTTON_RESUME_ITEM, resumeString);
-    choices.Add(CONTEXT_BUTTON_PLAY_ITEM, 12021); // Start from beginning
-    int choice = CGUIDialogContextMenu::ShowAndGetChoice(choices);
-    if (choice > 0)
-      item->m_lStartOffset = choice == CONTEXT_BUTTON_RESUME_ITEM ? STARTOFFSET_RESUME : 0;
-    else
-      bPlayIt = false; // context menu cancelled
-  }
-  return bPlayIt;
-}
-
-bool CGUIWindowPVRBase::PlayRecording(CFileItem *item, bool bPlayMinimized /* = false */, bool bCheckResume /* = true */)
-{
-  if (!item->HasPVRRecordingInfoTag())
-    return false;
-
-  std::string stream = item->GetPVRRecordingInfoTag()->m_strStreamURL;
-  if (stream.empty())
-  {
-    if (!bCheckResume || CheckResumeRecording(item))
-      CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PLAY, 0, 0, static_cast<void*>(new CFileItem(*item)));
-
-    return true;
-  }
-
-  /* Isolate the folder from the filename */
-  size_t found = stream.find_last_of("/");
-  if (found == std::string::npos)
-    found = stream.find_last_of("\\");
-
-  if (found != std::string::npos)
-  {
-    /* Check here for asterisk at the begin of the filename */
-    if (stream[found+1] == '*')
-    {
-      /* Create a "stack://" url with all files matching the extension */
-      std::string ext = URIUtils::GetExtension(stream);
-      std::string dir = stream.substr(0, found);
-
-      CFileItemList items;
-      XFILE::CDirectory::GetDirectory(dir, items);
-      items.Sort(SortByFile, SortOrderAscending);
-
-      std::vector<int> stack;
-      for (int i = 0; i < items.Size(); ++i)
-      {
-        if (URIUtils::HasExtension(items[i]->GetPath(), ext))
-          stack.push_back(i);
-      }
-
-      if (stack.empty())
-      {
-        /* If we have a stack change the path of the item to it */
-        XFILE::CStackDirectory dir;
-        std::string stackPath = dir.ConstructStackPath(items, stack);
-        item->SetPath(stackPath);
-      }
-    }
-    else
-    {
-      /* If no asterisk is present play only the given stream URL */
-      item->SetPath(stream);
-    }
-  }
-  else
-  {
-    CLog::Log(LOGERROR, "CGUIWindowPVRBase - %s - can't open recording: no valid filename", __FUNCTION__);
-    CGUIDialogOK::ShowAndGetInput(CVariant{19033}, CVariant{19036});
-    return false;
-  }
-
-  if (!bCheckResume || CheckResumeRecording(item))
-    CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PLAY, 0, 0, static_cast<void*>(new CFileItem(*item)));
-
-  return true;
-}
-
-void CGUIWindowPVRBase::ShowRecordingInfo(CFileItem *item)
-{
-  CGUIDialogPVRRecordingInfo* pDlgInfo = (CGUIDialogPVRRecordingInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_RECORDING_INFO);
-  if (item->IsPVRRecording() && pDlgInfo)
-  {
-    pDlgInfo->SetRecording(item);
-    pDlgInfo->Open();
-  }
-}
-
-void CGUIWindowPVRBase::ShowEPGInfo(CFileItem *item)
-{
-  CEpgInfoTagPtr epgTag;
-  CPVRChannelPtr channel;
-
-  if (item->IsEPG())
-  {
-    epgTag  = item->GetEPGInfoTag();
-    channel = epgTag->ChannelTag();
-  }
-  else if (item->IsPVRChannel())
-  {
-    channel = item->GetPVRChannelInfoTag();
-    epgTag  = channel->GetEPGNow();
-  }
-  else if (item->IsPVRTimer())
-  {
-    epgTag = item->GetPVRTimerInfoTag()->GetEpgInfoTag();
-    if (epgTag && epgTag->HasPVRChannel())
-      channel = epgTag->ChannelTag();
-  }
-
-  if (channel && !g_PVRManager.CheckParentalLock(channel))
-    return;
-
-  if (!epgTag)
-  {
-    CLog::Log(LOGERROR, "CGUIWindowPVRBase - %s - no epg tag!", __FUNCTION__);
-    return;
-  }
-
-  CGUIDialogPVRGuideInfo* pDlgInfo = (CGUIDialogPVRGuideInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GUIDE_INFO);
-  if (!pDlgInfo)
-  {
-    CLog::Log(LOGERROR, "CGUIWindowPVRBase - %s - unable to get WINDOW_DIALOG_PVR_GUIDE_INFO!", __FUNCTION__);
-    return;
-  }
-
-  pDlgInfo->SetProgInfo(epgTag);
-  pDlgInfo->Open();
-}
-
-bool CGUIWindowPVRBase::ActionInputChannelNumber(int input)
-{
-  std::string strInput = StringUtils::Format("%i", input);
-  if (CGUIDialogNumeric::ShowAndGetNumber(strInput, g_localizeStrings.Get(19103)))
-  {
-    int iChannelNumber = atoi(strInput.c_str());
-    if (iChannelNumber >= 0)
-    {
-      int itemIndex = 0;
-      VECFILEITEMS items = m_vecItems->GetList();
-      for (VECFILEITEMS::iterator it = items.begin(); it != items.end(); ++it)
-      {
-        if(((*it)->HasPVRChannelInfoTag() && (*it)->GetPVRChannelInfoTag()->ChannelNumber() == iChannelNumber) ||
-           ((*it)->HasEPGInfoTag() && (*it)->GetEPGInfoTag()->HasPVRChannel() && (*it)->GetEPGInfoTag()->PVRChannelNumber() == iChannelNumber))
-        {
-          // different handling for guide grid
-          if (GetID() == WINDOW_TV_GUIDE || GetID() == WINDOW_RADIO_GUIDE)
-          {
-            CGUIEPGGridContainer* epgGridContainer = (CGUIEPGGridContainer*) GetControl(m_viewControl.GetCurrentControl());
-            if ((*it)->HasEPGInfoTag() && (*it)->GetEPGInfoTag()->HasPVRChannel())
-              epgGridContainer->SetChannel((*it)->GetEPGInfoTag()->ChannelTag());
-            else
-              epgGridContainer->SetChannel((*it)->GetPVRChannelInfoTag());
-          }
-          else
-            m_viewControl.SetSelectedItem(itemIndex);
-          return true;
-        }
-        ++itemIndex;
-      }
-    }
-  }
-
-  return false;
-}
-
-bool CGUIWindowPVRBase::ActionShowTimerRule(CFileItem *item)
-{
-  if (!g_PVRTimers->GetTimerRule(item))
-    return AddTimerRule(item, true);
-  else
-    return EditTimerRule(item);
-}
-
-bool CGUIWindowPVRBase::ActionToggleTimer(CFileItem *item)
-{
-  if (!item->HasEPGInfoTag())
-    return false;
-
-  CPVRTimerInfoTagPtr timer(item->GetEPGInfoTag()->Timer());
-  if (timer)
-    return DeleteTimer(item, timer->IsRecording(), false);
-  else
-    return AddTimer(item, false, false);
-}
-
-bool CGUIWindowPVRBase::ActionPlayChannel(CFileItem *item)
-{
-  return PlayFile(item, CSettings::GetInstance().GetBool(CSettings::SETTING_PVRPLAYBACK_PLAYMINIMIZED));
-}
-
-bool CGUIWindowPVRBase::ActionPlayEpg(CFileItem *item, bool bPlayRecording)
-{
-  if (!item || !item->HasEPGInfoTag())
-    return false;
-
-  CPVRChannelPtr channel;
-  CEpgInfoTagPtr epgTag(item->GetEPGInfoTag());
-  if (epgTag && epgTag->HasPVRChannel())
-    channel = epgTag->ChannelTag();
-
-  if (!channel || !g_PVRManager.CheckParentalLock(channel))
-    return false;
-
-  CFileItem fileItem;
-  if (bPlayRecording && epgTag->HasRecording())
-    fileItem = CFileItem(epgTag->Recording());
-  else
-    fileItem = CFileItem(channel);
-
-  g_application.SwitchToFullScreen();
-  if (!PlayFile(&fileItem))
-  {
-    // CHANNELNAME could not be played. Check the log for details.
-    std::string msg = StringUtils::Format(g_localizeStrings.Get(19035).c_str(), channel->ChannelName().c_str());
-    CGUIDialogOK::ShowAndGetInput(CVariant{19033}, CVariant{std::move(msg)});
-    return false;
-  }
-
-  return true;
-}
-
-bool CGUIWindowPVRBase::ActionDeleteChannel(CFileItem *item)
-{
-  CPVRChannelPtr channel(item->GetPVRChannelInfoTag());
-
-  /* check if the channel tag is valid */
-  if (!channel || channel->ChannelNumber() <= 0)
-    return false;
-
-  /* show a confirmation dialog */
-  CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*) g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
-  if (!pDialog)
-    return false;
-  pDialog->SetHeading(CVariant{19039});
-  pDialog->SetLine(0, CVariant{""});
-  pDialog->SetLine(1, CVariant{channel->ChannelName()});
-  pDialog->SetLine(2, CVariant{""});
-  pDialog->Open();
-
-  /* prompt for the user's confirmation */
-  if (!pDialog->IsConfirmed())
-    return false;
-
-  g_PVRChannelGroups->GetGroupAll(channel->IsRadio())->RemoveFromGroup(channel);
-  Refresh(true);
-
-  return true;
-}
-
-bool CGUIWindowPVRBase::UpdateEpgForChannel(CFileItem *item)
-{
-  CPVRChannelPtr channel(item->GetPVRChannelInfoTag());
-
-  CEpgPtr epg = channel->GetEPG();
-  if (!epg)
-    return false;
-
-  epg->ForceUpdate();
-  return true;
-}
-
 bool CGUIWindowPVRBase::Update(const std::string &strDirectory, bool updateFilterPath /*= true*/)
 {
   if (!GetChannelGroup())
@@ -1032,51 +354,6 @@ void CGUIWindowPVRBase::UpdateButtons(void)
   SET_CONTROL_LABEL(CONTROL_BTNCHANNELGROUPS, g_localizeStrings.Get(19141) + ": " + m_channelGroup->GroupName());
 }
 
-bool CGUIWindowPVRBase::ConfirmDeleteTimer(const CPVRTimerInfoTagPtr &timer, bool &bDeleteRule)
-{
-  bool bConfirmed(false);
-
-  if (timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
-  {
-    // timer was scheduled by a timer rule. prompt user for confirmation for deleting the timer rule, including scheduled timers.
-    bool bCancel(false);
-    bDeleteRule = CGUIDialogYesNo::ShowAndGetInput(
-                        CVariant{122}, // "Confirm delete"
-                        CVariant{840}, // "Do you want to delete only this timer or also the timer rule that has scheduled it?"
-                        CVariant{""},
-                        CVariant{timer->Title()},
-                        bCancel,
-                        CVariant{841}, // "Only this"
-                        CVariant{593}, // "All"
-                        0); // no autoclose
-    bConfirmed = !bCancel;
-  }
-  else
-  {
-    bDeleteRule = false;
-
-    // prompt user for confirmation for deleting the timer
-    bConfirmed = CGUIDialogYesNo::ShowAndGetInput(
-                        CVariant{122}, // "Confirm delete"
-                        timer->IsTimerRule()
-                          ? CVariant{845}  // "Are you sure you want to delete this timer rule and all timers it has scheduled?"
-                          : CVariant{846}, // "Are you sure you want to delete this timer?"
-                        CVariant{""},
-                        CVariant{timer->Title()});
-  }
-
-  return bConfirmed;
-}
-
-bool CGUIWindowPVRBase::ConfirmStopRecording(const CPVRTimerInfoTagPtr &timer)
-{
-  return CGUIDialogYesNo::ShowAndGetInput(
-                         CVariant{847}, // "Confirm stop recording"
-                         CVariant{848}, // "Are you sure you want to stop this recording?"
-                         CVariant{""},
-                         CVariant{timer->Title()});
-}
-
 void CGUIWindowPVRBase::ShowProgressDialog(const std::string &strText, int iProgress)
 {
   if (!m_progressHandle)
diff --git a/xbmc/pvr/windows/GUIWindowPVRBase.h b/xbmc/pvr/windows/GUIWindowPVRBase.h
index 6175fd7..6733051 100644
--- a/xbmc/pvr/windows/GUIWindowPVRBase.h
+++ b/xbmc/pvr/windows/GUIWindowPVRBase.h
@@ -19,8 +19,10 @@
  *
  */
 
-#include "windows/GUIMediaWindow.h"
 #include "utils/Observer.h"
+#include "windows/GUIMediaWindow.h"
+
+#include "pvr/PVRTypes.h"
 
 #define CONTROL_BTNVIEWASICONS            2
 #define CONTROL_BTNSORTBY                 3
@@ -48,12 +50,6 @@ namespace PVR
     EPG_SELECT_ACTION_PLAY_RECORDING = 4,
   };
 
-  class CPVRChannelGroup;
-  typedef std::shared_ptr<CPVRChannelGroup> CPVRChannelGroupPtr;
-
-  class CPVRTimerInfoTag;
-  typedef std::shared_ptr<CPVRTimerInfoTag> CPVRTimerInfoTagPtr;
-
   class CGUIWindowPVRBase : public CGUIMediaWindow, public Observer
   {
   public:
@@ -61,9 +57,7 @@ namespace PVR
     virtual void OnInitWindow(void) override;
     virtual void OnDeinitWindow(int nextWindowID) override;
     virtual bool OnMessage(CGUIMessage& message) override;
-    virtual bool OnContextButton(int itemNumber, CONTEXT_BUTTON button) override;
     virtual bool OnContextButton(const CFileItem &item, CONTEXT_BUTTON button) { return false; };
-    virtual bool OnContextButtonActiveAEDSPSettings(CFileItem *item, CONTEXT_BUTTON button);
     virtual bool Update(const std::string &strDirectory, bool updateFilterPath = true) override;
     virtual void UpdateButtons(void) override;
     virtual bool OnAction(const CAction &action) override;
@@ -76,16 +70,11 @@ namespace PVR
     static std::string GetSelectedItemPath(bool bRadio);
     static void SetSelectedItemPath(bool bRadio, const std::string &path);
 
-    static bool ShowTimerSettings(const CPVRTimerInfoTagPtr &timer);
-    static bool AddTimer(CFileItem *item, bool bShowTimerSettings = false);
-    static bool AddTimerRule(CFileItem *item, bool bShowTimerSettings = true);
-    static bool EditTimer(CFileItem *item);
-    static bool EditTimerRule(CFileItem *item);
-    static bool DeleteTimer(CFileItem *item);
-    static bool DeleteTimerRule(CFileItem *item);
-    static bool StopRecordFile(CFileItem *item);
-
-    static bool PlayRecording(CFileItem *item, bool bPlayMinimized = false, bool bCheckResume = true);
+    /*!
+     * @brief Refresh window content.
+     * @return true, if refresh succeeded, false otherwise.
+     */
+    bool DoRefresh(void) { return Refresh(true); }
 
   protected:
     CGUIWindowPVRBase(bool bRadio, int id, const std::string &xmlFile);
@@ -98,23 +87,7 @@ namespace PVR
     virtual CPVRChannelGroupPtr GetChannelGroup(void);
     virtual void SetChannelGroup(const CPVRChannelGroupPtr &group);
 
-    virtual bool ActionShowTimerRule(CFileItem *item);
-    virtual bool ActionToggleTimer(CFileItem *item);
-    virtual bool ActionPlayChannel(CFileItem *item);
-    virtual bool ActionPlayEpg(CFileItem *item, bool bPlayRecording);
-    virtual bool ActionDeleteChannel(CFileItem *item);
-    virtual bool ActionInputChannelNumber(int input);
-
-    virtual bool PlayFile(CFileItem *item, bool bPlayMinimized = false, bool bCheckResume = true);
-    virtual void ShowEPGInfo(CFileItem *item);
-    virtual void ShowRecordingInfo(CFileItem *item);
-    virtual bool UpdateEpgForChannel(CFileItem *item);
     virtual void UpdateSelectedItemPath();
-    static bool CheckResumeRecording(CFileItem *item);
-
-    bool OnContextButtonEditTimer(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonEditTimerRule(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonDeleteTimerRule(CFileItem *item, CONTEXT_BUTTON button);
 
     void RegisterObservers(void);
     void UnregisterObservers(void);
@@ -127,24 +100,6 @@ namespace PVR
 
   private:
     /*!
-     * @brief Open a dialog to confirm timer delete.
-     * @param timer the timer to delete.
-     * @param bDeleteRule in: ignored
-     *                    out, for one shot timer scheduled by a timer rule: true to also delete the timer
-     *                    rule that has scheduled this timer, false to only delete the one shot timer.
-     *                    out, for one shot timer not scheduled by a timer rule: ignored
-     * @return true, to proceed with delete, false otherwise.
-     */
-    static bool ConfirmDeleteTimer(const CPVRTimerInfoTagPtr &timer, bool &bDeleteRule);
-
-    /*!
-     * @brief Open a dialog to confirm stop recording.
-     * @param timer the recording to stop (actually the timer to delete).
-     * @return true, to proceed with delete, false otherwise.
-     */
-    static bool ConfirmStopRecording(const CPVRTimerInfoTagPtr &timer);
-
-    /*!
      * @brief Show or update the progress dialog.
      * @param strText The current status.
      * @param iProgress The current progress in %.
@@ -156,9 +111,6 @@ namespace PVR
      */
     void HideProgressDialog(void);
 
-    static bool DeleteTimer(CFileItem *item, bool bIsRecording, bool bDeleteRule);
-    static bool AddTimer(CFileItem *item, bool bCreateRule, bool bShowTimerSettings);
-
     CPVRChannelGroupPtr m_channelGroup;
     XbmcThreads::EndTime m_refreshTimeout;
     CGUIDialogProgressBarHandle *m_progressHandle; /*!< progress dialog that is displayed while the pvr manager is loading */
diff --git a/xbmc/pvr/windows/GUIWindowPVRChannels.cpp b/xbmc/pvr/windows/GUIWindowPVRChannels.cpp
index 67067fc..cf81e35 100644
--- a/xbmc/pvr/windows/GUIWindowPVRChannels.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRChannels.cpp
@@ -19,27 +19,27 @@
  */
 
 
-#include "ContextMenuManager.h"
 #include "GUIInfoManager.h"
-#include "cores/AudioEngine/Engines/ActiveAE/AudioDSPAddons/ActiveAEDSP.h"
 #include "epg/EpgContainer.h"
+#include "dialogs/GUIDialogContextMenu.h"
 #include "dialogs/GUIDialogKaiToast.h"
-#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogNumeric.h"
 #include "dialogs/GUIDialogYesNo.h"
 #include "guilib/GUIKeyboardFactory.h"
 #include "guilib/GUIRadioButtonControl.h"
 #include "guilib/GUIWindowManager.h"
 #include "input/Key.h"
+#include "settings/Settings.h"
 #include "threads/SingleLock.h"
 #include "utils/StringUtils.h"
 #include "utils/Variant.h"
 
+#include "pvr/PVRGUIActions.h"
 #include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClients.h"
 #include "pvr/channels/PVRChannelGroupsContainer.h"
 #include "pvr/dialogs/GUIDialogPVRChannelManager.h"
 #include "pvr/dialogs/GUIDialogPVRGroupManager.h"
-#include "pvr/timers/PVRTimers.h"
 
 #include "GUIWindowPVRChannels.h"
 
@@ -62,32 +62,10 @@ CGUIWindowPVRChannels::~CGUIWindowPVRChannels()
 
 void CGUIWindowPVRChannels::GetContextButtons(int itemNumber, CContextButtons &buttons)
 {
-  if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
-    return;
-  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
-  CPVRChannelPtr channel(pItem->GetPVRChannelInfoTag());
-
-  if (channel->GetEPGNow())
-  {
-    buttons.Add(CONTEXT_BUTTON_INFO, 19047);                                        /* Programme information */
-    buttons.Add(CONTEXT_BUTTON_FIND, 19003);                                        /* Find similar */
-  }
-
-  if (channel->IsRecording())
-    buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059);  /* Stop recording */
-  else if (g_PVRClients->SupportsTimers(channel->ClientID()))
-    buttons.Add(CONTEXT_BUTTON_START_RECORD, 264);   /* Record */
-
-  if (CServiceBroker::GetADSP().IsProcessing())
-    buttons.Add(CONTEXT_BUTTON_ACTIVE_ADSP_SETTINGS, 15047);                        /* Audio DSP settings */
-
-  if (g_PVRClients->HasMenuHooks(channel->ClientID(), PVR_MENUHOOK_CHANNEL))
-    buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);                                  /* PVR client specific action */
-
   // Add parent buttons before the Manage button
   CGUIWindowPVRBase::GetContextButtons(itemNumber, buttons);
 
-  buttons.Add(CONTEXT_BUTTON_EDIT, 16106);                                          /* Manage... */
+  buttons.Add(CONTEXT_BUTTON_EDIT, 16106); /* Manage... */
 }
 
 std::string CGUIWindowPVRChannels::GetDirectoryPath(void)
@@ -101,17 +79,9 @@ bool CGUIWindowPVRChannels::OnContextButton(int itemNumber, CONTEXT_BUTTON butto
 {
   if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
     return false;
-  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
-
-  return OnContextButtonAdd(pItem.get(), button) ||
-      OnContextButtonInfo(pItem.get(), button) ||
-      OnContextButtonGroupManager(pItem.get(), button) ||
-      OnContextButtonUpdateEpg(pItem.get(), button) ||
-      OnContextButtonStartRecord(pItem.get(), button) ||
-      OnContextButtonStopRecord(pItem.get(), button) ||
-      OnContextButtonManage(pItem.get(), button) ||
-      OnContextButtonActiveAEDSPSettings(pItem.get(), button) ||
-      CGUIWindowPVRBase::OnContextButton(itemNumber, button);
+
+  return OnContextButtonManage(m_vecItems->Get(itemNumber), button) ||
+      CGUIMediaWindow::OnContextButton(itemNumber, button);
 }
 
 bool CGUIWindowPVRChannels::Update(const std::string &strDirectory, bool updateFilterPath /* = true */)
@@ -150,7 +120,6 @@ bool CGUIWindowPVRChannels::OnAction(const CAction &action)
 {
   switch (action.GetID())
   {
-    case REMOTE_0:
     case REMOTE_1:
     case REMOTE_2:
     case REMOTE_3:
@@ -160,7 +129,7 @@ bool CGUIWindowPVRChannels::OnAction(const CAction &action)
     case REMOTE_7:
     case REMOTE_8:
     case REMOTE_9:
-      return ActionInputChannelNumber(action.GetID() - REMOTE_0);
+      return InputChannelNumber(action.GetID() - REMOTE_0);
   }
 
   return CGUIWindowPVRBase::OnAction(action);
@@ -183,13 +152,15 @@ bool CGUIWindowPVRChannels::OnMessage(CGUIMessage& message)
            case ACTION_SELECT_ITEM:
            case ACTION_MOUSE_LEFT_CLICK:
            case ACTION_PLAY:
-             ActionPlayChannel(m_vecItems->Get(iItem).get());
+             CPVRGUIActions::GetInstance().SwitchToChannel(m_vecItems->Get(iItem),
+                                                           CSettings::GetInstance().GetBool(CSettings::SETTING_PVRPLAYBACK_PLAYMINIMIZED),
+                                                           true);
              break;
            case ACTION_SHOW_INFO:
-             ShowEPGInfo(m_vecItems->Get(iItem).get());
+             CPVRGUIActions::GetInstance().ShowEPGInfo(m_vecItems->Get(iItem));
              break;
            case ACTION_DELETE_ITEM:
-             ActionDeleteChannel(m_vecItems->Get(iItem).get());
+             CPVRGUIActions::GetInstance().HideChannel(m_vecItems->Get(iItem));
              break;
            case ACTION_CONTEXT_MENU:
            case ACTION_MOUSE_RIGHT_CLICK:
@@ -248,46 +219,7 @@ bool CGUIWindowPVRChannels::OnMessage(CGUIMessage& message)
   return bReturn || CGUIWindowPVRBase::OnMessage(message);
 }
 
-bool CGUIWindowPVRChannels::OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_ADD)
-  {
-    CGUIDialogOK::ShowAndGetInput(CVariant{19033}, CVariant{19038});
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRChannels::OnContextButtonGroupManager(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_GROUP_MANAGER)
-  {
-    ShowGroupManager();
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRChannels::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_INFO)
-  {
-    ShowEPGInfo(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRChannels::OnContextButtonManage(CFileItem *item, CONTEXT_BUTTON button)
+bool CGUIWindowPVRChannels::OnContextButtonManage(const CFileItemPtr &item, CONTEXT_BUTTON button)
 {
   bool bReturn = false;
 
@@ -312,7 +244,7 @@ bool CGUIWindowPVRChannels::OnContextButtonManage(CFileItem *item, CONTEXT_BUTTO
           ShowChannelManager();
           break;
         case CONTEXT_BUTTON_UPDATE_EPG:
-          OnContextButtonUpdateEpg(item, (CONTEXT_BUTTON)button);
+          UpdateEpg(item);
           break;
         default:
           break;
@@ -328,67 +260,37 @@ bool CGUIWindowPVRChannels::OnContextButtonManage(CFileItem *item, CONTEXT_BUTTO
   return bReturn;
 }
 
-bool CGUIWindowPVRChannels::OnContextButtonStartRecord(CFileItem *item, CONTEXT_BUTTON button)
+void CGUIWindowPVRChannels::UpdateEpg(const CFileItemPtr &item)
 {
-  bool bReturn = false;
+  const CPVRChannelPtr channel(item->GetPVRChannelInfoTag());
 
-  if (button == CONTEXT_BUTTON_START_RECORD)
-  {
-    AddTimer(item);
-    bReturn = true;
-  }
-  else if (button == CONTEXT_BUTTON_ADD_TIMER)
-  {
-    AddTimerRule(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRChannels::OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
+  if (!CGUIDialogYesNo::ShowAndGetInput(CVariant{19251}, // "Update guide information"
+                                        CVariant{19252}, // "Schedule guide update for this channel?"
+                                        CVariant{""},
+                                        CVariant{channel->ChannelName()}))
+    return;
 
-  if (button == CONTEXT_BUTTON_STOP_RECORD)
+  const CEpgPtr epg = channel->GetEPG();
+  if (epg)
   {
-    StopRecordFile(item);
-    bReturn = true;
+    epg->ForceUpdate();
+
+    const std::string strMessage = StringUtils::Format("%s: '%s'",
+                                                       g_localizeStrings.Get(19253).c_str(), // "Guide update scheduled for channel"
+                                                       channel->ChannelName().c_str());
+    CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info,
+                                          g_localizeStrings.Get(19166), // "PVR information"
+                                          strMessage);
   }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRChannels::OnContextButtonUpdateEpg(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_UPDATE_EPG)
+  else
   {
-    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
-    if (!pDialog)
-      return bReturn;
-
-    CPVRChannelPtr channel(item->GetPVRChannelInfoTag());
-
-    pDialog->SetHeading(CVariant{19251});
-    pDialog->SetLine(0, CVariant{g_localizeStrings.Get(19252)});
-    pDialog->SetLine(1, CVariant{channel->ChannelName()});
-    pDialog->SetLine(2, CVariant{""});
-    pDialog->Open();
-
-    if (!pDialog->IsConfirmed())
-      return bReturn;
-
-    bReturn = UpdateEpgForChannel(item);
-
-    std::string strMessage = StringUtils::Format("%s: '%s'", g_localizeStrings.Get(bReturn ? 19253 : 19254).c_str(), channel->ChannelName().c_str());
-    CGUIDialogKaiToast::QueueNotification(bReturn ? CGUIDialogKaiToast::Info : CGUIDialogKaiToast::Error,
-        g_localizeStrings.Get(19166),
-        strMessage);
+    const std::string strMessage = StringUtils::Format("%s: '%s'",
+                                                       g_localizeStrings.Get(19254).c_str(), // "Guide update failed for channel"
+                                                       channel->ChannelName().c_str());
+    CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error,
+                                          g_localizeStrings.Get(19166), // "PVR information"
+                                          strMessage);
   }
-
-  return bReturn;
 }
 
 void CGUIWindowPVRChannels::ShowChannelManager()
@@ -410,3 +312,27 @@ void CGUIWindowPVRChannels::ShowGroupManager(void)
 
   return;
 }
+
+bool CGUIWindowPVRChannels::InputChannelNumber(int input)
+{
+  std::string strInput = StringUtils::Format("%i", input);
+  if (CGUIDialogNumeric::ShowAndGetNumber(strInput, g_localizeStrings.Get(19103)))
+  {
+    int iChannelNumber = atoi(strInput.c_str());
+    if (iChannelNumber >= 0)
+    {
+      int itemIndex = 0;
+      for (auto channel : m_vecItems->GetList())
+      {
+        if (channel->GetPVRChannelInfoTag()->ChannelNumber() == iChannelNumber)
+        {
+          m_viewControl.SetSelectedItem(itemIndex);
+          return true;
+        }
+        ++itemIndex;
+      }
+    }
+  }
+
+  return false;
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVRChannels.h b/xbmc/pvr/windows/GUIWindowPVRChannels.h
index 94e0119..9578402 100644
--- a/xbmc/pvr/windows/GUIWindowPVRChannels.h
+++ b/xbmc/pvr/windows/GUIWindowPVRChannels.h
@@ -40,17 +40,12 @@ namespace PVR
     virtual std::string GetDirectoryPath(void) override;
 
   private:
-    bool OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonGroupManager(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonManage(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonUpdateEpg(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonAddTimer(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonStartRecord(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button);
+    bool OnContextButtonManage(const CFileItemPtr &item, CONTEXT_BUTTON button);
 
     void ShowChannelManager();
-    void ShowGroupManager(void);
+    void ShowGroupManager();
+    void UpdateEpg(const CFileItemPtr &item);
+    bool InputChannelNumber(int input);
 
     bool m_bShowHiddenChannels;
   };
diff --git a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
index 5a10301..8313167 100644
--- a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
@@ -19,6 +19,7 @@
  */
 
 #include "ContextMenuManager.h"
+#include "dialogs/GUIDialogNumeric.h"
 #include "epg/GUIEPGGridContainer.h"
 #include "GUIUserMessages.h"
 #include "epg/EpgContainer.h"
@@ -30,6 +31,7 @@
 #include "threads/SingleLock.h"
 #include "utils/log.h"
 
+#include "pvr/PVRGUIActions.h"
 #include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClients.h"
 #include "pvr/channels/PVRChannelGroupsContainer.h"
@@ -145,60 +147,10 @@ void CGUIWindowPVRGuide::GetContextButtons(int itemNumber, CContextButtons &butt
 {
   if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
     return;
-  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
-
-  buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 19000);         /* Switch channel */
-  buttons.Add(CONTEXT_BUTTON_INFO, 19047);              /* Programme information */
-  buttons.Add(CONTEXT_BUTTON_FIND, 19003);              /* Find similar */
-
-  CEpgInfoTagPtr epg(pItem->GetEPGInfoTag());
-  if (epg)
-  {
-    CPVRTimerInfoTagPtr timer(epg->Timer());
-    if (timer)
-    {
-      if (timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
-      {
-        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER_RULE, 19243); /* Edit timer rule */
-        buttons.Add(CONTEXT_BUTTON_DELETE_TIMER_RULE, 19295); /* Delete timer rule */
-      }
-
-      const CPVRTimerTypePtr timerType(timer->GetTimerType());
-      if (timerType && !timerType->IsReadOnly() && timer->GetTimerRuleId() == PVR_TIMER_NO_PARENT)
-        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER, 19242);    /* Edit timer */
-      else
-        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER, 19241);    /* View timer information */
-
-      if (timer->IsRecording())
-        buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059);   /* Stop recording */
-      else
-      {
-        if (timerType && !timerType->IsReadOnly())
-          buttons.Add(CONTEXT_BUTTON_DELETE_TIMER, 19060);  /* Delete timer */
-      }
-    }
-    else if (g_PVRClients->SupportsTimers())
-    {
-      if (epg->EndAsLocalTime() > CDateTime::GetCurrentDateTime())
-        buttons.Add(CONTEXT_BUTTON_START_RECORD, 264);      /* Record */
-      buttons.Add(CONTEXT_BUTTON_ADD_TIMER, 19061);       /* Add timer */
-    }
-
-    if (epg->HasRecording())
-      buttons.Add(CONTEXT_BUTTON_PLAY_OTHER, 19687);      /* Play recording */
-  }
-
 
   buttons.Add(CONTEXT_BUTTON_BEGIN, 19063); /* Go to begin */
-  buttons.Add(CONTEXT_BUTTON_NOW, 19070); /* Go to now */
-  buttons.Add(CONTEXT_BUTTON_END, 19064); /* Go to end */
-
-  if (epg)
-  {
-    CPVRChannelPtr channel(epg->ChannelTag());
-    if (channel && g_PVRClients->HasMenuHooks(channel->ClientID(), PVR_MENUHOOK_EPG))
-      buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);      /* PVR client specific action */
-  }
+  buttons.Add(CONTEXT_BUTTON_NOW,   19070); /* Go to now */
+  buttons.Add(CONTEXT_BUTTON_END,   19064); /* Go to end */
 
   CGUIWindowPVRBase::GetContextButtons(itemNumber, buttons);
 }
@@ -273,7 +225,7 @@ bool CGUIWindowPVRGuide::OnAction(const CAction &action)
     case REMOTE_7:
     case REMOTE_8:
     case REMOTE_9:
-      return ActionInputChannelNumber(action.GetID() - REMOTE_0);
+      return InputChannelNumber(action.GetID() - REMOTE_0);
   }
 
   return CGUIWindowPVRBase::OnAction(action);
@@ -304,37 +256,37 @@ bool CGUIWindowPVRGuide::OnMessage(CGUIMessage& message)
                   bReturn = true;
                   break;
                 case EPG_SELECT_ACTION_SWITCH:
-                  ActionPlayEpg(pItem.get(), false);
+                  CPVRGUIActions::GetInstance().SwitchToChannel(pItem, false, true);
                   bReturn = true;
                   break;
                 case EPG_SELECT_ACTION_PLAY_RECORDING:
-                  ActionPlayEpg(pItem.get(), true);
+                  CPVRGUIActions::GetInstance().PlayRecording(pItem, false, true);
                   bReturn = true;
                   break;
                 case EPG_SELECT_ACTION_INFO:
-                  ShowEPGInfo(pItem.get());
+                  CPVRGUIActions::GetInstance().ShowEPGInfo(pItem);
                   bReturn = true;
                   break;
                 case EPG_SELECT_ACTION_RECORD:
-                  ActionToggleTimer(pItem.get());
+                  CPVRGUIActions::GetInstance().ToggleTimer(pItem);
                   bReturn = true;
                   break;
               }
               break;
             case ACTION_SHOW_INFO:
-              ShowEPGInfo(pItem.get());
+              CPVRGUIActions::GetInstance().ShowEPGInfo(pItem);
               bReturn = true;
               break;
             case ACTION_PLAY:
-              ActionPlayEpg(pItem.get(), true);
+              CPVRGUIActions::GetInstance().PlayRecording(pItem, false, true);
               bReturn = true;
               break;
             case ACTION_RECORD:
-              ActionToggleTimer(pItem.get());
+              CPVRGUIActions::GetInstance().ToggleTimer(pItem);
               bReturn = true;
               break;
             case ACTION_PVR_SHOW_TIMER_RULE:
-              ActionShowTimerRule(pItem.get());
+              CPVRGUIActions::GetInstance().AddTimerRule(pItem, true);
               bReturn = true;
               break;
             case ACTION_CONTEXT_MENU:
@@ -357,10 +309,10 @@ bool CGUIWindowPVRGuide::OnMessage(CGUIMessage& message)
               CGUIEPGGridContainer *epgGridContainer = GetGridControl();
               if (epgGridContainer)
               {
-                CFileItemPtr item(epgGridContainer->GetSelectedChannelItem());
+                const CFileItemPtr item(epgGridContainer->GetSelectedChannelItem());
                 if (item)
                 {
-                  ActionPlayEpg(item.get(), false);
+                  CPVRGUIActions::GetInstance().SwitchToChannel(item, false, true);
                   bReturn = true;
                 }
               }
@@ -423,18 +375,10 @@ bool CGUIWindowPVRGuide::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
     return false;
   CFileItemPtr pItem = m_vecItems->Get(itemNumber);
 
-  return OnContextButtonPlay(pItem.get(), button) ||
-      OnContextButtonInfo(pItem.get(), button) ||
-      OnContextButtonStartRecord(pItem.get(), button) ||
-      OnContextButtonStopRecord(pItem.get(), button) ||
-      OnContextButtonEditTimer(pItem.get(), button) ||
-      OnContextButtonEditTimerRule(pItem.get(), button) ||
-      OnContextButtonDeleteTimer(pItem.get(), button) ||
-      OnContextButtonDeleteTimerRule(pItem.get(), button) ||
-      OnContextButtonBegin(pItem.get(), button) ||
+  return OnContextButtonBegin(pItem.get(), button) ||
       OnContextButtonEnd(pItem.get(), button) ||
       OnContextButtonNow(pItem.get(), button) ||
-      CGUIWindowPVRBase::OnContextButton(itemNumber, button);
+      CGUIMediaWindow::OnContextButton(itemNumber, button);
 }
 
 bool CGUIWindowPVRGuide::RefreshTimelineItems()
@@ -527,74 +471,31 @@ bool CGUIWindowPVRGuide::OnContextButtonNow(CFileItem *item, CONTEXT_BUTTON butt
   return bReturn;
 }
 
-bool CGUIWindowPVRGuide::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_INFO)
-  {
-    ShowEPGInfo(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRGuide::OnContextButtonPlay(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_PLAY_ITEM || button == CONTEXT_BUTTON_PLAY_OTHER)
-  {
-    ActionPlayEpg(item, button == CONTEXT_BUTTON_PLAY_OTHER);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRGuide::OnContextButtonStartRecord(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_START_RECORD)
-  {
-    AddTimer(item);
-    bReturn = true;
-  }
-  else if (button == CONTEXT_BUTTON_ADD_TIMER)
-  {
-    AddTimerRule(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRGuide::OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button)
+bool CGUIWindowPVRGuide::InputChannelNumber(int input)
 {
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_STOP_RECORD)
+  std::string strInput = StringUtils::Format("%i", input);
+  if (CGUIDialogNumeric::ShowAndGetNumber(strInput, g_localizeStrings.Get(19103)))
   {
-    StopRecordFile(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRGuide::OnContextButtonDeleteTimer(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_DELETE_TIMER)
-  {
-    DeleteTimer(item);
-    bReturn = true;
+    int iChannelNumber = atoi(strInput.c_str());
+    if (iChannelNumber >= 0)
+    {
+      for (auto event : m_vecItems->GetList())
+      {
+        const CEpgInfoTagPtr tag(event->GetEPGInfoTag());
+        if (tag->HasPVRChannel() && tag->PVRChannelNumber() == iChannelNumber)
+        {
+          CGUIEPGGridContainer* epgGridContainer = dynamic_cast<CGUIEPGGridContainer*>(GetControl(m_viewControl.GetCurrentControl()));
+          if (epgGridContainer)
+          {
+            epgGridContainer->SetChannel(tag->ChannelTag());
+            return true;
+          }
+        }
+      }
+    }
   }
 
-  return bReturn;
+  return false;
 }
 
 CPVRRefreshTimelineItemsThread::CPVRRefreshTimelineItemsThread(CGUIWindowPVRGuide *pGuideWindow)
diff --git a/xbmc/pvr/windows/GUIWindowPVRGuide.h b/xbmc/pvr/windows/GUIWindowPVRGuide.h
index a957f15..bdbc1d7 100644
--- a/xbmc/pvr/windows/GUIWindowPVRGuide.h
+++ b/xbmc/pvr/windows/GUIWindowPVRGuide.h
@@ -70,11 +70,8 @@ namespace PVR
     bool OnContextButtonBegin(CFileItem *item, CONTEXT_BUTTON button);
     bool OnContextButtonEnd(CFileItem *item, CONTEXT_BUTTON button);
     bool OnContextButtonNow(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonPlay(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonStartRecord(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonDeleteTimer(CFileItem *item, CONTEXT_BUTTON button);
+
+    bool InputChannelNumber(int input);
 
     void StartRefreshTimelineItemsThread();
     void StopRefreshTimelineItemsThread();
diff --git a/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp b/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
index 17daef0..069d907 100644
--- a/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
@@ -18,27 +18,20 @@
  *
  */
 
-#include "ContextMenuManager.h"
 #include "GUIInfoManager.h"
-#include "cores/AudioEngine/Engines/ActiveAE/AudioDSPAddons/ActiveAEDSP.h"
-#include "dialogs/GUIDialogYesNo.h"
 #include "guilib/LocalizeStrings.h"
-#include "guilib/GUIKeyboardFactory.h"
 #include "guilib/GUIRadioButtonControl.h"
 #include "guilib/GUIWindowManager.h"
 #include "input/Key.h"
 #include "settings/Settings.h"
 #include "threads/SingleLock.h"
-#include "utils/StringUtils.h"
 #include "utils/URIUtils.h"
-#include "utils/Variant.h"
 #include "video/windows/GUIWindowVideoNav.h"
 
+#include "pvr/PVRGUIActions.h"
 #include "pvr/PVRManager.h"
-#include "pvr/addons/PVRClients.h"
 #include "pvr/recordings/PVRRecordings.h"
 #include "pvr/recordings/PVRRecordingsPath.h"
-#include "pvr/timers/PVRTimers.h"
 
 #include "GUIWindowPVRRecordings.h"
 
@@ -67,35 +60,6 @@ std::string CGUIWindowPVRRecordings::GetDirectoryPath(void)
   return URIUtils::PathHasParent(m_vecItems->GetPath(), basePath) ? m_vecItems->GetPath() : basePath;
 }
 
-std::string CGUIWindowPVRRecordings::GetResumeString(const CFileItem& item)
-{
-  std::string resumeString;
-  if (item.IsUsablePVRRecording())
-  {
-
-    // First try to find the resume position on the back-end, if that fails use video database
-    int positionInSeconds = item.GetPVRRecordingInfoTag()->GetLastPlayedPosition();
-    // If the back-end does report a saved position it will be picked up by FileItem
-    if (positionInSeconds < 0)
-    {
-      CVideoDatabase db;
-      if (db.Open())
-      {
-        CBookmark bookmark;
-        std::string itemPath(item.GetPVRRecordingInfoTag()->m_strFileNameAndPath);
-        if (db.GetResumeBookMark(itemPath, bookmark) )
-          positionInSeconds = lrint(bookmark.timeInSeconds);
-        db.Close();
-      }
-    }
-
-    // Suppress resume from 0
-    if (positionInSeconds > 0)
-      resumeString = StringUtils::Format(g_localizeStrings.Get(12022).c_str(), StringUtils::SecondsToTimeString(positionInSeconds, TIME_FORMAT_HH_MM_SS).c_str());
-  }
-  return resumeString;
-}
-
 void CGUIWindowPVRRecordings::GetContextButtons(int itemNumber, CContextButtons &buttons)
 {
   if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
@@ -115,60 +79,11 @@ void CGUIWindowPVRRecordings::GetContextButtons(int itemNumber, CContextButtons
   {
     isDeletedRecording = recording->IsDeleted();
 
-    buttons.Add(CONTEXT_BUTTON_INFO, 19053);        /* Recording Information */
-    if (!isDeletedRecording)
+    if (isDeletedRecording)
     {
-      buttons.Add(CONTEXT_BUTTON_FIND, 19003);      /* Find similar */
-
-      std::string resumeString = GetResumeString(*pItem);
-      if (resumeString.empty())
-      {
-        buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 208); /* Play */
-      }
-      else
-      {
-        buttons.Add(CONTEXT_BUTTON_RESUME_ITEM, resumeString); /* Resume from HH:MM:SS */
-        buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 12023); /* Play from beginning */
-      }
-    }
-    else
-    {
-      buttons.Add(CONTEXT_BUTTON_UNDELETE, 19290);      /* Undelete */
-      buttons.Add(CONTEXT_BUTTON_DELETE, 19291);        /* Delete permanently */
       if (m_vecItems->GetObjectCount() > 1)
-        buttons.Add(CONTEXT_BUTTON_DELETE_ALL, 19292);  /* Delete all permanently */
-    }
-  }
-  if (!isDeletedRecording)
-  {
-    if (pItem->m_bIsFolder)
-    {
-      // Have both options for folders since we don't know whether all children are watched/unwatched
-      buttons.Add(CONTEXT_BUTTON_MARK_UNWATCHED, 16104); /* Mark as unwatched */
-      buttons.Add(CONTEXT_BUTTON_MARK_WATCHED, 16103);   /* Mark as watched */
-    }
-
-    if (recording)
-    {
-      if (recording->m_playCount > 0)
-        buttons.Add(CONTEXT_BUTTON_MARK_UNWATCHED, 16104); /* Mark as unwatched */
-      else
-        buttons.Add(CONTEXT_BUTTON_MARK_WATCHED, 16103);   /* Mark as watched */
-
-      buttons.Add(CONTEXT_BUTTON_RENAME, 118);      /* Rename */
+        buttons.Add(CONTEXT_BUTTON_DELETE_ALL, 19292); /* Delete all permanently */
     }
-
-    buttons.Add(CONTEXT_BUTTON_DELETE, 117);        /* Delete */
-  }
-
-  if (CServiceBroker::GetADSP().IsProcessing())
-    buttons.Add(CONTEXT_BUTTON_ACTIVE_ADSP_SETTINGS, 15047);  /* Audio DSP settings */
-
-  if (recording)
-  {
-    if ((!isDeletedRecording && g_PVRClients->HasMenuHooks(recording->m_iClientId, PVR_MENUHOOK_RECORDING)) ||
-        (isDeletedRecording && g_PVRClients->HasMenuHooks(recording->m_iClientId, PVR_MENUHOOK_DELETED_RECORDING)))
-      buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);      /* PVR client specific action */
   }
 
   if (!isDeletedRecording)
@@ -196,25 +111,25 @@ bool CGUIWindowPVRRecordings::OnContextButton(int itemNumber, CONTEXT_BUTTON but
     return false;
   CFileItemPtr pItem = m_vecItems->Get(itemNumber);
 
-  return OnContextButtonPlay(pItem.get(), button) ||
-      OnContextButtonRename(pItem.get(), button) ||
-      OnContextButtonDelete(pItem.get(), button) ||
-      OnContextButtonUndelete(pItem.get(), button) ||
-      OnContextButtonDeleteAll(pItem.get(), button) ||
-      OnContextButtonInfo(pItem.get(), button) ||
-      OnContextButtonMarkWatched(pItem, button) ||
-      OnContextButtonActiveAEDSPSettings(pItem.get(), button) ||
-      CGUIWindowPVRBase::OnContextButton(itemNumber, button);
+  return OnContextButtonDeleteAll(pItem.get(), button) ||
+      CGUIMediaWindow::OnContextButton(itemNumber, button);
 }
 
 bool CGUIWindowPVRRecordings::Update(const std::string &strDirectory, bool updateFilterPath /* = true */)
 {
   m_thumbLoader.StopThread();
 
+  int iOldCount = m_vecItems->GetObjectCount();
+  const std::string oldPath = m_vecItems->GetPath();
+
   bool bReturn = CGUIWindowPVRBase::Update(strDirectory);
 
   if (bReturn)
   {
+    // TODO: does it make sense to show the non-deleted recordings, although user wants
+    //       to see the deleted recordings? Or is this just another hack to avoid misbehavior
+    //       of CGUIMediaWindow if it has no content?
+
     CSingleLock lock(m_critSection);
 
     /* empty list for deleted recordings */
@@ -224,8 +139,17 @@ bool CGUIWindowPVRRecordings::Update(const std::string &strDirectory, bool updat
       m_bShowDeletedRecordings = false;
       lock.Leave();
       Update(GetDirectoryPath());
+      return bReturn;
     }
   }
+
+  if (bReturn && iOldCount > 0 && m_vecItems->GetObjectCount() == 0 && oldPath == m_vecItems->GetPath())
+  {
+    /* go to the parent folder if we're in a subdirectory and for instance just deleted the last item */
+    const CPVRRecordingsPath path(m_vecItems->GetPath());
+    if (path.IsValid() && !path.IsRecordingsRoot())
+      GoParentFolder();
+  }
   return bReturn;
 }
 
@@ -284,7 +208,7 @@ bool CGUIWindowPVRRecordings::OnMessage(CGUIMessage &message)
 
               if (message.GetParam1() == ACTION_PLAY)
               {
-                PlayFile(item.get(), false /* don't play minimized */, true /* check resume */);
+                CPVRGUIActions::GetInstance().PlayRecording(item, false /* don't play minimized */, true /* check resume */);
                 bReturn = true;
               }
               else
@@ -296,19 +220,15 @@ bool CGUIWindowPVRRecordings::OnMessage(CGUIMessage &message)
                     bReturn = true;
                     break;
                   case SELECT_ACTION_PLAY_OR_RESUME:
-                    PlayFile(item.get(), false /* don't play minimized */, true /* check resume */);
+                    CPVRGUIActions::GetInstance().PlayRecording(item, false /* don't play minimized */, true /* check resume */);
                     bReturn = true;
                     break;
                   case SELECT_ACTION_RESUME:
-                  {
-                    const std::string resumeString = GetResumeString(*item);
-                    item->m_lStartOffset = resumeString.empty() ? 0 : STARTOFFSET_RESUME;
-                    PlayFile(item.get(), false /* don't play minimized */, false /* don't check resume */);
+                    CPVRGUIActions::GetInstance().ResumePlayRecording(item, false /* don't play minimized */, true /* fall back to play if no resume possible */);
                     bReturn = true;
                     break;
-                  }
                   case SELECT_ACTION_INFO:
-                    ShowRecordingInfo(item.get());
+                    CPVRGUIActions::GetInstance().ShowRecordingInfo(item);
                     bReturn = true;
                     break;
                   default:
@@ -324,11 +244,11 @@ bool CGUIWindowPVRRecordings::OnMessage(CGUIMessage &message)
               bReturn = true;
               break;
             case ACTION_SHOW_INFO:
-              ShowRecordingInfo(item.get());
+              CPVRGUIActions::GetInstance().ShowRecordingInfo(item);
               bReturn = true;
               break;
             case ACTION_DELETE_ITEM:
-              ActionDeleteRecording(item.get());
+              CPVRGUIActions::GetInstance().DeleteRecording(item);
               bReturn = true;
               break;
             default:
@@ -379,192 +299,15 @@ bool CGUIWindowPVRRecordings::OnMessage(CGUIMessage &message)
   return bReturn || CGUIWindowPVRBase::OnMessage(message);
 }
 
-bool CGUIWindowPVRRecordings::ActionDeleteRecording(CFileItem *item)
-{
-  bool bReturn = false;
-
-  if ((!item->IsPVRRecording() && !item->m_bIsFolder) || item->IsParentFolder())
-    return bReturn;
-
-  /* show a confirmation dialog */
-  CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
-  if (!pDialog)
-    return bReturn;
-
-  int iLine0 = item->m_bIsFolder ? 19113 : item->GetPVRRecordingInfoTag()->IsDeleted() ? 19294 : 19112;
-  pDialog->SetHeading(CVariant{122}); // Confirm delete
-  pDialog->SetLine(0, CVariant{iLine0}); // Delete all recordings in this folder? / Delete this recording permanently? / Delete this recording?
-  pDialog->SetLine(1, CVariant{""});
-  pDialog->SetLine(2, CVariant{item->GetLabel()});
-  pDialog->SetChoice(1, CVariant{117}); // Delete
-
-  /* prompt for the user's confirmation */
-  pDialog->Open();
-  if (!pDialog->IsConfirmed())
-    return bReturn;
-
-  /* delete the recording */
-  if (g_PVRRecordings->Delete(*item))
-  {
-    g_PVRManager.TriggerRecordingsUpdate();
-    bReturn = true;
-
-    /* remove the item from the list immediately, otherwise the
-    item count further down may be wrong */
-    m_vecItems->Remove(item);
-
-    /* go to the parent folder if we're in a subdirectory and just deleted the last item */
-    CPVRRecordingsPath path(m_vecItems->GetPath());
-    if (path.IsValid() && !path.IsRecordingsRoot() && m_vecItems->GetObjectCount() == 0)
-      GoParentFolder();
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRRecordings::OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button)
-{
-  return button == CONTEXT_BUTTON_DELETE ? ActionDeleteRecording(item) : false;
-}
-
-bool CGUIWindowPVRRecordings::OnContextButtonUndelete(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button != CONTEXT_BUTTON_UNDELETE || !item->IsDeletedPVRRecording())
-    return bReturn;
-
-  /* undelete the recording */
-  if (g_PVRRecordings->Undelete(*item))
-  {
-    g_PVRManager.TriggerRecordingsUpdate();
-    bReturn = true;
-
-    /* remove the item from the list immediately, otherwise the
-    item count further down may be wrong */
-    m_vecItems->Remove(item);
-
-    /* go to the parent folder if we're in a subdirectory and just deleted the last item */
-    CPVRRecordingsPath path(m_vecItems->GetPath());
-    if (path.IsValid() && !path.IsRecordingsRoot() && m_vecItems->GetObjectCount() == 0)
-      GoParentFolder();
-  }
-
-  return bReturn;
-}
-
 bool CGUIWindowPVRRecordings::OnContextButtonDeleteAll(CFileItem *item, CONTEXT_BUTTON button)
 {
-  bool bReturn = false;
-
-  if (button != CONTEXT_BUTTON_DELETE_ALL || !item->IsDeletedPVRRecording())
-    return bReturn;
-
-  /* show a confirmation dialog */
-  CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
-  if (!pDialog)
-    return bReturn;
-
-
-  pDialog->SetHeading(CVariant{19292}); // Delete all permanently
-  pDialog->SetLine(0, CVariant{19293}); // Delete all recordings permanently?
-  pDialog->SetLine(1, CVariant{""});
-  pDialog->SetLine(2, CVariant{""});
-  pDialog->SetChoice(1, CVariant{117}); // Delete
-
-  /* prompt for the user's confirmation */
-  pDialog->Open();
-  if (!pDialog->IsConfirmed())
-    return bReturn;
-
-  /* undelete the recording */
-  if (g_PVRRecordings->DeleteAllRecordingsFromTrash())
+  if (button == CONTEXT_BUTTON_DELETE_ALL)
   {
-    g_PVRManager.TriggerRecordingsUpdate();
-    bReturn = true;
-
-    /* remove the item from the list immediately, otherwise the
-    item count further down may be wrong */
-    m_vecItems->Clear();
-
-    /* go to the parent folder if we're in a subdirectory and just deleted the last item */
-    CPVRRecordingsPath path(m_vecItems->GetPath());
-    if (path.IsValid() && !path.IsRecordingsRoot() && m_vecItems->GetObjectCount() == 0)
-      GoParentFolder();
-  }
-  return bReturn;
-}
-
-bool CGUIWindowPVRRecordings::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_INFO)
-  {
-    bReturn = true;
-    ShowRecordingInfo(item);
+    CPVRGUIActions::GetInstance().DeleteAllRecordingsFromTrash();
+    return true;
   }
 
-  return bReturn;
-}
-
-bool CGUIWindowPVRRecordings::OnContextButtonPlay(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if ((button == CONTEXT_BUTTON_PLAY_ITEM) ||
-      (button == CONTEXT_BUTTON_RESUME_ITEM))
-  {
-    item->m_lStartOffset = button == CONTEXT_BUTTON_RESUME_ITEM ? STARTOFFSET_RESUME : 0;
-    bReturn = PlayFile(item, false, false); /* play recording, don't check resume */
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRRecordings::OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_RENAME)
-  {
-    CPVRRecordingPtr recording = item->GetPVRRecordingInfoTag();
-    if (recording)
-    {
-      bReturn = true;
-
-      std::string strNewName = recording->m_strTitle;
-      if (CGUIKeyboardFactory::ShowAndGetInput(strNewName, CVariant{g_localizeStrings.Get(19041)}, false))
-      {
-        if (g_PVRRecordings->RenameRecording(*item, strNewName))
-          Refresh(true);
-      }
-    }
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRRecordings::OnContextButtonMarkWatched(const CFileItemPtr &item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_MARK_WATCHED || button == CONTEXT_BUTTON_MARK_UNWATCHED)
-  {
-    if (button == CONTEXT_BUTTON_MARK_WATCHED)
-      bReturn = g_PVRRecordings->IncrementRecordingsPlayCount(item);
-    else
-      bReturn = g_PVRRecordings->SetRecordingsPlayCount(item, 0);
-
-    if (bReturn)
-    {
-      // Advance the selected item one notch
-      m_viewControl.SetSelectedItem(m_viewControl.GetSelectedItem() + 1);
-      Refresh(true);
-    }
-  }
-
-  return bReturn;
+  return false;
 }
 
 void CGUIWindowPVRRecordings::OnPrepareFileItems(CFileItemList& items)
diff --git a/xbmc/pvr/windows/GUIWindowPVRRecordings.h b/xbmc/pvr/windows/GUIWindowPVRRecordings.h
index 1dfdcf6..41f184e 100644
--- a/xbmc/pvr/windows/GUIWindowPVRRecordings.h
+++ b/xbmc/pvr/windows/GUIWindowPVRRecordings.h
@@ -32,8 +32,6 @@ namespace PVR
     CGUIWindowPVRRecordings(bool bRadio);
     virtual ~CGUIWindowPVRRecordings(void);
 
-    static std::string GetResumeString(const CFileItem& item);
-
     virtual void OnWindowLoaded() override;
     virtual bool OnMessage(CGUIMessage& message) override;
     virtual bool OnAction(const CAction &action) override;
@@ -47,14 +45,7 @@ namespace PVR
     virtual void OnPrepareFileItems(CFileItemList &items) override;
 
   private:
-    bool ActionDeleteRecording(CFileItem *item);
-    bool OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonUndelete(CFileItem *item, CONTEXT_BUTTON button);
     bool OnContextButtonDeleteAll(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonPlay(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonMarkWatched(const CFileItemPtr &item, CONTEXT_BUTTON button);
 
     CVideoThumbLoader m_thumbLoader;
     CVideoDatabase m_database;
diff --git a/xbmc/pvr/windows/GUIWindowPVRSearch.cpp b/xbmc/pvr/windows/GUIWindowPVRSearch.cpp
index f71ea78..f56d0e8 100644
--- a/xbmc/pvr/windows/GUIWindowPVRSearch.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRSearch.cpp
@@ -18,7 +18,6 @@
  *
  */
 
-#include "ContextMenuManager.h"
 #include "dialogs/GUIDialogOK.h"
 #include "dialogs/GUIDialogProgress.h"
 #include "epg/EpgContainer.h"
@@ -26,6 +25,7 @@
 #include "input/Key.h"
 #include "utils/Variant.h"
 
+#include "pvr/PVRGUIActions.h"
 #include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClients.h"
 #include "pvr/channels/PVRChannelGroupsContainer.h"
@@ -46,54 +46,9 @@ void CGUIWindowPVRSearch::GetContextButtons(int itemNumber, CContextButtons &but
 {
   if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
     return;
-  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
 
   buttons.Add(CONTEXT_BUTTON_CLEAR, 19232);               /* Clear search results */
 
-  CEpgInfoTagPtr epg(pItem->GetEPGInfoTag());
-  if (epg)
-  {
-    buttons.Add(CONTEXT_BUTTON_INFO, 19047);              /* Programme information */
-
-    CPVRTimerInfoTagPtr timer(epg->Timer());
-    if (timer)
-    {
-      if (timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
-      {
-        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER_RULE, 19243); /* Edit timer rule */
-        buttons.Add(CONTEXT_BUTTON_DELETE_TIMER_RULE, 19295); /* Delete timer rule */
-      }
-
-      const CPVRTimerTypePtr timerType(timer->GetTimerType());
-      if (timerType && !timerType->IsReadOnly() && timer->GetTimerRuleId() == PVR_TIMER_NO_PARENT)
-        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER, 19242);    /* Edit timer */
-      else
-        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER, 19241);    /* View timer information */
-
-      if (timer->IsRecording())
-        buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059);   /* Stop recording */
-      else
-      {
-        if (timerType && !timerType->IsReadOnly())
-          buttons.Add(CONTEXT_BUTTON_DELETE_TIMER, 19060);  /* Delete timer */
-      }
-    }
-    else if (g_PVRClients->SupportsTimers())
-    {
-      if (epg->EndAsLocalTime() > CDateTime::GetCurrentDateTime())
-        buttons.Add(CONTEXT_BUTTON_START_RECORD, 264);      /* Record */
-      buttons.Add(CONTEXT_BUTTON_ADD_TIMER, 19061);       /* Add timer */
-    }
-
-    if (epg->HasRecording())
-      buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 19687);       /* Play recording */
-
-    CPVRChannelPtr channel(epg->ChannelTag());
-    if (channel &&
-        g_PVRClients->HasMenuHooks(channel->ClientID(), PVR_MENUHOOK_EPG))
-      buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);      /* PVR client specific action */
-  }
-
   CGUIWindowPVRBase::GetContextButtons(itemNumber, buttons);
 }
 
@@ -110,57 +65,36 @@ bool CGUIWindowPVRSearch::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
   CFileItemPtr pItem = m_vecItems->Get(itemNumber);
 
   return OnContextButtonClear(pItem.get(), button) ||
-      OnContextButtonInfo(pItem.get(), button) ||
-      OnContextButtonStartRecord(pItem.get(), button) ||
-      OnContextButtonStopRecord(pItem.get(), button) ||
-      OnContextButtonEditTimer(pItem.get(), button) ||
-      OnContextButtonEditTimerRule(pItem.get(), button) ||
-      OnContextButtonDeleteTimer(pItem.get(), button) ||
-      OnContextButtonDeleteTimerRule(pItem.get(), button) ||
-      OnContextButtonPlay(pItem.get(), button) ||
-      CGUIWindowPVRBase::OnContextButton(itemNumber, button);
+      CGUIMediaWindow::OnContextButton(itemNumber, button);
 }
 
-bool CGUIWindowPVRSearch::OnContextButton(const CFileItem &item, CONTEXT_BUTTON button)
+bool CGUIWindowPVRSearch::FindSimilar(const CFileItemPtr &item)
 {
-  bool bReturn = false;
+  m_searchfilter.Reset();
 
-  switch(button)
+  // construct the search term
+  if (item->IsEPG())
+    m_searchfilter.m_strSearchTerm = "\"" + item->GetEPGInfoTag()->Title() + "\"";
+  else if (item->IsPVRChannel())
   {
-    case CONTEXT_BUTTON_FIND:
-    {
-      m_searchfilter.Reset();
-
-      // construct the search term
-      if (item.IsEPG())
-        m_searchfilter.m_strSearchTerm = "\"" + item.GetEPGInfoTag()->Title() + "\"";
-      else if (item.IsPVRChannel())
-      {
-        const CEpgInfoTagPtr tag(item.GetPVRChannelInfoTag()->GetEPGNow());
-        if (tag)
-          m_searchfilter.m_strSearchTerm = "\"" + tag->Title() + "\"";
-      }
-      else if (item.IsUsablePVRRecording())
-        m_searchfilter.m_strSearchTerm = "\"" + item.GetPVRRecordingInfoTag()->m_strTitle + "\"";
-      else if (item.IsPVRTimer())
-      {
-        const CPVRTimerInfoTagPtr info(item.GetPVRTimerInfoTag());
-        const CEpgInfoTagPtr tag(info->GetEpgInfoTag());
-        if (tag)
-          m_searchfilter.m_strSearchTerm = "\"" + tag->Title() + "\"";
-        else
-          m_searchfilter.m_strSearchTerm = "\"" + info->m_strTitle + "\"";
-      }
-      m_bSearchConfirmed = true;
-      Refresh(true);
-      bReturn = true;
-      break;
-    }
-    default:
-      bReturn = false;
+    const CEpgInfoTagPtr tag(item->GetPVRChannelInfoTag()->GetEPGNow());
+    if (tag)
+      m_searchfilter.m_strSearchTerm = "\"" + tag->Title() + "\"";
   }
-
-  return bReturn;
+  else if (item->IsUsablePVRRecording())
+    m_searchfilter.m_strSearchTerm = "\"" + item->GetPVRRecordingInfoTag()->m_strTitle + "\"";
+  else if (item->IsPVRTimer())
+  {
+    const CPVRTimerInfoTagPtr info(item->GetPVRTimerInfoTag());
+    const CEpgInfoTagPtr tag(info->GetEpgInfoTag());
+    if (tag)
+      m_searchfilter.m_strSearchTerm = "\"" + tag->Title() + "\"";
+    else
+      m_searchfilter.m_strSearchTerm = "\"" + info->m_strTitle + "\"";
+  }
+  m_bSearchConfirmed = true;
+  Refresh(true);
+  return true;
 }
 
 void CGUIWindowPVRSearch::OnPrepareFileItems(CFileItemList &items)
@@ -223,7 +157,7 @@ bool CGUIWindowPVRSearch::OnMessage(CGUIMessage &message)
             if (URIUtils::PathEquals(pItem->GetPath(), "pvr://guide/searchresults/search/"))
               OpenDialogSearch();
             else
-               ShowEPGInfo(pItem.get());
+               CPVRGUIActions::GetInstance().ShowEPGInfo(pItem);
             return true;
           }
 
@@ -233,7 +167,7 @@ bool CGUIWindowPVRSearch::OnMessage(CGUIMessage &message)
             return true;
 
           case ACTION_RECORD:
-            ActionToggleTimer(pItem.get());
+            CPVRGUIActions::GetInstance().ToggleTimer(pItem);
             return true;
         }
       }
@@ -260,77 +194,6 @@ bool CGUIWindowPVRSearch::OnContextButtonClear(CFileItem *item, CONTEXT_BUTTON b
   return bReturn;
 }
 
-bool CGUIWindowPVRSearch::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_INFO)
-  {
-    bReturn = true;
-
-    ShowEPGInfo(item);
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRSearch::OnContextButtonPlay(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_PLAY_ITEM)
-  {
-    ActionPlayEpg(item, true /* play recording, not channel */);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRSearch::OnContextButtonStartRecord(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_START_RECORD)
-  {
-    AddTimer(item);
-    bReturn = true;
-  }
-  else if (button == CONTEXT_BUTTON_ADD_TIMER)
-  {
-    AddTimerRule(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRSearch::OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_STOP_RECORD)
-  {
-    StopRecordFile(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRSearch::OnContextButtonDeleteTimer(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_DELETE_TIMER)
-  {
-    DeleteTimer(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
 void CGUIWindowPVRSearch::OpenDialogSearch()
 {
   CGUIDialogPVRGuideSearch* dlgSearch = (CGUIDialogPVRGuideSearch*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GUIDE_SEARCH);
diff --git a/xbmc/pvr/windows/GUIWindowPVRSearch.h b/xbmc/pvr/windows/GUIWindowPVRSearch.h
index d63f8ec..e9a2812 100644
--- a/xbmc/pvr/windows/GUIWindowPVRSearch.h
+++ b/xbmc/pvr/windows/GUIWindowPVRSearch.h
@@ -34,7 +34,13 @@ namespace PVR
     virtual void OnWindowLoaded() override;
     virtual void GetContextButtons(int itemNumber, CContextButtons &buttons) override;
     virtual bool OnContextButton(int itemNumber, CONTEXT_BUTTON button) override;
-    virtual bool OnContextButton(const CFileItem &item, CONTEXT_BUTTON button) override;
+
+    /*!
+     * @brief trigger a search for events similar to the given item.
+     * @param item the epg event to search similar events for.
+     * @return True on success (note: empty result set also means success), false otherwise.
+     */
+    bool FindSimilar(const CFileItemPtr &item);
 
   protected:
     virtual void OnPrepareFileItems(CFileItemList &items) override;
@@ -42,11 +48,6 @@ namespace PVR
 
   private:
     bool OnContextButtonClear(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonPlay(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonStartRecord(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonDeleteTimer(CFileItem *item, CONTEXT_BUTTON button);
 
     void OpenDialogSearch();
 
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp b/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
index 3c55214..3d7070f 100644
--- a/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
@@ -18,25 +18,20 @@
  *
  */
 
-#include "ContextMenuManager.h"
 #include "GUIInfoManager.h"
 #include "dialogs/GUIDialogOK.h"
-#include "dialogs/GUIDialogYesNo.h"
-#include "guilib/GUIKeyboardFactory.h"
-#include "guilib/GUIWindowManager.h"
 #include "input/Key.h"
 #include "settings/Settings.h"
 #include "threads/SingleLock.h"
-#include "utils/StringUtils.h"
 #include "utils/URIUtils.h"
 #include "utils/Variant.h"
 
+#include "pvr/PVRGUIActions.h"
 #include "pvr/PVRManager.h"
-#include "pvr/dialogs/GUIDialogPVRTimerSettings.h"
 #include "pvr/timers/PVRTimers.h"
 #include "pvr/addons/PVRClients.h"
 
-#include "GUIWindowPVRTimers.h"
+#include "GUIWindowPVRTimersBase.h"
 
 using namespace PVR;
 
@@ -51,60 +46,6 @@ CGUIWindowPVRTimersBase::~CGUIWindowPVRTimersBase()
   g_infoManager.UnregisterObserver(this);
 }
 
-void CGUIWindowPVRTimersBase::GetContextButtons(int itemNumber, CContextButtons &buttons)
-{
-  if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
-    return;
-  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
-
-  if (!URIUtils::PathEquals(pItem->GetPath(), CPVRTimersPath::PATH_ADDTIMER))
-  {
-    CPVRTimerInfoTagPtr timer(pItem->GetPVRTimerInfoTag());
-    if (timer)
-    {
-      if (timer->GetEpgInfoTag())
-        buttons.Add(CONTEXT_BUTTON_INFO, 19047);          /* Programme information */
-
-      CPVRTimerTypePtr timerType(timer->GetTimerType());
-      if (timerType)
-      {
-        if (timerType->SupportsEnableDisable())
-        {
-          if (timer->m_state == PVR_TIMER_STATE_DISABLED)
-            buttons.Add(CONTEXT_BUTTON_ACTIVATE, 843);    /* Activate */
-          else
-            buttons.Add(CONTEXT_BUTTON_ACTIVATE, 844);    /* Deactivate */
-        }
-
-        if (timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
-        {
-          buttons.Add(CONTEXT_BUTTON_EDIT_TIMER_RULE, 19243); /* Edit timer rule */
-          buttons.Add(CONTEXT_BUTTON_DELETE_TIMER_RULE, 19295); /* Delete timer rule */
-        }
-
-        if (timerType && !timerType->IsReadOnly() && timer->GetTimerRuleId() == PVR_TIMER_NO_PARENT)
-          buttons.Add(CONTEXT_BUTTON_EDIT_TIMER, 21450);  /* Edit */
-        else
-          buttons.Add(CONTEXT_BUTTON_EDIT_TIMER, 19241);  /* View timer information */
-
-        // As epg-based timers will get it's title from the epg tag, they should not be renamable.
-        if (timer->IsManual() && !timerType->IsReadOnly())
-          buttons.Add(CONTEXT_BUTTON_RENAME, 118);        /* Rename */
-
-        if (timer->IsRecording())
-          buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059); /* Stop recording */
-        else if (timerType && !timerType->IsReadOnly())
-            buttons.Add(CONTEXT_BUTTON_DELETE, 117);      /* Delete */
-      }
-
-      if (g_PVRClients->HasMenuHooks(timer->m_iClientId, PVR_MENUHOOK_TIMER))
-        buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);    /* PVR client specific action */
-    }
-  }
-
-  CGUIWindowPVRBase::GetContextButtons(itemNumber, buttons);
-}
-
 bool CGUIWindowPVRTimersBase::OnAction(const CAction &action)
 {
   if (action.GetID() == ACTION_PARENT_DIR ||
@@ -121,22 +62,25 @@ bool CGUIWindowPVRTimersBase::OnAction(const CAction &action)
   return CGUIWindowPVRBase::OnAction(action);
 }
 
-bool CGUIWindowPVRTimersBase::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+bool CGUIWindowPVRTimersBase::Update(const std::string &strDirectory, bool updateFilterPath /* = true */)
 {
-  if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
-    return false;
-  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
+  int iOldCount = m_vecItems->GetObjectCount();
+  const std::string oldPath = m_vecItems->GetPath();
 
-  return OnContextButtonActivate(pItem.get(), button) ||
-      OnContextButtonAdd(pItem.get(), button) ||
-      OnContextButtonDelete(pItem.get(), button) ||
-      OnContextButtonStopRecord(pItem.get(), button) ||
-      OnContextButtonEditTimer(pItem.get(), button) ||
-      OnContextButtonEditTimerRule(pItem.get(), button) ||
-      OnContextButtonDeleteTimerRule(pItem.get(), button) ||
-      OnContextButtonRename(pItem.get(), button) ||
-      OnContextButtonInfo(pItem.get(), button) ||
-      CGUIWindowPVRBase::OnContextButton(itemNumber, button);
+  bool bReturn = CGUIWindowPVRBase::Update(strDirectory);
+
+  if (bReturn && iOldCount > 0 && m_vecItems->GetObjectCount() == 0 && oldPath == m_vecItems->GetPath())
+  {
+    /* go to the parent folder if we're in a subdirectory and for instance just deleted the last item */
+    const CPVRTimersPath path(m_vecItems->GetPath());
+    if (path.IsValid() && path.IsTimerRule())
+    {
+      m_currentFileItem.reset();
+      GoParentFolder();
+    }
+  }
+
+  return bReturn;
 }
 
 void CGUIWindowPVRTimersBase::UpdateButtons(void)
@@ -182,7 +126,7 @@ bool CGUIWindowPVRTimersBase::OnMessage(CGUIMessage &message)
               else
               {
                 m_currentFileItem.reset();
-                ActionShowTimer(item.get());
+                ActionShowTimer(item);
               }
               break;
             }
@@ -191,7 +135,7 @@ bool CGUIWindowPVRTimersBase::OnMessage(CGUIMessage &message)
               OnPopupMenu(iItem);
               break;
             case ACTION_DELETE_ITEM:
-              ActionDeleteTimer(m_vecItems->Get(iItem).get());
+              CPVRGUIActions::GetInstance().DeleteTimer(m_vecItems->Get(iItem));
               break;
             default:
               bReturn = false;
@@ -230,114 +174,7 @@ bool CGUIWindowPVRTimersBase::OnMessage(CGUIMessage &message)
   return bReturn || CGUIWindowPVRBase::OnMessage(message);
 }
 
-bool CGUIWindowPVRTimersBase::OnContextButtonActivate(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_ACTIVATE)
-  {
-    bReturn = true;
-    if (!item->HasPVRTimerInfoTag())
-      return bReturn;
-
-    CPVRTimerInfoTagPtr timer = item->GetPVRTimerInfoTag();
-    if (timer->m_state == PVR_TIMER_STATE_DISABLED)
-      timer->m_state = PVR_TIMER_STATE_SCHEDULED;
-    else
-      timer->m_state = PVR_TIMER_STATE_DISABLED;
-
-    g_PVRTimers->UpdateTimer(timer);
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimersBase::OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_ADD)
-    bReturn = ShowNewTimerDialog();
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimersBase::OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_DELETE)
-  {
-    DeleteTimer(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimersBase::OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_STOP_RECORD)
-  {
-    StopRecordFile(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimersBase::OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_RENAME)
-  {
-    bReturn = true;
-    if (!item->HasPVRTimerInfoTag())
-      return bReturn;
-    CPVRTimerInfoTagPtr timer = item->GetPVRTimerInfoTag();
-
-    std::string strNewName(timer->m_strTitle);
-    if (CGUIKeyboardFactory::ShowAndGetInput(strNewName, CVariant{g_localizeStrings.Get(19042)}, false))
-      g_PVRTimers->RenameTimer(*item, strNewName);
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimersBase::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_INFO)
-  {
-    ShowEPGInfo(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimersBase::ActionDeleteTimer(CFileItem *item)
-{
-  bool bReturn = DeleteTimer(item);
-
-  if (bReturn && (m_vecItems->GetObjectCount() == 0))
-  {
-    /* go to the parent folder if we're in a subdirectory and just deleted the last item */
-    CPVRTimersPath path(m_vecItems->GetPath());
-    if (path.IsValid() && path.IsTimerRule())
-    {
-      m_currentFileItem.reset();
-      GoParentFolder();
-    }
-  }
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimersBase::ActionShowTimer(CFileItem *item)
+bool CGUIWindowPVRTimersBase::ActionShowTimer(const CFileItemPtr &item)
 {
   if (!g_PVRClients->SupportsTimers())
   {
@@ -347,32 +184,13 @@ bool CGUIWindowPVRTimersBase::ActionShowTimer(CFileItem *item)
 
   bool bReturn = false;
 
-  /* Check if "Add timer..." entry is pressed by OK, if yes
+  /* Check if "Add timer..." entry is selected, if yes
      create a new timer and open settings dialog, otherwise
      open settings for selected timer entry */
   if (URIUtils::PathEquals(item->GetPath(), CPVRTimersPath::PATH_ADDTIMER))
-  {
-    bReturn = ShowNewTimerDialog();
-  }
+    bReturn = CPVRGUIActions::GetInstance().AddTimer(m_bRadio);
   else
-  {
-    bReturn = EditTimer(item);
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimersBase::ShowNewTimerDialog(void)
-{
-  bool bReturn(false);
-
-  CPVRTimerInfoTagPtr newTimer(new CPVRTimerInfoTag(m_bRadio));
-
-  if (ShowTimerSettings(newTimer))
-  {
-    /* Add timer to backend */
-    bReturn = g_PVRTimers->AddTimer(newTimer);
-  }
+    bReturn = CPVRGUIActions::GetInstance().EditTimer(item);
 
   return bReturn;
 }
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimersBase.h b/xbmc/pvr/windows/GUIWindowPVRTimersBase.h
index b53fcf2..3add7be 100644
--- a/xbmc/pvr/windows/GUIWindowPVRTimersBase.h
+++ b/xbmc/pvr/windows/GUIWindowPVRTimersBase.h
@@ -36,21 +36,11 @@ namespace PVR
 
     bool OnMessage(CGUIMessage& message);
     bool OnAction(const CAction &action);
-    void GetContextButtons(int itemNumber, CContextButtons &buttons);
-    bool OnContextButton(int itemNumber, CONTEXT_BUTTON button);
+    bool Update(const std::string &strDirectory, bool updateFilterPath = true);
     void UpdateButtons(void);
 
   private:
-    bool ActionDeleteTimer(CFileItem *item);
-    bool ActionShowTimer(CFileItem *item);
-    bool ShowNewTimerDialog(void);
-
-    bool OnContextButtonActivate(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button);
+    bool ActionShowTimer(const CFileItemPtr &item);
 
     CFileItemPtr m_currentFileItem;
   };
