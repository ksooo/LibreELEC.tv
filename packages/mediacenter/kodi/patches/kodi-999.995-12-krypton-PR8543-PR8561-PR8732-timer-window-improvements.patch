diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index c688f8b..8dd5ba4 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -3600,11 +3600,7 @@ msgctxt "#841"
 msgid "Only this"
 msgstr ""
 
-#. Label of the option to switch between hierarchical and flat timer view (in confluence sideblade).
-#: skin.confluence
-msgctxt "#842"
-msgid "Group timers"
-msgstr ""
+#empty string with id 842
 
 #. Label for a context menu entry to activate a currently inactive timer
 #: xbmc/pvr/windows/GUIWindowPVRTimers.cpp
@@ -8764,7 +8760,11 @@ msgctxt "#19076"
 msgid "Folder"
 msgstr ""
 
-#empty string with id 19077
+#. Label of the option to hide disabled timers (in confluence sideblade) in timer window.
+#: skin.confluence
+msgctxt "#19077"
+msgid "Hide disabled"
+msgstr ""
 
 #. Label of channel selector list in PVR timer settings dialog
 #: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
@@ -9045,7 +9045,11 @@ msgctxt "#19137"
 msgid "No groups defined. Please create a group first"
 msgstr ""
 
-#empty string with id 19138
+#. Label of timer rules tv/radio home submenu item
+#: skin.confluence
+msgctxt "#19138"
+msgid "Timer rules"
+msgstr ""
 
 msgctxt "#19139"
 msgid "Name of the new group"
@@ -9560,7 +9564,17 @@ msgctxt "#19254"
 msgid "Guide update failed for channel"
 msgstr ""
 
-#empty strings from id 19255 to 19256
+#. for a timer rule, the number of child timers which are currently scheduled to record. For use in "status" fields.
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
+msgctxt "#19255"
+msgid "%d scheduled"
+msgstr ""
+
+#. for a timer rule or timer to indicate this item has completed the intended recordings. For use in "status" fields.
+#: xbmc/pvr/timers/PVRTimerInfoTag.cpp
+msgctxt "#19256"
+msgid "Completed"
+msgstr ""
 
 msgctxt "#19257"
 msgid "Lock channel"
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index b9c0500..ca079c1 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1639,9 +1639,9 @@
     </category>
     <category id="pvrtimers" label="" help="">
       <group id="1">
-        <setting id="pvrtimers.timertypefilter" type="boolean" label="" help="">
+        <setting id="pvrtimers.hidedisabledtimers" type="boolean" label="" help="">
+          <default>false</default>
           <level>4</level>
-          <default>true</default>
         </setting>
       </group>
     </category>
diff --git a/xbmc/guilib/GUIWindowManager.cpp b/xbmc/guilib/GUIWindowManager.cpp
index 89cfb8b..6472bee 100644
--- a/xbmc/guilib/GUIWindowManager.cpp
+++ b/xbmc/guilib/GUIWindowManager.cpp
@@ -120,6 +120,7 @@
 #include "pvr/windows/GUIWindowPVRRecordings.h"
 #include "pvr/windows/GUIWindowPVRGuide.h"
 #include "pvr/windows/GUIWindowPVRTimers.h"
+#include "pvr/windows/GUIWindowPVRTimerRules.h"
 #include "pvr/windows/GUIWindowPVRSearch.h"
 #include "pvr/dialogs/GUIDialogPVRChannelManager.h"
 #include "pvr/dialogs/GUIDialogPVRChannelsOSD.h"
@@ -250,11 +251,13 @@ void CGUIWindowManager::CreateWindows()
   Add(new CGUIWindowPVRRecordings(false));
   Add(new CGUIWindowPVRGuide(false));
   Add(new CGUIWindowPVRTimers(false));
+  Add(new CGUIWindowPVRTimerRules(false));
   Add(new CGUIWindowPVRSearch(false));
   Add(new CGUIWindowPVRChannels(true));
   Add(new CGUIWindowPVRRecordings(true));
   Add(new CGUIWindowPVRGuide(true));
   Add(new CGUIWindowPVRTimers(true));
+  Add(new CGUIWindowPVRTimerRules(true));
   Add(new CGUIDialogPVRRadioRDSInfo);
   Add(new CGUIWindowPVRSearch(true));
   Add(new CGUIDialogPVRGuideInfo);
@@ -342,11 +345,13 @@ bool CGUIWindowManager::DestroyWindows()
     Delete(WINDOW_TV_RECORDINGS);
     Delete(WINDOW_TV_GUIDE);
     Delete(WINDOW_TV_TIMERS);
+    Delete(WINDOW_TV_TIMER_RULES);
     Delete(WINDOW_TV_SEARCH);
     Delete(WINDOW_RADIO_CHANNELS);
     Delete(WINDOW_RADIO_RECORDINGS);
     Delete(WINDOW_RADIO_GUIDE);
     Delete(WINDOW_RADIO_TIMERS);
+    Delete(WINDOW_RADIO_TIMER_RULES);
     Delete(WINDOW_RADIO_SEARCH);
     Delete(WINDOW_DIALOG_PVR_GUIDE_INFO);
     Delete(WINDOW_DIALOG_PVR_RECORDING_INFO);
diff --git a/xbmc/guilib/WindowIDs.h b/xbmc/guilib/WindowIDs.h
index 58d6ddb..d50f24d 100644
--- a/xbmc/guilib/WindowIDs.h
+++ b/xbmc/guilib/WindowIDs.h
@@ -137,6 +137,8 @@
 #define WINDOW_RADIO_SEARCH               10624
 #define WINDOW_FULLSCREEN_RADIO           10625 // virtual window for PVR radio specific keymaps with fallback to WINDOW_VISUALISATION
 #define WINDOW_DIALOG_PVR_RADIO_RDS_INFO  10626
+#define WINDOW_TV_TIMER_RULES             10627
+#define WINDOW_RADIO_TIMER_RULES          10628
 
 //#define WINDOW_VIRTUAL_KEYBOARD           11000
 // WINDOW_ID's from 11100 to 11199 reserved for Skins
diff --git a/xbmc/input/ButtonTranslator.cpp b/xbmc/input/ButtonTranslator.cpp
index 0efbdda..a495d02 100644
--- a/xbmc/input/ButtonTranslator.cpp
+++ b/xbmc/input/ButtonTranslator.cpp
@@ -393,7 +393,9 @@ static const ActionMapping windows[] =
     { "extendedprogressdialog"   , WINDOW_DIALOG_EXT_PROGRESS },
     { "mediafilter"              , WINDOW_DIALOG_MEDIA_FILTER },
     { "addon"                    , WINDOW_ADDON_START },
-    { "eventlog"                 , WINDOW_EVENT_LOG}
+    { "eventlog"                 , WINDOW_EVENT_LOG},
+    { "tvtimerrules"             , WINDOW_TV_TIMER_RULES},
+    { "radiotimerrules"          , WINDOW_RADIO_TIMER_RULES}
 };
 
 static const ActionMapping mousekeys[] =
diff --git a/xbmc/pvr/PVRManager.cpp b/xbmc/pvr/PVRManager.cpp
index 9ceacf6..632f4a1 100644
--- a/xbmc/pvr/PVRManager.cpp
+++ b/xbmc/pvr/PVRManager.cpp
@@ -71,17 +71,19 @@ using namespace KODI::MESSAGING;
 
 using KODI::MESSAGING::HELPERS::DialogResponse;
 
-const int CPVRManager::m_pvrWindowIds[10] = {
+const int CPVRManager::m_pvrWindowIds[12] = {
     WINDOW_TV_CHANNELS,
     WINDOW_TV_GUIDE,
     WINDOW_TV_RECORDINGS,
     WINDOW_TV_SEARCH,
     WINDOW_TV_TIMERS,
+    WINDOW_TV_TIMER_RULES,
     WINDOW_RADIO_CHANNELS,
     WINDOW_RADIO_GUIDE,
     WINDOW_RADIO_RECORDINGS,
     WINDOW_RADIO_SEARCH,
-    WINDOW_RADIO_TIMERS
+    WINDOW_RADIO_TIMERS,
+    WINDOW_RADIO_TIMER_RULES
 };
 
 CPVRManager::CPVRManager(void) :
@@ -237,11 +239,13 @@ bool CPVRManager::IsPVRWindowActive(void) const
       g_windowManager.IsWindowActive(WINDOW_TV_GUIDE) ||
       g_windowManager.IsWindowActive(WINDOW_TV_RECORDINGS) ||
       g_windowManager.IsWindowActive(WINDOW_TV_TIMERS) ||
+      g_windowManager.IsWindowActive(WINDOW_TV_TIMER_RULES) ||
       g_windowManager.IsWindowActive(WINDOW_TV_SEARCH) ||
       g_windowManager.IsWindowActive(WINDOW_RADIO_CHANNELS) ||
       g_windowManager.IsWindowActive(WINDOW_RADIO_GUIDE) ||
       g_windowManager.IsWindowActive(WINDOW_RADIO_RECORDINGS) ||
       g_windowManager.IsWindowActive(WINDOW_RADIO_TIMERS) ||
+      g_windowManager.IsWindowActive(WINDOW_RADIO_TIMER_RULES) ||
       g_windowManager.IsWindowActive(WINDOW_RADIO_SEARCH) ||
       g_windowManager.IsWindowActive(WINDOW_DIALOG_PVR_CHANNEL_MANAGER) ||
       g_windowManager.IsWindowActive(WINDOW_DIALOG_PVR_OSD_CHANNELS) ||
@@ -260,11 +264,13 @@ bool CPVRManager::IsPVRWindow(int windowId)
           windowId == WINDOW_TV_RECORDINGS ||
           windowId == WINDOW_TV_SEARCH ||
           windowId == WINDOW_TV_TIMERS ||
+          windowId == WINDOW_TV_TIMER_RULES ||
           windowId == WINDOW_RADIO_CHANNELS ||
           windowId == WINDOW_RADIO_GUIDE ||
           windowId == WINDOW_RADIO_RECORDINGS ||
           windowId == WINDOW_RADIO_SEARCH ||
-          windowId == WINDOW_RADIO_TIMERS);
+          windowId == WINDOW_RADIO_TIMERS ||
+          windowId == WINDOW_RADIO_TIMER_RULES);
 }
 
 bool CPVRManager::InstallAddonAllowed(const std::string& strAddonId) const
diff --git a/xbmc/pvr/PVRManager.h b/xbmc/pvr/PVRManager.h
index 9020cc7..0239abd 100644
--- a/xbmc/pvr/PVRManager.h
+++ b/xbmc/pvr/PVRManager.h
@@ -686,7 +686,7 @@ namespace PVR
     ManagerState                    m_managerState;
     CStopWatch                     *m_parentalTimer;
     std::vector<std::string>        m_outdatedAddons;
-    static const int                m_pvrWindowIds[10];
+    static const int                m_pvrWindowIds[12];
   };
 
   class CPVREpgsCreateJob : public CJob
diff --git a/xbmc/pvr/timers/PVRTimerInfoTag.cpp b/xbmc/pvr/timers/PVRTimerInfoTag.cpp
index 576309e..3f713b8 100644
--- a/xbmc/pvr/timers/PVRTimerInfoTag.cpp
+++ b/xbmc/pvr/timers/PVRTimerInfoTag.cpp
@@ -69,6 +69,7 @@ CPVRTimerInfoTag::CPVRTimerInfoTag(bool bRadio /* = false */) :
   m_state               = PVR_TIMER_STATE_SCHEDULED;
   m_FirstDay.SetValid(false);
   m_iTimerId            = 0;
+  ResetChildState();
 
   if (g_PVRClients->SupportsTimers(m_iClientId))
   {
@@ -127,6 +128,7 @@ CPVRTimerInfoTag::CPVRTimerInfoTag(const PVR_TIMER &timer, const CPVRChannelPtr
   m_state               = timer.state;
   m_strFileNameAndPath  = StringUtils::Format("pvr://client%i/timers/%i", m_iClientId, m_iClientIndex);
   m_iTimerId            = 0;
+  ResetChildState();
 
   if (g_PVRClients->SupportsTimers(m_iClientId))
   {
@@ -207,7 +209,11 @@ bool CPVRTimerInfoTag::operator ==(const CPVRTimerInfoTag& right) const
           m_iMarginEnd          == right.m_iMarginEnd &&
           m_state               == right.m_state &&
           m_timerType           == right.m_timerType &&
-          m_iTimerId            == right.m_iTimerId);
+          m_iTimerId            == right.m_iTimerId &&
+          m_iActiveChildTimers  == right.m_iActiveChildTimers &&
+          m_bHasChildConflictNOK== right.m_bHasChildConflictNOK &&
+          m_bHasChildRecording  == right.m_bHasChildRecording &&
+          m_bHasChildErrors     == right.m_bHasChildErrors);
 }
 
 CPVRTimerInfoTag::~CPVRTimerInfoTag(void)
@@ -421,6 +427,22 @@ std::string CPVRTimerInfoTag::GetStatus() const
     strReturn = g_localizeStrings.Get(257);
   else if (m_state == PVR_TIMER_STATE_DISABLED)
     strReturn = g_localizeStrings.Get(13106);
+  else if (m_state == PVR_TIMER_STATE_COMPLETED)
+    if (m_bHasChildRecording)
+      strReturn = g_localizeStrings.Get(19162); // "Recording active"
+    else
+      strReturn = g_localizeStrings.Get(19256); // "Completed"
+  else if (m_state == PVR_TIMER_STATE_SCHEDULED || m_state == PVR_TIMER_STATE_NEW)
+  {
+    if (m_bHasChildRecording)
+      strReturn = g_localizeStrings.Get(19162); // "Recording active"
+    else if (m_bHasChildErrors)
+      strReturn = g_localizeStrings.Get(257);   // "Error"
+    else if (m_bHasChildConflictNOK)
+      strReturn = g_localizeStrings.Get(19276); // "Conflict error"
+    else if (m_iActiveChildTimers > 0)
+      strReturn = StringUtils::Format(g_localizeStrings.Get(19255).c_str(), m_iActiveChildTimers); // "%d scheduled"
+  }
 
   return strReturn;
 }
@@ -615,6 +637,46 @@ bool CPVRTimerInfoTag::UpdateEntry(const CPVRTimerInfoTagPtr &tag)
   return true;
 }
 
+bool CPVRTimerInfoTag::UpdateChildState(const CPVRTimerInfoTagPtr &childTimer)
+{
+  if (!childTimer || childTimer->m_iParentClientIndex != m_iClientIndex)
+    return false;
+
+  switch (childTimer->m_state)
+  {
+  case PVR_TIMER_STATE_NEW:
+  case PVR_TIMER_STATE_SCHEDULED:
+  case PVR_TIMER_STATE_CONFLICT_OK:
+    m_iActiveChildTimers++;
+    break;
+  case PVR_TIMER_STATE_RECORDING:
+    m_iActiveChildTimers++;
+    m_bHasChildRecording = true;
+    break;
+  case PVR_TIMER_STATE_CONFLICT_NOK:
+    m_bHasChildConflictNOK = true;
+    break;
+  case PVR_TIMER_STATE_ERROR:
+    m_bHasChildErrors = true;
+    break;
+  case PVR_TIMER_STATE_COMPLETED:
+  case PVR_TIMER_STATE_ABORTED:
+  case PVR_TIMER_STATE_CANCELLED:
+  case PVR_TIMER_STATE_DISABLED:
+    //these are not the child timers we are looking for
+    break;
+  }
+  return true;
+}
+
+void CPVRTimerInfoTag::ResetChildState()
+{
+  m_iActiveChildTimers = 0;
+  m_bHasChildConflictNOK = false;
+  m_bHasChildRecording = false;
+  m_bHasChildErrors = false;
+}
+
 bool CPVRTimerInfoTag::UpdateOnClient()
 {
   PVR_ERROR error = g_PVRClients->UpdateTimer(*this);
diff --git a/xbmc/pvr/timers/PVRTimerInfoTag.h b/xbmc/pvr/timers/PVRTimerInfoTag.h
index 89bdf31..5156a03 100644
--- a/xbmc/pvr/timers/PVRTimerInfoTag.h
+++ b/xbmc/pvr/timers/PVRTimerInfoTag.h
@@ -114,8 +114,23 @@ namespace PVR
     std::string ChannelIcon(void) const;
     CPVRChannelPtr ChannelTag(void) const;
 
+    /*!
+     * @brief updates this timer excluding the state of any children. See UpdateChildState/ResetChildState.
+     * @return true if the timer was updated successfully
+     */
     bool UpdateEntry(const CPVRTimerInfoTagPtr &tag);
 
+    /*!
+     * @brief merge in the state of this child timer. Run for each child after using ResetChildState.
+     * @return true if the child timer's state was merged successfully
+     */
+    bool UpdateChildState(const CPVRTimerInfoTagPtr &childTimer);
+
+    /*!
+     * @brief reset the state of children related to this timer. Run UpdateChildState for all children afterwards.
+     */
+    void ResetChildState();
+
     void UpdateEpgEvent(bool bClear = false);
 
     bool IsActive(void) const
@@ -274,5 +289,10 @@ namespace PVR
     CDateTime             m_StopTime;  /*!< stop time */
     CDateTime             m_FirstDay;  /*!< if it is a manual repeating timer the first date it starts */
     CPVRTimerTypePtr      m_timerType; /*!< the type of this timer */
+
+    unsigned int          m_iActiveChildTimers;   /*!< @brief Number of active timers which have this timer as their m_iParentClientIndex */
+    bool                  m_bHasChildConflictNOK; /*!< @brief Has at least one child timer with status PVR_TIMER_STATE_CONFLICT_NOK */
+    bool                  m_bHasChildRecording;   /*!< @brief Has at least one child timer with status PVR_TIMER_STATE_RECORDING */
+    bool                  m_bHasChildErrors;      /*!< @brief Has at least one child timer with status PVR_TIMER_STATE_ERROR */
   };
 }
diff --git a/xbmc/pvr/timers/PVRTimers.cpp b/xbmc/pvr/timers/PVRTimers.cpp
index 5c9ed15..96c1298 100644
--- a/xbmc/pvr/timers/PVRTimers.cpp
+++ b/xbmc/pvr/timers/PVRTimers.cpp
@@ -123,6 +123,7 @@ bool CPVRTimers::UpdateEntries(const CPVRTimers &timers)
         {
           bChanged = true;
           UpdateEpgEvent(existingTimer);
+          existingTimer->ResetChildState();
 
           if (bStateChanged && g_PVRManager.IsStarted())
           {
@@ -246,6 +247,21 @@ bool CPVRTimers::UpdateEntries(const CPVRTimers &timers)
     UpdateEpgEvent(*timerIt);
   }
 
+  /* update child information for all parent timers */
+  for (const auto &tagsEntry : m_tags)
+  {
+    for (const auto &timersEntry : *tagsEntry.second)
+    {
+      if (timersEntry->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
+      {
+        const CPVRTimerInfoTagPtr parentTimer(GetByClient(timersEntry->m_iClientId, timersEntry->GetTimerRuleId()));
+        if (parentTimer)
+          parentTimer->UpdateChildState(timersEntry);
+      }
+    }
+  }
+
+
   m_bIsUpdating = false;
   if (bChanged)
   {
@@ -406,8 +422,10 @@ bool CPVRTimers::GetRootDirectory(const CPVRTimersPath &path, CFileItemList &ite
   item->SetSpecialSort(SortSpecialOnTop);
   items.Add(item);
 
-  bool bRadio   = path.IsRadio();
-  bool bGrouped = path.IsGrouped();
+  bool bRadio = path.IsRadio();
+  bool bRules = path.IsRules();
+
+  bool bHideDisabled = CSettings::GetInstance().GetBool(CSettings::SETTING_PVRTIMERS_HIDEDISABLEDTIMERS);
 
   CSingleLock lock(m_critSection);
   for (const auto &tagsEntry : m_tags)
@@ -415,7 +433,8 @@ bool CPVRTimers::GetRootDirectory(const CPVRTimersPath &path, CFileItemList &ite
     for (const auto &timer : *tagsEntry.second)
     {
       if ((bRadio == timer->m_bIsRadio) &&
-          (!bGrouped || (timer->m_iParentClientIndex == PVR_TIMER_NO_PARENT)))
+          (bRules == timer->IsRepeating()) &&
+          (!bHideDisabled || (timer->m_state != PVR_TIMER_STATE_DISABLED)))
       {
         item.reset(new CFileItem(timer));
         std::string strItemPath(
@@ -434,6 +453,8 @@ bool CPVRTimers::GetSubDirectory(const CPVRTimersPath &path, CFileItemList &item
   unsigned int iParentId = path.GetParentId();
   int          iClientId = path.GetClientId();
 
+  bool bHideDisabled = CSettings::GetInstance().GetBool(CSettings::SETTING_PVRTIMERS_HIDEDISABLEDTIMERS);
+
   CFileItemPtr item;
 
   CSingleLock lock(m_critSection);
@@ -444,7 +465,8 @@ bool CPVRTimers::GetSubDirectory(const CPVRTimersPath &path, CFileItemList &item
       if ((timer->m_bIsRadio == bRadio) &&
           (timer->m_iParentClientIndex != PVR_TIMER_NO_PARENT) &&
           (timer->m_iClientId == iClientId) &&
-          (timer->m_iParentClientIndex == iParentId))
+          (timer->m_iParentClientIndex == iParentId) &&
+          (!bHideDisabled || (timer->m_state != PVR_TIMER_STATE_DISABLED)))
       {
         item.reset(new CFileItem(timer));
         std::string strItemPath(
@@ -853,8 +875,8 @@ CPVRTimersPath::CPVRTimersPath(const std::string &strPath, int iClientId, unsign
   {
     /* set/replace client and parent id. */
     m_path = StringUtils::Format("pvr://timers/%s/%s/%d/%d",
-                                 m_bRadio   ? "radio"   : "tv",
-                                 m_bGrouped ? "grouped" : "all",
+                                 m_bRadio      ? "radio" : "tv",
+                                 m_bTimerRules ? "rules" : "timers",
                                  iClientId,
                                  iParentId);
     m_iClientId = iClientId;
@@ -863,13 +885,13 @@ CPVRTimersPath::CPVRTimersPath(const std::string &strPath, int iClientId, unsign
   }
 }
 
-CPVRTimersPath::CPVRTimersPath(bool bRadio, bool bGrouped) :
+CPVRTimersPath::CPVRTimersPath(bool bRadio, bool bTimerRules) :
   m_path(StringUtils::Format(
-    "pvr://timers/%s/%s", bRadio ? "radio" : "tv", bGrouped ? "grouped" : "all")),
+    "pvr://timers/%s/%s", bRadio ? "radio" : "tv", bTimerRules ? "rules" : "timers")),
   m_bValid(true),
   m_bRoot(true),
   m_bRadio(bRadio),
-  m_bGrouped(bGrouped),
+  m_bTimerRules(bTimerRules),
   m_iClientId(-1),
   m_iParentId(0)
 {
@@ -886,10 +908,10 @@ bool CPVRTimersPath::Init(const std::string &strPath)
   m_bValid   = (((segments.size() == 4) || (segments.size() == 6)) &&
                 (segments.at(1) == "timers") &&
                 ((segments.at(2) == "radio") || (segments.at(2) == "tv"))&&
-                ((segments.at(3) == "grouped") || (segments.at(3) == "all")));
+                ((segments.at(3) == "rules") || (segments.at(3) == "timers")));
   m_bRoot    = (m_bValid && (segments.size() == 4));
   m_bRadio   = (m_bValid && (segments.at(2) == "radio"));
-  m_bGrouped = (m_bValid && (segments.at(3) == "grouped"));
+  m_bTimerRules = (m_bValid && (segments.at(3) == "rules"));
 
   if (!m_bValid || m_bRoot)
   {
diff --git a/xbmc/pvr/timers/PVRTimers.h b/xbmc/pvr/timers/PVRTimers.h
index 7ba8418..03dd88d 100644
--- a/xbmc/pvr/timers/PVRTimers.h
+++ b/xbmc/pvr/timers/PVRTimers.h
@@ -211,7 +211,7 @@ namespace PVR
 
     CPVRTimersPath(const std::string &strPath);
     CPVRTimersPath(const std::string &strPath, int iClientId, unsigned int iParentId);
-    CPVRTimersPath(bool bRadio, bool bGrouped);
+    CPVRTimersPath(bool bRadio, bool bTimerRules);
 
     bool IsValid() const { return m_bValid; }
 
@@ -219,7 +219,7 @@ namespace PVR
     bool              IsTimersRoot() const    { return m_bRoot; }
     bool              IsTimerSchedule() const { return !IsTimersRoot(); }
     bool              IsRadio() const         { return m_bRadio; }
-    bool              IsGrouped() const       { return m_bGrouped; }
+    bool              IsRules() const         { return m_bTimerRules; }
     int               GetClientId() const     { return m_iClientId; }
     unsigned int      GetParentId() const     { return m_iParentId; }
 
@@ -230,7 +230,7 @@ namespace PVR
     bool         m_bValid;
     bool         m_bRoot;
     bool         m_bRadio;
-    bool         m_bGrouped;
+    bool         m_bTimerRules;
     int          m_iClientId;
     unsigned int m_iParentId;
   };
diff --git a/xbmc/pvr/windows/GUIWindowPVRBase.h b/xbmc/pvr/windows/GUIWindowPVRBase.h
index 612ca87..6ec0301 100644
--- a/xbmc/pvr/windows/GUIWindowPVRBase.h
+++ b/xbmc/pvr/windows/GUIWindowPVRBase.h
@@ -28,7 +28,7 @@
 #define CONTROL_BTNGROUPITEMS             5
 #define CONTROL_BTNSHOWHIDDEN             6
 #define CONTROL_BTNSHOWDELETED            7
-#define CONTROL_BTNTIMERTYPEFILTER        8
+#define CONTROL_BTNHIDEDISABLEDTIMERS     8
 #define CONTROL_BTNCHANNELGROUPS          28
 #define CONTROL_BTNFILTERCHANNELS         31
 
@@ -84,7 +84,7 @@ namespace PVR
   protected:
     CGUIWindowPVRBase(bool bRadio, int id, const std::string &xmlFile);
 
-    virtual std::string GetDirectoryPath(void) { return ""; };
+    virtual std::string GetDirectoryPath(void) = 0;
     virtual CPVRChannelGroupPtr GetGroup(void);
     virtual void SetGroup(CPVRChannelGroupPtr group);
 
diff --git a/xbmc/pvr/windows/GUIWindowPVRGuide.h b/xbmc/pvr/windows/GUIWindowPVRGuide.h
index d06b636..8711a5a 100644
--- a/xbmc/pvr/windows/GUIWindowPVRGuide.h
+++ b/xbmc/pvr/windows/GUIWindowPVRGuide.h
@@ -45,6 +45,7 @@ namespace PVR
 
   protected:
     void UpdateSelectedItemPath();
+    virtual std::string GetDirectoryPath(void) { return ""; }
     virtual bool GetDirectory(const std::string &strDirectory, CFileItemList &items);
 
   private:
diff --git a/xbmc/pvr/windows/GUIWindowPVRSearch.h b/xbmc/pvr/windows/GUIWindowPVRSearch.h
index a7bd311..d657735 100644
--- a/xbmc/pvr/windows/GUIWindowPVRSearch.h
+++ b/xbmc/pvr/windows/GUIWindowPVRSearch.h
@@ -38,6 +38,7 @@ namespace PVR
 
   protected:
     void OnPrepareFileItems(CFileItemList &items);
+    virtual std::string GetDirectoryPath(void) { return ""; }
 
   private:
     bool OnContextButtonClear(CFileItem *item, CONTEXT_BUTTON button);
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimerRules.cpp b/xbmc/pvr/windows/GUIWindowPVRTimerRules.cpp
new file mode 100644
index 0000000..6f90614
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVRTimerRules.cpp
@@ -0,0 +1,37 @@
+/*
+ *      Copyright (C) 2012-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "utils/StringUtils.h"
+#include "pvr/timers/PVRTimers.h"
+
+#include "GUIWindowPVRTimerRules.h"
+
+using namespace PVR;
+
+CGUIWindowPVRTimerRules::CGUIWindowPVRTimerRules(bool bRadio) :
+  CGUIWindowPVRTimersBase(bRadio, bRadio ? WINDOW_RADIO_TIMER_RULES : WINDOW_TV_TIMER_RULES, "MyPVRTimers.xml")
+{
+}
+
+std::string CGUIWindowPVRTimerRules::GetDirectoryPath(void)
+{
+  const std::string basePath(CPVRTimersPath(m_bRadio, true).GetPath());
+  return StringUtils::StartsWith(m_vecItems->GetPath(), basePath) ? m_vecItems->GetPath() : basePath;
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimerRules.h b/xbmc/pvr/windows/GUIWindowPVRTimerRules.h
new file mode 100644
index 0000000..650d6c2
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVRTimerRules.h
@@ -0,0 +1,37 @@
+#pragma once
+/*
+ *      Copyright (C) 2012-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GUIWindowPVRTimersBase.h"
+
+#include <string>
+
+namespace PVR
+{
+  class CGUIWindowPVRTimerRules : public CGUIWindowPVRTimersBase
+  {
+  public:
+    CGUIWindowPVRTimerRules(bool bRadio);
+    virtual ~CGUIWindowPVRTimerRules(void) {};
+
+  protected:
+    virtual std::string GetDirectoryPath(void);
+  };
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimers.cpp b/xbmc/pvr/windows/GUIWindowPVRTimers.cpp
index 8c7093e..1765d34 100644
--- a/xbmc/pvr/windows/GUIWindowPVRTimers.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRTimers.cpp
@@ -18,406 +18,20 @@
  *
  */
 
-#include "ContextMenuManager.h"
-#include "GUIInfoManager.h"
-#include "dialogs/GUIDialogOK.h"
-#include "dialogs/GUIDialogYesNo.h"
-#include "guilib/GUIKeyboardFactory.h"
-#include "guilib/GUIWindowManager.h"
-#include "input/Key.h"
-#include "settings/Settings.h"
-#include "threads/SingleLock.h"
 #include "utils/StringUtils.h"
-#include "utils/Variant.h"
-
-#include "pvr/PVRManager.h"
-#include "pvr/dialogs/GUIDialogPVRTimerSettings.h"
 #include "pvr/timers/PVRTimers.h"
-#include "pvr/addons/PVRClients.h"
 
 #include "GUIWindowPVRTimers.h"
 
 using namespace PVR;
 
 CGUIWindowPVRTimers::CGUIWindowPVRTimers(bool bRadio) :
-  CGUIWindowPVRBase(bRadio, bRadio ? WINDOW_RADIO_TIMERS : WINDOW_TV_TIMERS, "MyPVRTimers.xml")
-{
-}
-
-void CGUIWindowPVRTimers::UnregisterObservers(void)
-{
-  CSingleLock lock(m_critSection);
-  if (g_PVRTimers)
-    g_PVRTimers->UnregisterObserver(this);
-  g_infoManager.UnregisterObserver(this);
-}
-
-void CGUIWindowPVRTimers::ResetObservers(void)
+  CGUIWindowPVRTimersBase(bRadio, bRadio ? WINDOW_RADIO_TIMERS : WINDOW_TV_TIMERS, "MyPVRTimers.xml")
 {
-  CSingleLock lock(m_critSection);
-  UnregisterObservers();
-  g_PVRTimers->RegisterObserver(this);
-  g_infoManager.RegisterObserver(this);
 }
 
 std::string CGUIWindowPVRTimers::GetDirectoryPath(void)
 {
-  const std::string basePath(
-    CPVRTimersPath(m_bRadio, CSettings::GetInstance().GetBool(CSettings::SETTING_PVRTIMERS_TIMERTYPEFILTER)).GetPath());
+  const std::string basePath(CPVRTimersPath(m_bRadio, false).GetPath());
   return StringUtils::StartsWith(m_vecItems->GetPath(), basePath) ? m_vecItems->GetPath() : basePath;
 }
-
-void CGUIWindowPVRTimers::GetContextButtons(int itemNumber, CContextButtons &buttons)
-{
-  if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
-    return;
-  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
-
-  if (!URIUtils::PathEquals(pItem->GetPath(), CPVRTimersPath::PATH_ADDTIMER))
-  {
-    CPVRTimerInfoTagPtr timer(pItem->GetPVRTimerInfoTag());
-    if (timer)
-    {
-      if (timer->HasEpgInfoTag())
-        buttons.Add(CONTEXT_BUTTON_INFO, 19047);          /* Programme information */
-
-      CPVRTimerTypePtr timerType(timer->GetTimerType());
-      if (timerType)
-      {
-        if (timerType->SupportsEnableDisable())
-        {
-          if (timer->m_state == PVR_TIMER_STATE_DISABLED)
-            buttons.Add(CONTEXT_BUTTON_ACTIVATE, 843);    /* Activate */
-          else
-            buttons.Add(CONTEXT_BUTTON_ACTIVATE, 844);    /* Deactivate */
-        }
-
-        if (!timerType->IsReadOnly())
-        {
-          buttons.Add(CONTEXT_BUTTON_EDIT, 21450);        /* Edit */
-
-          // As epg-based timers will get it's title from the epg tag, they should not be renamable.
-          if (timer->IsManual())
-            buttons.Add(CONTEXT_BUTTON_RENAME, 118);      /* Rename */
-
-          if (timer->IsRecording())
-            buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059); /* Stop recording */
-          else
-            buttons.Add(CONTEXT_BUTTON_DELETE, 117);        /* Delete */
-        }
-      }
-
-      if (g_PVRClients->HasMenuHooks(timer->m_iClientId, PVR_MENUHOOK_TIMER))
-        buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);    /* PVR client specific action */
-    }
-  }
-
-  CGUIWindowPVRBase::GetContextButtons(itemNumber, buttons);
-  CContextMenuManager::GetInstance().AddVisibleItems(pItem, buttons);
-}
-
-bool CGUIWindowPVRTimers::OnAction(const CAction &action)
-{
-  if (action.GetID() == ACTION_PARENT_DIR ||
-      action.GetID() == ACTION_NAV_BACK)
-  {
-    CPVRTimersPath path(m_vecItems->GetPath());
-    if (path.IsValid() && path.IsTimerSchedule())
-    {
-      m_currentFileItem.reset();
-      GoParentFolder();
-      return true;
-    }
-  }
-  return CGUIWindowPVRBase::OnAction(action);
-}
-
-bool CGUIWindowPVRTimers::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
-{
-  if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
-    return false;
-  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
-
-  return OnContextButtonActivate(pItem.get(), button) ||
-      OnContextButtonAdd(pItem.get(), button) ||
-      OnContextButtonDelete(pItem.get(), button) ||
-      OnContextButtonStopRecord(pItem.get(), button) ||
-      OnContextButtonEdit(pItem.get(), button) ||
-      OnContextButtonRename(pItem.get(), button) ||
-      OnContextButtonInfo(pItem.get(), button) ||
-      CGUIWindowPVRBase::OnContextButton(itemNumber, button);
-}
-
-bool CGUIWindowPVRTimers::Update(const std::string &strDirectory, bool updateFilterPath /* = true */)
-{
-  return CGUIWindowPVRBase::Update(strDirectory);
-}
-
-void CGUIWindowPVRTimers::UpdateButtons(void)
-{
-  SET_CONTROL_SELECTED(GetID(), CONTROL_BTNTIMERTYPEFILTER, CSettings::GetInstance().GetBool(CSettings::SETTING_PVRTIMERS_TIMERTYPEFILTER));
-
-  CGUIWindowPVRBase::UpdateButtons();
-
-  std::string strHeaderTitle;
-  if (m_currentFileItem && m_currentFileItem->HasPVRTimerInfoTag())
-  {
-    CPVRTimerInfoTagPtr timer = m_currentFileItem->GetPVRTimerInfoTag();
-    strHeaderTitle = timer->Title();
-  }
-
-  SET_CONTROL_LABEL(CONTROL_LABEL_HEADER1, strHeaderTitle);
-}
-
-bool CGUIWindowPVRTimers::OnMessage(CGUIMessage &message)
-{
-  if (!IsValidMessage(message))
-    return false;
-  
-  bool bReturn = false;
-  switch (message.GetMessage())
-  {
-    case GUI_MSG_CLICKED:
-      if (message.GetSenderId() == m_viewControl.GetCurrentControl())
-      {
-        int iItem = m_viewControl.GetSelectedItem();
-        if (iItem >= 0 && iItem < m_vecItems->Size())
-        {
-          bReturn = true;
-          switch (message.GetParam1())
-          {
-            case ACTION_SHOW_INFO:
-            case ACTION_SELECT_ITEM:
-            case ACTION_MOUSE_LEFT_CLICK:
-            {
-              CFileItemPtr item(m_vecItems->Get(iItem));
-              if (item->m_bIsFolder && (message.GetParam1() != ACTION_SHOW_INFO))
-              {
-                m_currentFileItem = item;
-                bReturn = false; // folders are handled by base class
-              }
-              else
-              {
-                m_currentFileItem.reset();
-                ActionShowTimer(item.get());
-              }
-              break;
-            }
-            case ACTION_CONTEXT_MENU:
-            case ACTION_MOUSE_RIGHT_CLICK:
-              OnPopupMenu(iItem);
-              break;
-            case ACTION_DELETE_ITEM:
-              ActionDeleteTimer(m_vecItems->Get(iItem).get());
-              break;
-            default:
-              bReturn = false;
-              break;
-          }
-        }
-      }
-      else if (message.GetSenderId() == CONTROL_BTNTIMERTYPEFILTER)
-      {
-        CSettings::GetInstance().ToggleBool(CSettings::SETTING_PVRTIMERS_TIMERTYPEFILTER);
-        CSettings::GetInstance().Save();
-        Update(GetDirectoryPath());
-        bReturn = true;
-      }
-      break;
-    case GUI_MSG_REFRESH_LIST:
-      switch(message.GetParam1())
-      {
-        case ObservableMessageTimers:
-        case ObservableMessageEpg:
-        case ObservableMessageEpgContainer:
-        case ObservableMessageEpgActiveItem:
-        case ObservableMessageCurrentItem:
-        {
-          if (IsActive())
-            SetInvalid();
-          bReturn = true;
-          break;
-        }
-        case ObservableMessageTimersReset:
-        {
-          if (IsActive())
-            Refresh(true);
-          bReturn = true;
-          break;
-        }
-      }
-  }
-
-  return bReturn || CGUIWindowPVRBase::OnMessage(message);
-}
-
-bool CGUIWindowPVRTimers::OnContextButtonActivate(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_ACTIVATE)
-  {
-    bReturn = true;
-    if (!item->HasPVRTimerInfoTag())
-      return bReturn;
-
-    CPVRTimerInfoTagPtr timer = item->GetPVRTimerInfoTag();
-    if (timer->m_state == PVR_TIMER_STATE_DISABLED)
-      timer->m_state = PVR_TIMER_STATE_SCHEDULED;
-    else
-      timer->m_state = PVR_TIMER_STATE_DISABLED;
-
-    g_PVRTimers->UpdateTimer(*item);
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimers::OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_ADD)
-    bReturn = ShowNewTimerDialog();
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimers::OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_DELETE)
-  {
-    DeleteTimer(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimers::OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_STOP_RECORD)
-  {
-    StopRecordFile(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimers::OnContextButtonEdit(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_EDIT)
-  {
-    bReturn = true;
-    if (!item->HasPVRTimerInfoTag())
-      return bReturn;
-
-    if (ShowTimerSettings(item) && !item->GetPVRTimerInfoTag()->GetTimerType()->IsReadOnly())
-      g_PVRTimers->UpdateTimer(*item);
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimers::OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_RENAME)
-  {
-    bReturn = true;
-    if (!item->HasPVRTimerInfoTag())
-      return bReturn;
-    CPVRTimerInfoTagPtr timer = item->GetPVRTimerInfoTag();
-
-    std::string strNewName(timer->m_strTitle);
-    if (CGUIKeyboardFactory::ShowAndGetInput(strNewName, CVariant{g_localizeStrings.Get(19042)}, false))
-      g_PVRTimers->RenameTimer(*item, strNewName);
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimers::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_INFO)
-  {
-    ShowEPGInfo(item);
-    bReturn = true;
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimers::ActionDeleteTimer(CFileItem *item)
-{
-  bool bReturn = DeleteTimer(item);
-
-  if (bReturn && (m_vecItems->GetObjectCount() == 0))
-  {
-    /* go to the parent folder if we're in a subdirectory and just deleted the last item */
-    CPVRTimersPath path(m_vecItems->GetPath());
-    if (path.IsValid() && path.IsTimerSchedule())
-    {
-      m_currentFileItem.reset();
-      GoParentFolder();
-    }
-  }
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimers::ActionShowTimer(CFileItem *item)
-{
-  if (!g_PVRClients->SupportsTimers())
-  {
-    CGUIDialogOK::ShowAndGetInput(CVariant{19033}, CVariant{19215}); // "Information", "The PVR backend does not support timers."
-    return false;
-  }
-
-  bool bReturn = false;
-
-  /* Check if "Add timer..." entry is pressed by OK, if yes
-     create a new timer and open settings dialog, otherwise
-     open settings for selected timer entry */
-  if (URIUtils::PathEquals(item->GetPath(), CPVRTimersPath::PATH_ADDTIMER))
-  {
-    bReturn = ShowNewTimerDialog();
-  }
-  else
-  {
-    if (ShowTimerSettings(item) && !item->GetPVRTimerInfoTag()->GetTimerType()->IsReadOnly())
-    {
-      /* Update timer on pvr backend */
-      bReturn = g_PVRTimers->UpdateTimer(*item);
-    }
-  }
-
-  return bReturn;
-}
-
-bool CGUIWindowPVRTimers::ShowNewTimerDialog(void)
-{
-  bool bReturn(false);
-
-  CPVRTimerInfoTagPtr newTimer(new CPVRTimerInfoTag(m_bRadio));
-  CFileItem *newItem = new CFileItem(newTimer);
-
-  if (ShowTimerSettings(newItem))
-  {
-    /* Add timer to backend */
-    bReturn = g_PVRTimers->AddTimer(newItem->GetPVRTimerInfoTag());
-  }
-
-  delete newItem;
-
-  return bReturn;
-}
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimers.h b/xbmc/pvr/windows/GUIWindowPVRTimers.h
index e6dbd8a..a307246 100644
--- a/xbmc/pvr/windows/GUIWindowPVRTimers.h
+++ b/xbmc/pvr/windows/GUIWindowPVRTimers.h
@@ -19,46 +19,19 @@
  *
  */
 
-#include "GUIWindowPVRBase.h"
+#include "GUIWindowPVRTimersBase.h"
 
-#include <memory>
-
-class CFileItem;
-typedef std::shared_ptr<CFileItem> CFileItemPtr;
+#include <string>
 
 namespace PVR
 {
-  class CGUIWindowPVRTimers : public CGUIWindowPVRBase
+  class CGUIWindowPVRTimers : public CGUIWindowPVRTimersBase
   {
   public:
     CGUIWindowPVRTimers(bool bRadio);
     virtual ~CGUIWindowPVRTimers(void) {};
 
-    bool OnMessage(CGUIMessage& message);
-    bool OnAction(const CAction &action);
-    void GetContextButtons(int itemNumber, CContextButtons &buttons);
-    bool OnContextButton(int itemNumber, CONTEXT_BUTTON button);
-    bool Update(const std::string &strDirectory, bool updateFilterPath = true);
-    void UpdateButtons(void);
-    void UnregisterObservers(void);
-    void ResetObservers(void);
-
   protected:
-    std::string GetDirectoryPath(void);
-
-  private:
-    bool ActionDeleteTimer(CFileItem *item);
-    bool ActionShowTimer(CFileItem *item);
-    bool ShowNewTimerDialog(void);
-
-    bool OnContextButtonActivate(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonEdit(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button);
-
-    CFileItemPtr m_currentFileItem;
+    virtual std::string GetDirectoryPath(void);
   };
 }
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp b/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
new file mode 100644
index 0000000..026332b
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
@@ -0,0 +1,410 @@
+/*
+ *      Copyright (C) 2012-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "ContextMenuManager.h"
+#include "GUIInfoManager.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "guilib/GUIKeyboardFactory.h"
+#include "guilib/GUIWindowManager.h"
+#include "input/Key.h"
+#include "settings/Settings.h"
+#include "threads/SingleLock.h"
+#include "utils/StringUtils.h"
+#include "utils/Variant.h"
+
+#include "pvr/PVRManager.h"
+#include "pvr/dialogs/GUIDialogPVRTimerSettings.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/addons/PVRClients.h"
+
+#include "GUIWindowPVRTimers.h"
+
+using namespace PVR;
+
+CGUIWindowPVRTimersBase::CGUIWindowPVRTimersBase(bool bRadio, int id, const std::string &xmlFile) :
+  CGUIWindowPVRBase(bRadio, id, xmlFile)
+{
+}
+
+void CGUIWindowPVRTimersBase::UnregisterObservers(void)
+{
+  CSingleLock lock(m_critSection);
+  if (g_PVRTimers)
+    g_PVRTimers->UnregisterObserver(this);
+  g_infoManager.UnregisterObserver(this);
+}
+
+void CGUIWindowPVRTimersBase::ResetObservers(void)
+{
+  CSingleLock lock(m_critSection);
+  UnregisterObservers();
+  g_PVRTimers->RegisterObserver(this);
+  g_infoManager.RegisterObserver(this);
+}
+
+void CGUIWindowPVRTimersBase::GetContextButtons(int itemNumber, CContextButtons &buttons)
+{
+  if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
+    return;
+  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
+
+  if (!URIUtils::PathEquals(pItem->GetPath(), CPVRTimersPath::PATH_ADDTIMER))
+  {
+    CPVRTimerInfoTagPtr timer(pItem->GetPVRTimerInfoTag());
+    if (timer)
+    {
+      if (timer->HasEpgInfoTag())
+        buttons.Add(CONTEXT_BUTTON_INFO, 19047);          /* Programme information */
+
+      CPVRTimerTypePtr timerType(timer->GetTimerType());
+      if (timerType)
+      {
+        if (timerType->SupportsEnableDisable())
+        {
+          if (timer->m_state == PVR_TIMER_STATE_DISABLED)
+            buttons.Add(CONTEXT_BUTTON_ACTIVATE, 843);    /* Activate */
+          else
+            buttons.Add(CONTEXT_BUTTON_ACTIVATE, 844);    /* Deactivate */
+        }
+
+        if (!timerType->IsReadOnly())
+        {
+          buttons.Add(CONTEXT_BUTTON_EDIT, 21450);        /* Edit */
+
+          // As epg-based timers will get it's title from the epg tag, they should not be renamable.
+          if (timer->IsManual())
+            buttons.Add(CONTEXT_BUTTON_RENAME, 118);      /* Rename */
+
+          if (timer->IsRecording())
+            buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059); /* Stop recording */
+          else
+            buttons.Add(CONTEXT_BUTTON_DELETE, 117);        /* Delete */
+        }
+      }
+
+      if (g_PVRClients->HasMenuHooks(timer->m_iClientId, PVR_MENUHOOK_TIMER))
+        buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);    /* PVR client specific action */
+    }
+  }
+
+  CGUIWindowPVRBase::GetContextButtons(itemNumber, buttons);
+  CContextMenuManager::GetInstance().AddVisibleItems(pItem, buttons);
+}
+
+bool CGUIWindowPVRTimersBase::OnAction(const CAction &action)
+{
+  if (action.GetID() == ACTION_PARENT_DIR ||
+      action.GetID() == ACTION_NAV_BACK)
+  {
+    CPVRTimersPath path(m_vecItems->GetPath());
+    if (path.IsValid() && path.IsTimerSchedule())
+    {
+      m_currentFileItem.reset();
+      GoParentFolder();
+      return true;
+    }
+  }
+  return CGUIWindowPVRBase::OnAction(action);
+}
+
+bool CGUIWindowPVRTimersBase::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
+    return false;
+  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
+
+  return OnContextButtonActivate(pItem.get(), button) ||
+      OnContextButtonAdd(pItem.get(), button) ||
+      OnContextButtonDelete(pItem.get(), button) ||
+      OnContextButtonStopRecord(pItem.get(), button) ||
+      OnContextButtonEdit(pItem.get(), button) ||
+      OnContextButtonRename(pItem.get(), button) ||
+      OnContextButtonInfo(pItem.get(), button) ||
+      CGUIWindowPVRBase::OnContextButton(itemNumber, button);
+}
+
+bool CGUIWindowPVRTimersBase::Update(const std::string &strDirectory, bool updateFilterPath /* = true */)
+{
+  return CGUIWindowPVRBase::Update(strDirectory);
+}
+
+void CGUIWindowPVRTimersBase::UpdateButtons(void)
+{
+  SET_CONTROL_SELECTED(GetID(), CONTROL_BTNHIDEDISABLEDTIMERS, CSettings::GetInstance().GetBool(CSettings::SETTING_PVRTIMERS_HIDEDISABLEDTIMERS));
+
+  CGUIWindowPVRBase::UpdateButtons();
+
+  std::string strHeaderTitle;
+  if (m_currentFileItem && m_currentFileItem->HasPVRTimerInfoTag())
+  {
+    CPVRTimerInfoTagPtr timer = m_currentFileItem->GetPVRTimerInfoTag();
+    strHeaderTitle = timer->Title();
+  }
+
+  SET_CONTROL_LABEL(CONTROL_LABEL_HEADER1, strHeaderTitle);
+}
+
+bool CGUIWindowPVRTimersBase::OnMessage(CGUIMessage &message)
+{
+  if (!IsValidMessage(message))
+    return false;
+  
+  bool bReturn = false;
+  switch (message.GetMessage())
+  {
+    case GUI_MSG_CLICKED:
+      if (message.GetSenderId() == m_viewControl.GetCurrentControl())
+      {
+        int iItem = m_viewControl.GetSelectedItem();
+        if (iItem >= 0 && iItem < m_vecItems->Size())
+        {
+          bReturn = true;
+          switch (message.GetParam1())
+          {
+            case ACTION_SHOW_INFO:
+            case ACTION_SELECT_ITEM:
+            case ACTION_MOUSE_LEFT_CLICK:
+            {
+              CFileItemPtr item(m_vecItems->Get(iItem));
+              if (item->m_bIsFolder && (message.GetParam1() != ACTION_SHOW_INFO))
+              {
+                m_currentFileItem = item;
+                bReturn = false; // folders are handled by base class
+              }
+              else
+              {
+                m_currentFileItem.reset();
+                ActionShowTimer(item.get());
+              }
+              break;
+            }
+            case ACTION_CONTEXT_MENU:
+            case ACTION_MOUSE_RIGHT_CLICK:
+              OnPopupMenu(iItem);
+              break;
+            case ACTION_DELETE_ITEM:
+              ActionDeleteTimer(m_vecItems->Get(iItem).get());
+              break;
+            default:
+              bReturn = false;
+              break;
+          }
+        }
+      }
+      else if (message.GetSenderId() == CONTROL_BTNHIDEDISABLEDTIMERS)
+      {
+        CSettings::GetInstance().ToggleBool(CSettings::SETTING_PVRTIMERS_HIDEDISABLEDTIMERS);
+        CSettings::GetInstance().Save();
+        Update(GetDirectoryPath());
+        bReturn = true;
+      }
+      break;
+    case GUI_MSG_REFRESH_LIST:
+      switch(message.GetParam1())
+      {
+        case ObservableMessageTimers:
+        case ObservableMessageEpg:
+        case ObservableMessageEpgContainer:
+        case ObservableMessageEpgActiveItem:
+        case ObservableMessageCurrentItem:
+        {
+          if (IsActive())
+            SetInvalid();
+          bReturn = true;
+          break;
+        }
+        case ObservableMessageTimersReset:
+        {
+          if (IsActive())
+            Refresh(true);
+          bReturn = true;
+          break;
+        }
+      }
+  }
+
+  return bReturn || CGUIWindowPVRBase::OnMessage(message);
+}
+
+bool CGUIWindowPVRTimersBase::OnContextButtonActivate(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_ACTIVATE)
+  {
+    bReturn = true;
+    if (!item->HasPVRTimerInfoTag())
+      return bReturn;
+
+    CPVRTimerInfoTagPtr timer = item->GetPVRTimerInfoTag();
+    if (timer->m_state == PVR_TIMER_STATE_DISABLED)
+      timer->m_state = PVR_TIMER_STATE_SCHEDULED;
+    else
+      timer->m_state = PVR_TIMER_STATE_DISABLED;
+
+    g_PVRTimers->UpdateTimer(*item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimersBase::OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_ADD)
+    bReturn = ShowNewTimerDialog();
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimersBase::OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_DELETE)
+  {
+    DeleteTimer(item);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimersBase::OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_STOP_RECORD)
+  {
+    StopRecordFile(item);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimersBase::OnContextButtonEdit(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_EDIT)
+  {
+    bReturn = true;
+    if (!item->HasPVRTimerInfoTag())
+      return bReturn;
+
+    if (ShowTimerSettings(item) && !item->GetPVRTimerInfoTag()->GetTimerType()->IsReadOnly())
+      g_PVRTimers->UpdateTimer(*item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimersBase::OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_RENAME)
+  {
+    bReturn = true;
+    if (!item->HasPVRTimerInfoTag())
+      return bReturn;
+    CPVRTimerInfoTagPtr timer = item->GetPVRTimerInfoTag();
+
+    std::string strNewName(timer->m_strTitle);
+    if (CGUIKeyboardFactory::ShowAndGetInput(strNewName, CVariant{g_localizeStrings.Get(19042)}, false))
+      g_PVRTimers->RenameTimer(*item, strNewName);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimersBase::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_INFO)
+  {
+    ShowEPGInfo(item);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimersBase::ActionDeleteTimer(CFileItem *item)
+{
+  bool bReturn = DeleteTimer(item);
+
+  if (bReturn && (m_vecItems->GetObjectCount() == 0))
+  {
+    /* go to the parent folder if we're in a subdirectory and just deleted the last item */
+    CPVRTimersPath path(m_vecItems->GetPath());
+    if (path.IsValid() && path.IsTimerSchedule())
+    {
+      m_currentFileItem.reset();
+      GoParentFolder();
+    }
+  }
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimersBase::ActionShowTimer(CFileItem *item)
+{
+  bool bReturn = false;
+
+  /* Check if "Add timer..." entry is pressed by OK, if yes
+     create a new timer and open settings dialog, otherwise
+     open settings for selected timer entry */
+  if (URIUtils::PathEquals(item->GetPath(), CPVRTimersPath::PATH_ADDTIMER))
+  {
+    bReturn = ShowNewTimerDialog();
+  }
+  else
+  {
+    if (ShowTimerSettings(item) && !item->GetPVRTimerInfoTag()->GetTimerType()->IsReadOnly())
+    {
+      /* Update timer on pvr backend */
+      bReturn = g_PVRTimers->UpdateTimer(*item);
+    }
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimersBase::ShowNewTimerDialog(void)
+{
+  bool bReturn(false);
+
+  CPVRTimerInfoTagPtr newTimer(new CPVRTimerInfoTag(m_bRadio));
+  CFileItem *newItem = new CFileItem(newTimer);
+
+  if (ShowTimerSettings(newItem))
+  {
+    /* Add timer to backend */
+    bReturn = g_PVRTimers->AddTimer(newItem->GetPVRTimerInfoTag());
+  }
+
+  delete newItem;
+
+  return bReturn;
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimersBase.h b/xbmc/pvr/windows/GUIWindowPVRTimersBase.h
new file mode 100644
index 0000000..25cc705
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVRTimersBase.h
@@ -0,0 +1,61 @@
+#pragma once
+/*
+ *      Copyright (C) 2012-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GUIWindowPVRBase.h"
+
+#include <memory>
+
+class CFileItem;
+typedef std::shared_ptr<CFileItem> CFileItemPtr;
+
+namespace PVR
+{
+  class CGUIWindowPVRTimersBase : public CGUIWindowPVRBase
+  {
+  public:
+    CGUIWindowPVRTimersBase(bool bRadio, int id, const std::string &xmlFile);
+    virtual ~CGUIWindowPVRTimersBase(void) {};
+
+    bool OnMessage(CGUIMessage& message);
+    bool OnAction(const CAction &action);
+    void GetContextButtons(int itemNumber, CContextButtons &buttons);
+    bool OnContextButton(int itemNumber, CONTEXT_BUTTON button);
+    bool Update(const std::string &strDirectory, bool updateFilterPath = true);
+    void UpdateButtons(void);
+    void UnregisterObservers(void);
+    void ResetObservers(void);
+
+  private:
+    bool ActionDeleteTimer(CFileItem *item);
+    bool ActionShowTimer(CFileItem *item);
+    bool ShowNewTimerDialog(void);
+
+    bool OnContextButtonActivate(CFileItem *item, CONTEXT_BUTTON button);
+    bool OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button);
+    bool OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button);
+    bool OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button);
+    bool OnContextButtonEdit(CFileItem *item, CONTEXT_BUTTON button);
+    bool OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button);
+    bool OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button);
+
+    CFileItemPtr m_currentFileItem;
+  };
+}
diff --git a/xbmc/pvr/windows/Makefile b/xbmc/pvr/windows/Makefile
index 386734b..49a3537 100644
--- a/xbmc/pvr/windows/Makefile
+++ b/xbmc/pvr/windows/Makefile
@@ -4,7 +4,9 @@ SRCS=GUIViewStatePVR.cpp \
      GUIWindowPVRGuide.cpp \
      GUIWindowPVRRecordings.cpp \
      GUIWindowPVRSearch.cpp \
-     GUIWindowPVRTimers.cpp
+     GUIWindowPVRTimersBase.cpp \
+     GUIWindowPVRTimers.cpp \
+     GUIWindowPVRTimerRules.cpp
 
 LIB=pvrwindows.a
 
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index f50355b..0fd9669 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -259,7 +259,7 @@ const std::string CSettings::SETTING_PVRPARENTAL_ENABLED = "pvrparental.enabled"
 const std::string CSettings::SETTING_PVRPARENTAL_PIN = "pvrparental.pin";
 const std::string CSettings::SETTING_PVRPARENTAL_DURATION = "pvrparental.duration";
 const std::string CSettings::SETTING_PVRCLIENT_MENUHOOK = "pvrclient.menuhook";
-const std::string CSettings::SETTING_PVRTIMERS_TIMERTYPEFILTER = "pvrtimers.timertypefilter";
+const std::string CSettings::SETTING_PVRTIMERS_HIDEDISABLEDTIMERS = "pvrtimers.hidedisabledtimers";
 const std::string CSettings::SETTING_MUSICLIBRARY_SHOWCOMPILATIONARTISTS = "musiclibrary.showcompilationartists";
 const std::string CSettings::SETTING_MUSICLIBRARY_DOWNLOADINFO = "musiclibrary.downloadinfo";
 const std::string CSettings::SETTING_MUSICLIBRARY_ALBUMSSCRAPER = "musiclibrary.albumsscraper";
diff --git a/xbmc/settings/Settings.h b/xbmc/settings/Settings.h
index 55e150d..46ea82e 100644
--- a/xbmc/settings/Settings.h
+++ b/xbmc/settings/Settings.h
@@ -215,7 +215,7 @@ public:
   static const std::string SETTING_PVRPARENTAL_PIN;
   static const std::string SETTING_PVRPARENTAL_DURATION;
   static const std::string SETTING_PVRCLIENT_MENUHOOK;
-  static const std::string SETTING_PVRTIMERS_TIMERTYPEFILTER;
+  static const std::string SETTING_PVRTIMERS_HIDEDISABLEDTIMERS;
   static const std::string SETTING_MUSICLIBRARY_SHOWCOMPILATIONARTISTS;
   static const std::string SETTING_MUSICLIBRARY_DOWNLOADINFO;
   static const std::string SETTING_MUSICLIBRARY_ALBUMSSCRAPER;
diff --git a/xbmc/view/GUIViewState.cpp b/xbmc/view/GUIViewState.cpp
index 2fa00b7..e88dc52 100644
--- a/xbmc/view/GUIViewState.cpp
+++ b/xbmc/view/GUIViewState.cpp
@@ -145,6 +145,9 @@ CGUIViewState* CGUIViewState::GetViewState(int windowId, const CFileItemList& it
   if (windowId == WINDOW_TV_TIMERS)
     return new CGUIViewStateWindowPVRTimers(windowId, items);
 
+  if (windowId == WINDOW_TV_TIMER_RULES)
+    return new CGUIViewStateWindowPVRTimers(windowId, items);
+
   if (windowId == WINDOW_TV_SEARCH)
     return new CGUIViewStateWindowPVRSearch(windowId, items);
 
@@ -160,6 +163,9 @@ CGUIViewState* CGUIViewState::GetViewState(int windowId, const CFileItemList& it
   if (windowId == WINDOW_RADIO_TIMERS)
     return new CGUIViewStateWindowPVRTimers(windowId, items);
 
+  if (windowId == WINDOW_RADIO_TIMER_RULES)
+    return new CGUIViewStateWindowPVRTimers(windowId, items);
+
   if (windowId == WINDOW_RADIO_SEARCH)
     return new CGUIViewStateWindowPVRSearch(windowId, items);
 
