diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index d00062b..a9b0dc8 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -3426,19 +3426,19 @@ msgctxt "#806"
 msgid "Fulltext search (or title search only)"
 msgstr ""
 
-#. special days of week representation value for a timer schedule
+#. special days of week representation value for a timer rule
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#807"
 msgid "Any day"
 msgstr ""
 
-#. special days of week representation for a repeating timer
+#. special days of week representation for a timer rule
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#808"
 msgid "Every day"
 msgstr ""
 
-#. special channel representation value for a repeating timer
+#. special channel representation value for a timer rule
 #: xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#809"
@@ -3515,13 +3515,13 @@ msgctxt "#821"
 msgid "One time (guide-based)"
 msgstr ""
 
-#. Representation of a timer schedule
+#. Representation of a timer rule
 #: xbmc/pvr/addons/PVRClient.cpp
 msgctxt "#822"
 msgid "Repeating"
 msgstr ""
 
-#. Representation of an epg-based timer schedule.
+#. Representation of an epg-based timer rule.
 #: xbmc/pvr/addons/PVRClient.cpp
 msgctxt "#823"
 msgid "Repeating (guide-based)"
@@ -3529,10 +3529,10 @@ msgstr ""
 
 #empty strings from id 824 to 827
 
-#. Text for notification that a repeating timer has been deleted
+#. Text for notification that a timer rule has been deleted
 #: xbmc/pvr/timers/PVRTimers.cpp
 msgctxt "#828"
-msgid "Repeating timer deleted"
+msgid "Timer rule deleted"
 msgstr ""
 
 #empty strings from id 829 to 830
@@ -3588,13 +3588,13 @@ msgstr ""
 
 #empty strings from id 838 to 839
 
-#. Message in a dialog when a user wants to delete a timer that was scheduled by a repeating timer
+#. Message in a dialog when a user wants to delete a timer that was scheduled by a timer rule
 #: xbmc/pvr/windows/GUIWindowPVRBase.cpp
 msgctxt "#840"
-msgid "Do you only want to delete this timer or also the repeating timer that has scheduled it?"
+msgid "Do you only want to delete this timer or also the timer rule that has scheduled it?"
 msgstr ""
 
-#. Label for No button in a dialog when a user wants to delete a timer that was scheduled by a repeating timer
+#. Label for No button in a dialog when a user wants to delete a timer that was scheduled by a timer rule
 #: xbmc/pvr/windows/GUIWindowPVRBase.cpp
 msgctxt "#841"
 msgid "Only this"
@@ -3614,25 +3614,25 @@ msgctxt "#844"
 msgid "Deactivate"
 msgstr ""
 
-#. Message in a dialog when a user wants to delete a repeating timer
+#. Message in a dialog when a user wants to delete a timer rule
 #: xbmc/pvr/windows/GUIWindowPVRBase.cpp
 msgctxt "#845"
-msgid "Are you sure you want to delete this repeating timer and all timers it has scheduled?"
+msgid "Are you sure you want to delete this timer rule and all timers it has scheduled?"
 msgstr ""
 
-#. Message in a dialog when a user wants to delete a non-repeating timer
+#. Message in a dialog when a user wants to delete a timer
 #: xbmc/pvr/windows/GUIWindowPVRBase.cpp
 msgctxt "#846"
 msgid "Are you sure you want to delete this timer?"
 msgstr ""
 
-#. Message in a dialog when a user wants to delete a non-repeating timer
+#. Heading for a dialog for confirming to stop an active recording
 #: xbmc/pvr/windows/GUIWindowPVRBase.cpp
 msgctxt "#847"
 msgid "Confirm stop recording"
 msgstr ""
 
-#. Message in a dialog when a user wants to delete a non-repeating timer
+#. Message in a dialog when a user wants to stop an active recording
 #: xbmc/pvr/windows/GUIWindowPVRBase.cpp
 msgctxt "#848"
 msgid "Are you sure you want to stop this recording?"
@@ -9120,7 +9120,7 @@ msgctxt "#19160"
 msgid "to"
 msgstr ""
 
-#. timer schedule presentation string. <start-day-date|days-of-week> "from" <start-day-time|"any time"> "to" <end-day-time|"any time">
+#. timer rule presentation string. <start-day-date|days-of-week> "from" <start-day-time|"any time"> "to" <end-day-time|"any time">
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19161"
 msgid "any time"
@@ -9481,17 +9481,27 @@ msgctxt "#19239"
 msgid "Starting background threads"
 msgstr ""
 
-#: xbmc/pvr/windows/PVRClients.cpp
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#19240"
 msgid "No PVR add-on enabled"
 msgstr ""
 
-#: xbmc/pvr/windows/PVRClients.cpp
+#: xbmc/pvr/addons/PVRClients.cpp
 msgctxt "#19241"
 msgid "The PVR manager has been enabled without any enabled PVR add-on. Enable at least one add-on in order to use the PVR functionality."
 msgstr ""
 
-#empty strings from id 19242 to 19243
+#. Label for context menu entry to open settings dialog for a timer
+#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
+msgctxt "#19242"
+msgid "Edit timer"
+msgstr ""
+
+#. Label for context menu entry to open settings dialog for a timer rule
+#: xbmc/pvr/windows/GUIWindowPVRGuide.cpp
+msgctxt "#19243"
+msgid "Edit timer rule"
+msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#19244"
@@ -17313,7 +17323,7 @@ msgstr ""
 #. Description of setting "TV -> Recording -> Prevent duplicate episodes" with label #812
 #: system/settings/settings.xml
 msgctxt "#36423"
-msgid "Repeating schedules shall only record new episodes. Not supported by all add-ons and backends."
+msgid "Timer rules shall only record new episodes. Not supported by all add-ons and backends."
 msgstr ""
 
 #: system/settings/settings.xml
diff --git a/xbmc/GUIInfoManager.cpp b/xbmc/GUIInfoManager.cpp
index 1baf292..bb5c48a 100644
--- a/xbmc/GUIInfoManager.cpp
+++ b/xbmc/GUIInfoManager.cpp
@@ -5928,7 +5928,7 @@ bool CGUIInfoManager::GetItemBool(const CGUIListItem *item, int condition) const
       if (pItem->HasEPGInfoTag())
       {
         CFileItemPtr timer = g_PVRTimers->GetTimerForEpgTag(pItem);
-        if (timer && timer->HasPVRTimerInfoTag() && timer->GetPVRTimerInfoTag()->GetTimerScheduleId() != PVR_TIMER_NO_PARENT)
+        if (timer && timer->HasPVRTimerInfoTag() && timer->GetPVRTimerInfoTag()->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
           return timer->GetPVRTimerInfoTag()->IsActive();
       }
     }
diff --git a/xbmc/dialogs/GUIDialogContextMenu.h b/xbmc/dialogs/GUIDialogContextMenu.h
index 2ce98af..d675593 100644
--- a/xbmc/dialogs/GUIDialogContextMenu.h
+++ b/xbmc/dialogs/GUIDialogContextMenu.h
@@ -107,6 +107,8 @@ enum CONTEXT_BUTTON { CONTEXT_BUTTON_CANCELLED = 0,
                       CONTEXT_BUTTON_START_RECORD,
                       CONTEXT_BUTTON_ADD_TIMER,
                       CONTEXT_BUTTON_STOP_RECORD,
+                      CONTEXT_BUTTON_EDIT_TIMER,
+                      CONTEXT_BUTTON_EDIT_TIMER_RULE,
                       CONTEXT_BUTTON_DELETE_TIMER,
                       CONTEXT_BUTTON_GROUP_MANAGER,
                       CONTEXT_BUTTON_CHANNEL_MANAGER,
diff --git a/xbmc/epg/EpgInfoTag.cpp b/xbmc/epg/EpgInfoTag.cpp
index 18574cf..4ce11ae 100644
--- a/xbmc/epg/EpgInfoTag.cpp
+++ b/xbmc/epg/EpgInfoTag.cpp
@@ -210,7 +210,7 @@ void CEpgInfoTag::Serialize(CVariant &value) const
   value["episodenum"] = m_iEpisodeNumber;
   value["episodepart"] = m_iEpisodePart;
   value["hastimer"] = HasTimer();
-  value["hastimerschedule"] = HasTimerSchedule();
+  value["hastimerrule"] = HasTimerRule();
   value["hasrecording"] = HasRecording();
   value["recording"] = recording ? recording->m_strFileNameAndPath : "";
   value["isactive"] = IsActive();
@@ -528,10 +528,10 @@ bool CEpgInfoTag::HasTimer(void) const
   return m_timer != NULL;
 }
 
-bool CEpgInfoTag::HasTimerSchedule(void) const
+bool CEpgInfoTag::HasTimerRule(void) const
 {
   CSingleLock lock(m_critSection);
-  return m_timer && (m_timer->GetTimerScheduleId() != PVR_TIMER_NO_PARENT);
+  return m_timer && (m_timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT);
 }
 
 CPVRTimerInfoTagPtr CEpgInfoTag::Timer(void) const
diff --git a/xbmc/epg/EpgInfoTag.h b/xbmc/epg/EpgInfoTag.h
index 6a52cfe..03dddd8 100644
--- a/xbmc/epg/EpgInfoTag.h
+++ b/xbmc/epg/EpgInfoTag.h
@@ -333,10 +333,10 @@ namespace EPG
     bool HasTimer(void) const;
 
     /*!
-     * @brief Check whether this event has an active timer schedule.
-     * @return True if it has an active timer schedule, false if not.
+     * @brief Check whether this event has an active timer rule.
+     * @return True if it has an active timer rule, false if not.
      */
-    bool HasTimerSchedule(void) const;
+    bool HasTimerRule(void) const;
 
     /*!
      * @brief Get a pointer to the timer for event or NULL if there is none.
diff --git a/xbmc/pvr/timers/PVRTimerInfoTag.h b/xbmc/pvr/timers/PVRTimerInfoTag.h
index 21c080e..559cd8d 100644
--- a/xbmc/pvr/timers/PVRTimerInfoTag.h
+++ b/xbmc/pvr/timers/PVRTimerInfoTag.h
@@ -225,10 +225,10 @@ namespace PVR
     static std::string GetWeekdaysString(unsigned int iWeekdays, bool bEpgBased, bool bLongMultiDaysFormat);
 
     /*!
-     * @brief For timers scheduled by repeated timers, return the id of the parent.
-     * @return the id of the timer schedule or 0 in case the timer was not scheduled by a repeating timer.
+     * @brief For timers scheduled by a timer rule, return the id of the rule (aka the id of the "parent" of the timer).
+     * @return the id of the timer rule or PVR_TIMER_NO_PARENT in case the timer was not scheduled by a timer rule.
      */
-    unsigned int GetTimerScheduleId() const { return m_iParentClientIndex; }
+    unsigned int GetTimerRuleId() const { return m_iParentClientIndex; }
 
     std::string           m_strTitle;            /*!< @brief name of this timer */
     std::string           m_strEpgSearchString;  /*!< @brief a epg data match string for repeating epg-based timers. Format is backend-dependent, for example regexp */
@@ -238,7 +238,7 @@ namespace PVR
     PVR_TIMER_STATE       m_state;               /*!< @brief the state of this timer */
     int                   m_iClientId;           /*!< @brief ID of the backend */
     unsigned int          m_iClientIndex;        /*!< @brief index number of the tag, given by the backend, PVR_TIMER_NO_CLIENT_INDEX for new */
-    unsigned int          m_iParentClientIndex;  /*!< @brief for timers scheduled by repeated timers, the index number of the parent, given by the backend, PVR_TIMER_NO_PARENT for no parent */
+    unsigned int          m_iParentClientIndex;  /*!< @brief for timers scheduled by a timer rule, the index number of the parent, given by the backend, PVR_TIMER_NO_PARENT for no parent */
     int                   m_iClientChannelUid;   /*!< @brief channel uid */
     bool                  m_bStartAnyTime;       /*!< @brief Ignore start date and time clock. Record at 'Any Time' */
     bool                  m_bEndAnyTime;         /*!< @brief Ignore end date and time clock. Record at 'Any Time' */
diff --git a/xbmc/pvr/timers/PVRTimers.cpp b/xbmc/pvr/timers/PVRTimers.cpp
index 2b78009..19f09ad 100644
--- a/xbmc/pvr/timers/PVRTimers.cpp
+++ b/xbmc/pvr/timers/PVRTimers.cpp
@@ -476,12 +476,12 @@ bool CPVRTimers::GetDirectory(const std::string& strPath, CFileItemList &items)
   {
     if (path.IsTimersRoot())
     {
-      /* Root folder containing both timer schedules and timers. */
+      /* Root folder containing either timer rules or timers. */
       return GetRootDirectory(path, items);
     }
-    else if (path.IsTimerSchedule())
+    else if (path.IsTimerRule())
     {
-      /* Sub folder containing the timers scheduled by the given timer schedule. */
+      /* Sub folder containing the timers scheduled by the given timer rule. */
       return GetSubDirectory(path, items);
     }
   }
@@ -595,7 +595,7 @@ bool CPVRTimers::AddTimer(const CPVRTimerInfoTagPtr &item)
   return item->AddToClient();
 }
 
-bool CPVRTimers::DeleteTimer(const CFileItem &item, bool bForce /* = false */, bool bDeleteSchedule /* = false */)
+bool CPVRTimers::DeleteTimer(const CFileItem &item, bool bForce /* = false */, bool bDeleteRule /* = false */)
 {
   /* Check if a CPVRTimerInfoTag is inside file item */
   if (!item.IsPVRTimer())
@@ -608,10 +608,10 @@ bool CPVRTimers::DeleteTimer(const CFileItem &item, bool bForce /* = false */, b
   if (!tag)
     return false;
 
-  if (bDeleteSchedule)
+  if (bDeleteRule)
   {
-    /* delete the repeating timer that scheduled this timer. */
-    tag = g_PVRTimers->GetByClient(tag->m_iClientId, tag->GetTimerScheduleId());
+    /* delete the timer rule that scheduled this timer. */
+    tag = g_PVRTimers->GetByClient(tag->m_iClientId, tag->GetTimerRuleId());
     if (!tag)
     {
       CLog::Log(LOGERROR, "PVRTimers - %s - unable to obtain parent timer for given timer", __FUNCTION__);
@@ -722,6 +722,35 @@ CFileItemPtr CPVRTimers::GetTimerForEpgTag(const CFileItem *item) const
   return fileItem;
 }
 
+CFileItemPtr CPVRTimers::GetTimerRule(const CFileItem *item) const
+{
+  CPVRTimerInfoTagPtr timer;
+  if (item && item->HasEPGInfoTag())
+    timer = item->GetEPGInfoTag()->Timer();
+  else if (item && item->HasPVRTimerInfoTag())
+    timer = item->GetPVRTimerInfoTag();
+
+  if (timer)
+  {
+    unsigned int iRuleId = timer->GetTimerRuleId();
+    if (iRuleId != PVR_TIMER_NO_PARENT)
+    {
+      int iClientId = timer->m_iClientId;
+
+      CSingleLock lock(m_critSection);
+      for (const auto &tagsEntry : m_tags)
+      {
+        for (const auto &timersEntry : *tagsEntry.second)
+        {
+          if (timersEntry->m_iClientId == iClientId && timersEntry->m_iClientIndex == iRuleId)
+            return CFileItemPtr(new CFileItem(timersEntry));
+        }
+      }
+    }
+  }
+  return CFileItemPtr();
+}
+
 void CPVRTimers::Notify(const Observable &obs, const ObservableMessage msg)
 {
   if (msg == ObservableMessageEpgContainer)
@@ -849,6 +878,7 @@ CPVRTimerInfoTagPtr CPVRTimers::GetById(unsigned int iTimerId) const
   return item;
 }
 
+
 //= CPVRTimersPath ============================================================
 
 const std::string CPVRTimersPath::PATH_ADDTIMER = "pvr://timers/addtimer/";
diff --git a/xbmc/pvr/timers/PVRTimers.h b/xbmc/pvr/timers/PVRTimers.h
index 03dd88d..af10013 100644
--- a/xbmc/pvr/timers/PVRTimers.h
+++ b/xbmc/pvr/timers/PVRTimers.h
@@ -148,10 +148,10 @@ namespace PVR
 
     /*!
      * @brief Delete a timer on the client. Doesn't delete the timer from the container. The backend will do this.
-     * @param bDeleteSchedule Also delete repeating schedule instead of single timer only.
+     * @param bDeleteRule Also delete the timer rule that scheduled the timer instead of single timer only.
      * @return True if it was sent correctly, false if not.
      */
-    static bool DeleteTimer(const CFileItem &item, bool bForce = false, bool bDeleteSchedule = false);
+    static bool DeleteTimer(const CFileItem &item, bool bForce = false, bool bDeleteRule = false);
 
     /*!
      * @brief Rename a timer on the client. Doesn't update the timer in the container. The backend will do this.
@@ -173,6 +173,13 @@ namespace PVR
     CFileItemPtr GetTimerForEpgTag(const CFileItem *item) const;
 
     /*!
+     * Get the timer rule for a given timer tag
+     * @param timer The timer to query the timer rule for
+     * @return The timer rule, or an empty fileitemptr if none was found.
+     */
+    CFileItemPtr GetTimerRule(const CFileItem *item) const;
+
+    /*!
      * @brief Update the channel pointers.
      */
     void UpdateChannels(void);
@@ -215,13 +222,13 @@ namespace PVR
 
     bool IsValid() const { return m_bValid; }
 
-    const std::string &GetPath() const        { return m_path; }
-    bool              IsTimersRoot() const    { return m_bRoot; }
-    bool              IsTimerSchedule() const { return !IsTimersRoot(); }
-    bool              IsRadio() const         { return m_bRadio; }
-    bool              IsRules() const         { return m_bTimerRules; }
-    int               GetClientId() const     { return m_iClientId; }
-    unsigned int      GetParentId() const     { return m_iParentId; }
+    const std::string &GetPath() const     { return m_path; }
+    bool              IsTimersRoot() const { return m_bRoot; }
+    bool              IsTimerRule() const  { return !IsTimersRoot(); }
+    bool              IsRadio() const      { return m_bRadio; }
+    bool              IsRules() const      { return m_bTimerRules; }
+    int               GetClientId() const  { return m_iClientId; }
+    unsigned int      GetParentId() const  { return m_iParentId; }
 
   private:
     bool Init(const std::string &strPath);
diff --git a/xbmc/pvr/windows/GUIWindowPVRBase.cpp b/xbmc/pvr/windows/GUIWindowPVRBase.cpp
index 2a5a0fe..be784c4 100644
--- a/xbmc/pvr/windows/GUIWindowPVRBase.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRBase.cpp
@@ -285,6 +285,35 @@ bool CGUIWindowPVRBase::OnContextButtonActiveAEDSPSettings(CFileItem *item, CONT
   return bReturn;
 }
 
+bool CGUIWindowPVRBase::OnContextButtonEditTimer(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_EDIT_TIMER)
+  {
+    EditTimer(item);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRBase::OnContextButtonEditTimerRule(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_EDIT_TIMER_RULE)
+  {
+    CFileItemPtr parentTimer(g_PVRTimers->GetTimerRule(item));
+    if (parentTimer)
+      EditTimer(parentTimer.get());
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
 void CGUIWindowPVRBase::SetInvalid()
 {
   if (m_refreshTimeout.IsTimePast())
@@ -512,6 +541,28 @@ bool CGUIWindowPVRBase::AddTimer(CFileItem *item, bool bAdvanced)
   return bReturn;
 }
 
+bool CGUIWindowPVRBase::EditTimer(CFileItem *item)
+{
+  CFileItemPtr timer;
+
+  if (item->IsPVRTimer())
+  {
+    timer.reset(new CFileItem(*item));
+  }
+  else if (item->IsEPG())
+  {
+    timer = g_PVRTimers->GetTimerForEpgTag(item);
+  }
+
+  if (!timer || !timer->HasPVRTimerInfoTag())
+    return false;
+
+  if (ShowTimerSettings(timer.get()) && !timer->GetPVRTimerInfoTag()->GetTimerType()->IsReadOnly())
+    return g_PVRTimers->UpdateTimer(*timer);
+
+  return false;
+}
+
 bool CGUIWindowPVRBase::DeleteTimer(CFileItem *item)
 {
   return DeleteTimer(item, false);
@@ -559,9 +610,9 @@ bool CGUIWindowPVRBase::DeleteTimer(CFileItem *item, bool bIsRecording)
   }
   else
   {
-    bool bDeleteSchedule(false);
-    if (ConfirmDeleteTimer(timer.get(), bDeleteSchedule))
-      return CPVRTimers::DeleteTimer(*timer, false, bDeleteSchedule);
+    bool bDeleteRule(false);
+    if (ConfirmDeleteTimer(timer.get(), bDeleteRule))
+      return CPVRTimers::DeleteTimer(*timer, false, bDeleteRule);
   }
   return false;
 }
@@ -843,17 +894,17 @@ void CGUIWindowPVRBase::UpdateSelectedItemPath()
   }
 }
 
-bool CGUIWindowPVRBase::ConfirmDeleteTimer(CFileItem *item, bool &bDeleteSchedule)
+bool CGUIWindowPVRBase::ConfirmDeleteTimer(CFileItem *item, bool &bDeleteRule)
 {
   bool bConfirmed(false);
 
-  if (item->GetPVRTimerInfoTag()->GetTimerScheduleId() != PVR_TIMER_NO_PARENT)
+  if (item->GetPVRTimerInfoTag()->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
   {
-    // timer was scheduled by a repeating timer. prompt user for confirmation for deleting the complete repeating timer, including scheduled timers.
+    // timer was scheduled by a timer rule. prompt user for confirmation for deleting the timer rule, including scheduled timers.
     bool bCancel(false);
-    bDeleteSchedule = CGUIDialogYesNo::ShowAndGetInput(
+    bDeleteRule = CGUIDialogYesNo::ShowAndGetInput(
                         CVariant{122}, // "Confirm delete"
-                        CVariant{840}, // "Do you only want to delete this timer or also the repeating timer that has scheduled it?"
+                        CVariant{840}, // "Do you want to delete only this timer or also the timer rule that has scheduled it?"
                         CVariant{""},
                         CVariant{item->GetPVRTimerInfoTag()->Title()},
                         bCancel,
@@ -864,13 +915,13 @@ bool CGUIWindowPVRBase::ConfirmDeleteTimer(CFileItem *item, bool &bDeleteSchedul
   }
   else
   {
-    bDeleteSchedule = false;
+    bDeleteRule = false;
 
     // prompt user for confirmation for deleting the timer
     bConfirmed = CGUIDialogYesNo::ShowAndGetInput(
                         CVariant{122}, // "Confirm delete"
                         item->GetPVRTimerInfoTag()->IsRepeating()
-                          ? CVariant{845}  // "Are you sure you want to delete this repeating timer and all timers it has scheduled?"
+                          ? CVariant{845}  // "Are you sure you want to delete this timer rule and all timers it has scheduled?"
                           : CVariant{846}, // "Are you sure you want to delete this timer?"
                         CVariant{""},
                         CVariant{item->GetPVRTimerInfoTag()->Title()});
diff --git a/xbmc/pvr/windows/GUIWindowPVRBase.h b/xbmc/pvr/windows/GUIWindowPVRBase.h
index 4f5c4df..cbb52ae 100644
--- a/xbmc/pvr/windows/GUIWindowPVRBase.h
+++ b/xbmc/pvr/windows/GUIWindowPVRBase.h
@@ -78,6 +78,7 @@ namespace PVR
 
     static bool ShowTimerSettings(CFileItem *item);
     static bool AddTimer(CFileItem *item, bool bAdvanced);
+    static bool EditTimer(CFileItem *item);
     static bool DeleteTimer(CFileItem *item);
     static bool StopRecordFile(CFileItem *item);
 
@@ -103,6 +104,9 @@ namespace PVR
     virtual bool IsValidMessage(CGUIMessage& message);
     void CheckResumeRecording(CFileItem *item);
 
+    bool OnContextButtonEditTimer(CFileItem *item, CONTEXT_BUTTON button);
+    bool OnContextButtonEditTimerRule(CFileItem *item, CONTEXT_BUTTON button);
+
     static CCriticalSection m_selectedItemPathsLock;
     static std::string m_selectedItemPaths[2];
 
@@ -113,13 +117,13 @@ namespace PVR
     /*!
      * @brief Open a dialog to confirm timer delete.
      * @param item the timer to delete.
-     * @param bDeleteSchedule in: ignored
-     *                        out, for one shot timer scheduled by a repeating timer: true to also delete the
-     *                             repeating timer that has scheduled this timer, false to only delete the one shot timer.
-     *                        out, for one shot timer not scheduled by a repeating timer: ignored
+     * @param bDeleteRule in: ignored
+     *                    out, for one shot timer scheduled by a timer rule: true to also delete the timer
+     *                    rule that has scheduled this timer, false to only delete the one shot timer.
+     *                    out, for one shot timer not scheduled by a timer rule: ignored
      * @return true, to proceed with delete, false otherwise.
      */
-    static bool ConfirmDeleteTimer(CFileItem *item, bool &bDeleteSchedule);
+    static bool ConfirmDeleteTimer(CFileItem *item, bool &bDeleteRule);
 
     /*!
      * @brief Open a dialog to confirm stop recording.
diff --git a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
index 814b4a8..244ca34 100644
--- a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
@@ -92,11 +92,17 @@ void CGUIWindowPVRGuide::GetContextButtons(int itemNumber, CContextButtons &butt
     CPVRTimerInfoTagPtr timer(epg->Timer());
     if (timer)
     {
+      if (timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
+        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER_RULE, 19243); /* Edit timer rule */
+
+      const CPVRTimerTypePtr timerType(timer->GetTimerType());
+      if (timerType && !timerType->IsReadOnly())
+        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER, 19242);    /* Edit timer */
+
       if (timer->IsRecording())
         buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059);   /* Stop recording */
       else
       {
-        CPVRTimerTypePtr timerType(timer->GetTimerType());
         if (timerType && !timerType->IsReadOnly())
           buttons.Add(CONTEXT_BUTTON_DELETE_TIMER, 19060);  /* Delete timer */
       }
@@ -392,6 +398,8 @@ bool CGUIWindowPVRGuide::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
       OnContextButtonInfo(pItem.get(), button) ||
       OnContextButtonStartRecord(pItem.get(), button) ||
       OnContextButtonStopRecord(pItem.get(), button) ||
+      OnContextButtonEditTimer(pItem.get(), button) ||
+      OnContextButtonEditTimerRule(pItem.get(), button) ||
       OnContextButtonDeleteTimer(pItem.get(), button) ||
       OnContextButtonBegin(pItem.get(), button) ||
       OnContextButtonEnd(pItem.get(), button) ||
diff --git a/xbmc/pvr/windows/GUIWindowPVRSearch.cpp b/xbmc/pvr/windows/GUIWindowPVRSearch.cpp
index 7908c32..a1e7972 100644
--- a/xbmc/pvr/windows/GUIWindowPVRSearch.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRSearch.cpp
@@ -58,11 +58,17 @@ void CGUIWindowPVRSearch::GetContextButtons(int itemNumber, CContextButtons &but
     CPVRTimerInfoTagPtr timer(epg->Timer());
     if (timer)
     {
+      if (timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
+        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER_RULE, 19243); /* Edit timer rule */
+
+      const CPVRTimerTypePtr timerType(timer->GetTimerType());
+      if (timerType && !timerType->IsReadOnly())
+        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER, 19242);    /* Edit timer */
+
       if (timer->IsRecording())
         buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059);   /* Stop recording */
       else
       {
-        CPVRTimerTypePtr timerType(timer->GetTimerType());
         if (timerType && !timerType->IsReadOnly())
           buttons.Add(CONTEXT_BUTTON_DELETE_TIMER, 19060);  /* Delete timer */
       }
@@ -103,6 +109,8 @@ bool CGUIWindowPVRSearch::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
       OnContextButtonInfo(pItem.get(), button) ||
       OnContextButtonStartRecord(pItem.get(), button) ||
       OnContextButtonStopRecord(pItem.get(), button) ||
+      OnContextButtonEditTimer(pItem.get(), button) ||
+      OnContextButtonEditTimerRule(pItem.get(), button) ||
       OnContextButtonDeleteTimer(pItem.get(), button) ||
       OnContextButtonPlay(pItem.get(), button) ||
       CGUIWindowPVRBase::OnContextButton(itemNumber, button);
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp b/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
index 026332b..0700022 100644
--- a/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRTimersBase.cpp
@@ -87,11 +87,14 @@ void CGUIWindowPVRTimersBase::GetContextButtons(int itemNumber, CContextButtons
 
         if (!timerType->IsReadOnly())
         {
-          buttons.Add(CONTEXT_BUTTON_EDIT, 21450);        /* Edit */
+          if (timer->GetTimerRuleId() == PVR_TIMER_NO_PARENT)
+            buttons.Add(CONTEXT_BUTTON_EDIT_TIMER, 21450);  /* Edit */
+          else
+            buttons.Add(CONTEXT_BUTTON_EDIT_TIMER, 19242);  /* Edit timer */
 
           // As epg-based timers will get it's title from the epg tag, they should not be renamable.
           if (timer->IsManual())
-            buttons.Add(CONTEXT_BUTTON_RENAME, 118);      /* Rename */
+            buttons.Add(CONTEXT_BUTTON_RENAME, 118);        /* Rename */
 
           if (timer->IsRecording())
             buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059); /* Stop recording */
@@ -100,6 +103,9 @@ void CGUIWindowPVRTimersBase::GetContextButtons(int itemNumber, CContextButtons
         }
       }
 
+      if (timer->GetTimerRuleId() != PVR_TIMER_NO_PARENT)
+        buttons.Add(CONTEXT_BUTTON_EDIT_TIMER_RULE, 19243); /* Edit timer rule */
+
       if (g_PVRClients->HasMenuHooks(timer->m_iClientId, PVR_MENUHOOK_TIMER))
         buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);    /* PVR client specific action */
     }
@@ -115,7 +121,7 @@ bool CGUIWindowPVRTimersBase::OnAction(const CAction &action)
       action.GetID() == ACTION_NAV_BACK)
   {
     CPVRTimersPath path(m_vecItems->GetPath());
-    if (path.IsValid() && path.IsTimerSchedule())
+    if (path.IsValid() && path.IsTimerRule())
     {
       m_currentFileItem.reset();
       GoParentFolder();
@@ -135,7 +141,8 @@ bool CGUIWindowPVRTimersBase::OnContextButton(int itemNumber, CONTEXT_BUTTON but
       OnContextButtonAdd(pItem.get(), button) ||
       OnContextButtonDelete(pItem.get(), button) ||
       OnContextButtonStopRecord(pItem.get(), button) ||
-      OnContextButtonEdit(pItem.get(), button) ||
+      OnContextButtonEditTimer(pItem.get(), button) ||
+      OnContextButtonEditTimerRule(pItem.get(), button) ||
       OnContextButtonRename(pItem.get(), button) ||
       OnContextButtonInfo(pItem.get(), button) ||
       CGUIWindowPVRBase::OnContextButton(itemNumber, button);
@@ -302,23 +309,6 @@ bool CGUIWindowPVRTimersBase::OnContextButtonStopRecord(CFileItem *item, CONTEXT
   return bReturn;
 }
 
-bool CGUIWindowPVRTimersBase::OnContextButtonEdit(CFileItem *item, CONTEXT_BUTTON button)
-{
-  bool bReturn = false;
-
-  if (button == CONTEXT_BUTTON_EDIT)
-  {
-    bReturn = true;
-    if (!item->HasPVRTimerInfoTag())
-      return bReturn;
-
-    if (ShowTimerSettings(item) && !item->GetPVRTimerInfoTag()->GetTimerType()->IsReadOnly())
-      g_PVRTimers->UpdateTimer(*item);
-  }
-
-  return bReturn;
-}
-
 bool CGUIWindowPVRTimersBase::OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button)
 {
   bool bReturn = false;
@@ -359,7 +349,7 @@ bool CGUIWindowPVRTimersBase::ActionDeleteTimer(CFileItem *item)
   {
     /* go to the parent folder if we're in a subdirectory and just deleted the last item */
     CPVRTimersPath path(m_vecItems->GetPath());
-    if (path.IsValid() && path.IsTimerSchedule())
+    if (path.IsValid() && path.IsTimerRule())
     {
       m_currentFileItem.reset();
       GoParentFolder();
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimersBase.h b/xbmc/pvr/windows/GUIWindowPVRTimersBase.h
index 25cc705..1701ad4 100644
--- a/xbmc/pvr/windows/GUIWindowPVRTimersBase.h
+++ b/xbmc/pvr/windows/GUIWindowPVRTimersBase.h
@@ -52,7 +52,6 @@ namespace PVR
     bool OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button);
     bool OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button);
     bool OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button);
-    bool OnContextButtonEdit(CFileItem *item, CONTEXT_BUTTON button);
     bool OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button);
     bool OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button);
 
